(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('@angular/cdk/platform'), require('rxjs/operators'), require('@angular/cdk/keycodes'), require('@angular/cdk/bidi'), require('@angular/cdk/portal'), require('@angular/animations'), require('@angular/cdk/coercion'), require('@angular/cdk/overlay'), require('@angular/common'), require('@angular/material/core'), require('@angular/material/dialog'), require('@angular/forms'), require('@angular/material/form-field'), require('@angular/material/input'), require('@angular/cdk/a11y'), require('@angular/material/button')) :
  typeof define === 'function' && define.amd ? define('saturn-datepicker', ['exports', '@angular/core', 'rxjs', '@angular/cdk/platform', 'rxjs/operators', '@angular/cdk/keycodes', '@angular/cdk/bidi', '@angular/cdk/portal', '@angular/animations', '@angular/cdk/coercion', '@angular/cdk/overlay', '@angular/common', '@angular/material/core', '@angular/material/dialog', '@angular/forms', '@angular/material/form-field', '@angular/material/input', '@angular/cdk/a11y', '@angular/material/button'], factory) :
  (factory((global['saturn-datepicker'] = {}),global.ng.core,global.rxjs,global.ng.cdk.platform,global.rxjs.operators,global.ng.cdk.keycodes,global.ng.cdk.bidi,global.ng.cdk.portal,global.ng.animations,global.ng.cdk.coercion,global.ng.cdk.overlay,global.ng.common,global.ng.material.core,global.ng.material.dialog,global.ng.forms,global.ng.material['form-field'],global.ng.material.input,global.ng.cdk.a11y,global.ng.material.button));
}(this, (function (exports,i0,rxjs,platform,operators,keycodes,bidi,portal,animations,coercion,overlay,common,core,dialog,forms,formField,input,a11y,button) { 'use strict';

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** *
   * InjectionToken for datepicker that can be used to override default locale code.
    @type {?} */
  var MAT_DATE_LOCALE = new i0.InjectionToken('MAT_DATE_LOCALE', {
      providedIn: 'root',
      factory: MAT_DATE_LOCALE_FACTORY,
  });
  /**
   * \@docs-private
   * @return {?}
   */
  function MAT_DATE_LOCALE_FACTORY() {
      return i0.inject(i0.LOCALE_ID);
  }
  /** *
   * No longer needed since MAT_DATE_LOCALE has been changed to a scoped injectable.
   * If you are importing and providing this in your code you can simply remove it.
   * @deprecated
   * \@breaking-change 7.0.0
    @type {?} */
  var MAT_DATE_LOCALE_PROVIDER = { provide: MAT_DATE_LOCALE, useExisting: i0.LOCALE_ID };
  /**
   * Adapts type `D` to be usable as a date by cdk-based components that work with dates.
   * @abstract
   * @template D
   */
  var /**
   * Adapts type `D` to be usable as a date by cdk-based components that work with dates.
   * @abstract
   * @template D
   */ DateAdapter = (function () {
      function DateAdapter() {
          this._localeChanges = new rxjs.Subject();
      }
      Object.defineProperty(DateAdapter.prototype, "localeChanges", {
          /** A stream that emits when the locale changes. */
          get: /**
           * A stream that emits when the locale changes.
           * @return {?}
           */ function () { return this._localeChanges; },
          enumerable: true,
          configurable: true
      });
      /**
       * Attempts to deserialize a value to a valid date object. This is different from parsing in that
       * deserialize should only accept non-ambiguous, locale-independent formats (e.g. a ISO 8601
       * string). The default implementation does not allow any deserialization, it simply checks that
       * the given value is already a valid date object or null. The `<sat-datepicker>` will call this
       * method on all of it's `@Input()` properties that accept dates. It is therefore possible to
       * support passing values from your backend directly to these properties by overriding this method
       * to also deserialize the format used by your backend.
       * @param value The value to be deserialized into a date object.
       * @returns The deserialized date object, either a valid date, null if the value can be
       *     deserialized into a null date (e.g. the empty string), or an invalid date.
       */
      /**
       * Attempts to deserialize a value to a valid date object. This is different from parsing in that
       * deserialize should only accept non-ambiguous, locale-independent formats (e.g. a ISO 8601
       * string). The default implementation does not allow any deserialization, it simply checks that
       * the given value is already a valid date object or null. The `<sat-datepicker>` will call this
       * method on all of it's `\@Input()` properties that accept dates. It is therefore possible to
       * support passing values from your backend directly to these properties by overriding this method
       * to also deserialize the format used by your backend.
       * @param {?} value The value to be deserialized into a date object.
       * @return {?} The deserialized date object, either a valid date, null if the value can be
       *     deserialized into a null date (e.g. the empty string), or an invalid date.
       */
      DateAdapter.prototype.deserialize = /**
       * Attempts to deserialize a value to a valid date object. This is different from parsing in that
       * deserialize should only accept non-ambiguous, locale-independent formats (e.g. a ISO 8601
       * string). The default implementation does not allow any deserialization, it simply checks that
       * the given value is already a valid date object or null. The `<sat-datepicker>` will call this
       * method on all of it's `\@Input()` properties that accept dates. It is therefore possible to
       * support passing values from your backend directly to these properties by overriding this method
       * to also deserialize the format used by your backend.
       * @param {?} value The value to be deserialized into a date object.
       * @return {?} The deserialized date object, either a valid date, null if the value can be
       *     deserialized into a null date (e.g. the empty string), or an invalid date.
       */
          function (value) {
              if (value == null || this.isDateInstance(value) && this.isValid(value)) {
                  return value;
              }
              return this.invalid();
          };
      /**
       * Sets the locale used for all dates.
       * @param locale The new locale.
       */
      /**
       * Sets the locale used for all dates.
       * @param {?} locale The new locale.
       * @return {?}
       */
      DateAdapter.prototype.setLocale = /**
       * Sets the locale used for all dates.
       * @param {?} locale The new locale.
       * @return {?}
       */
          function (locale) {
              this.locale = locale;
              this._localeChanges.next();
          };
      /**
       * Compares two dates.
       * @param first The first date to compare.
       * @param second The second date to compare.
       * @returns 0 if the dates are equal, a number less than 0 if the first date is earlier,
       *     a number greater than 0 if the first date is later.
       */
      /**
       * Compares two dates.
       * @param {?} first The first date to compare.
       * @param {?} second The second date to compare.
       * @return {?} 0 if the dates are equal, a number less than 0 if the first date is earlier,
       *     a number greater than 0 if the first date is later.
       */
      DateAdapter.prototype.compareDate = /**
       * Compares two dates.
       * @param {?} first The first date to compare.
       * @param {?} second The second date to compare.
       * @return {?} 0 if the dates are equal, a number less than 0 if the first date is earlier,
       *     a number greater than 0 if the first date is later.
       */
          function (first, second) {
              return this.getYear(first) - this.getYear(second) ||
                  this.getMonth(first) - this.getMonth(second) ||
                  this.getDate(first) - this.getDate(second);
          };
      /**
       * Checks if two dates are equal.
       * @param first The first date to check.
       * @param second The second date to check.
       * @returns Whether the two dates are equal.
       *     Null dates are considered equal to other null dates.
       */
      /**
       * Checks if two dates are equal.
       * @param {?} first The first date to check.
       * @param {?} second The second date to check.
       * @return {?} Whether the two dates are equal.
       *     Null dates are considered equal to other null dates.
       */
      DateAdapter.prototype.sameDate = /**
       * Checks if two dates are equal.
       * @param {?} first The first date to check.
       * @param {?} second The second date to check.
       * @return {?} Whether the two dates are equal.
       *     Null dates are considered equal to other null dates.
       */
          function (first, second) {
              if (first && second) {
                  /** @type {?} */
                  var firstValid = this.isValid(first);
                  /** @type {?} */
                  var secondValid = this.isValid(second);
                  if (firstValid && secondValid) {
                      return !this.compareDate(first, second);
                  }
                  return firstValid == secondValid;
              }
              return first == second;
          };
      /**
       * Clamp the given date between min and max dates.
       * @param date The date to clamp.
       * @param min The minimum value to allow. If null or omitted no min is enforced.
       * @param max The maximum value to allow. If null or omitted no max is enforced.
       * @returns `min` if `date` is less than `min`, `max` if date is greater than `max`,
       *     otherwise `date`.
       */
      /**
       * Clamp the given date between min and max dates.
       * @param {?} date The date to clamp.
       * @param {?=} min The minimum value to allow. If null or omitted no min is enforced.
       * @param {?=} max The maximum value to allow. If null or omitted no max is enforced.
       * @return {?} `min` if `date` is less than `min`, `max` if date is greater than `max`,
       *     otherwise `date`.
       */
      DateAdapter.prototype.clampDate = /**
       * Clamp the given date between min and max dates.
       * @param {?} date The date to clamp.
       * @param {?=} min The minimum value to allow. If null or omitted no min is enforced.
       * @param {?=} max The maximum value to allow. If null or omitted no max is enforced.
       * @return {?} `min` if `date` is less than `min`, `max` if date is greater than `max`,
       *     otherwise `date`.
       */
          function (date, min, max) {
              if (min && this.compareDate(date, min) < 0) {
                  return min;
              }
              if (max && this.compareDate(date, max) > 0) {
                  return max;
              }
              return date;
          };
      return DateAdapter;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** @type {?} */
  var MAT_DATE_FORMATS = new i0.InjectionToken('mat-date-formats');

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
  /* global Reflect, Promise */
  var extendStatics = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b)
          if (b.hasOwnProperty(p))
              d[p] = b[p]; };
  function __extends(d, b) {
      extendStatics(d, b);
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                  t[p] = s[p];
      }
      return t;
  };

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** *
   * Whether the browser supports the Intl API.
    @type {?} */
  var SUPPORTS_INTL_API = typeof Intl != 'undefined';
  /** *
   * The default month names to use if Intl API is not available.
    @type {?} */
  var DEFAULT_MONTH_NAMES = {
      'long': [
          'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September',
          'October', 'November', 'December'
      ],
      'short': ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
      'narrow': ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D']
  };
  var ɵ0 = function (i) { return String(i + 1); };
  /** *
   * The default date names to use if Intl API is not available.
    @type {?} */
  var DEFAULT_DATE_NAMES = range(31, ɵ0);
  /** *
   * The default day of the week names to use if Intl API is not available.
    @type {?} */
  var DEFAULT_DAY_OF_WEEK_NAMES = {
      'long': ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
      'short': ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
      'narrow': ['S', 'M', 'T', 'W', 'T', 'F', 'S']
  };
  /** *
   * First day of week according locale.
   * Taken form moment.js source code https://github.com/moment/moment/tree/develop/src/locale
    @type {?} */
  var FIRST_DAY_OF_WEEK = {
      af: 1, ar: 6, 'ar-ly': 6, 'ar-ma': 6, 'ar-tn': 1, az: 1, be: 1, bg: 1, bm: 1, br: 1, bs: 1, ca: 1, cs: 1, cv: 1,
      cy: 1, da: 1, de: 1, 'de-at': 1, 'de-ch': 1, el: 1, 'en-au': 1, 'en-gb': 1, 'en-ie': 1, 'en-nz': 1, eo: 1,
      es: 1, 'es-do': 1, et: 1, eu: 1, fa: 6, fi: 1, fo: 1, fr: 1, 'fr-ch': 1, fy: 1, gd: 1, gl: 1, 'gom-latn': 1,
      hr: 1, hu: 1, 'hy-am': 1, id: 1, is: 1, it: 1, jv: 1, ka: 1, kk: 1, km: 1, ky: 1, lb: 1, lt: 1, lv: 1, me: 1,
      mi: 1, mk: 1, ms: 1, 'ms-my': 1, mt: 1, my: 1, nb: 1, nl: 1, 'nl-be': 1, nn: 1, pl: 1, pt: 1, 'pt-BR': 0, ro: 1, ru: 1,
      sd: 1, se: 1, sk: 1, sl: 1, sq: 1, sr: 1, 'sr-cyrl': 1, ss: 1, sv: 1, sw: 1, 'tet': 1, tg: 1, 'tl-ph': 1,
      'tlh': 1, tr: 1, 'tzl': 1, 'tzm': 6, 'tzm-latn': 6, 'ug-cn': 1, uk: 1, ur: 1, uz: 1, 'uz-latn': 1, vi: 1,
      'x-pseudo': 1, yo: 1, 'zh-cn': 1,
  };
  /** *
   * Matches strings that have the form of a valid RFC 3339 string
   * (https://tools.ietf.org/html/rfc3339). Note that the string may not actually be a valid date
   * because the regex will match strings an with out of bounds month, date, etc.
    @type {?} */
  var ISO_8601_REGEX = /^\d{4}-\d{2}-\d{2}(?:T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|(?:(?:\+|-)\d{2}:\d{2}))?)?$/;
  /**
   * Creates an array and fills it with values.
   * @template T
   * @param {?} length
   * @param {?} valueFunction
   * @return {?}
   */
  function range(length, valueFunction) {
      /** @type {?} */
      var valuesArray = Array(length);
      for (var i = 0; i < length; i++) {
          valuesArray[i] = valueFunction(i);
      }
      return valuesArray;
  }
  /**
   * Adapts the native JS Date for use with cdk-based components that work with dates.
   */
  var NativeDateAdapter = (function (_super) {
      __extends(NativeDateAdapter, _super);
      function NativeDateAdapter(matDateLocale, platform$$1) {
          var _this = _super.call(this) || this;
          /**
           * Whether to use `timeZone: 'utc'` with `Intl.DateTimeFormat` when formatting dates.
           * Without this `Intl.DateTimeFormat` sometimes chooses the wrong timeZone, which can throw off
           * the result. (e.g. in the en-US locale `new Date(1800, 7, 14).toLocaleDateString()`
           * will produce `'8/13/1800'`.
           *
           * TODO(mmalerba): drop this variable. It's not being used in the code right now. We're now
           * getting the string representation of a Date object from it's utc representation. We're keeping
           * it here for sometime, just for precaution, in case we decide to revert some of these changes
           * though.
           */
          _this.useUtcForDisplay = true;
          _super.prototype.setLocale.call(_this, matDateLocale);
          // IE does its own time zone correction, so we disable this on IE.
          // IE does its own time zone correction, so we disable this on IE.
          _this.useUtcForDisplay = !platform$$1.TRIDENT;
          _this._clampDate = platform$$1.TRIDENT || platform$$1.EDGE;
          return _this;
      }
      /**
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype.getYear = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return date.getFullYear();
          };
      /**
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype.getMonth = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return date.getMonth();
          };
      /**
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype.getDate = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return date.getDate();
          };
      /**
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype.getDayOfWeek = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return date.getDay();
          };
      /**
       * @param {?} style
       * @return {?}
       */
      NativeDateAdapter.prototype.getMonthNames = /**
       * @param {?} style
       * @return {?}
       */
          function (style) {
              var _this = this;
              if (SUPPORTS_INTL_API) {
                  /** @type {?} */
                  var dtf_1 = new Intl.DateTimeFormat(this.locale, { month: style, timeZone: 'utc' });
                  return range(12, function (i) {
                      return _this._stripDirectionalityCharacters(_this._format(dtf_1, new Date(2017, i, 1)));
                  });
              }
              return DEFAULT_MONTH_NAMES[style];
          };
      /**
       * @return {?}
       */
      NativeDateAdapter.prototype.getDateNames = /**
       * @return {?}
       */
          function () {
              var _this = this;
              if (SUPPORTS_INTL_API) {
                  /** @type {?} */
                  var dtf_2 = new Intl.DateTimeFormat(this.locale, { day: 'numeric', timeZone: 'utc' });
                  return range(31, function (i) { return _this._stripDirectionalityCharacters(_this._format(dtf_2, new Date(2017, 0, i + 1))); });
              }
              return DEFAULT_DATE_NAMES;
          };
      /**
       * @param {?} style
       * @return {?}
       */
      NativeDateAdapter.prototype.getDayOfWeekNames = /**
       * @param {?} style
       * @return {?}
       */
          function (style) {
              var _this = this;
              if (SUPPORTS_INTL_API) {
                  /** @type {?} */
                  var dtf_3 = new Intl.DateTimeFormat(this.locale, { weekday: style, timeZone: 'utc' });
                  return range(7, function (i) { return _this._stripDirectionalityCharacters(_this._format(dtf_3, new Date(2017, 0, i + 1))); });
              }
              return DEFAULT_DAY_OF_WEEK_NAMES[style];
          };
      /**
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype.getYearName = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              if (SUPPORTS_INTL_API) {
                  /** @type {?} */
                  var dtf = new Intl.DateTimeFormat(this.locale, { year: 'numeric', timeZone: 'utc' });
                  return this._stripDirectionalityCharacters(this._format(dtf, date));
              }
              return String(this.getYear(date));
          };
      /**
       * @return {?}
       */
      NativeDateAdapter.prototype.getFirstDayOfWeek = /**
       * @return {?}
       */
          function () {
              /** @type {?} */
              var locale = this.locale.toLowerCase();
              return FIRST_DAY_OF_WEEK[locale] || FIRST_DAY_OF_WEEK[locale.substr(0, 2)] || 0;
          };
      /**
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype.getNumDaysInMonth = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return this.getDate(this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + 1, 0));
          };
      /**
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype.clone = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return this.createDate(this.getYear(date), this.getMonth(date), this.getDate(date));
          };
      /**
       * @param {?} year
       * @param {?} month
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype.createDate = /**
       * @param {?} year
       * @param {?} month
       * @param {?} date
       * @return {?}
       */
          function (year, month, date) {
              // Check for invalid month and date (except upper bound on date which we have to check after
              // creating the Date).
              if (month < 0 || month > 11) {
                  throw Error("Invalid month index \"" + month + "\". Month index has to be between 0 and 11.");
              }
              if (date < 1) {
                  throw Error("Invalid date \"" + date + "\". Date has to be greater than 0.");
              }
              /** @type {?} */
              var result = this._createDateWithOverflow(year, month, date);
              // Check that the date wasn't above the upper bound for the month, causing the month to overflow
              if (result.getMonth() != month) {
                  throw Error("Invalid date \"" + date + "\" for month with index \"" + month + "\".");
              }
              return result;
          };
      /**
       * @return {?}
       */
      NativeDateAdapter.prototype.today = /**
       * @return {?}
       */
          function () {
              return new Date();
          };
      /**
       * @param {?} value
       * @return {?}
       */
      NativeDateAdapter.prototype.parse = /**
       * @param {?} value
       * @return {?}
       */
          function (value) {
              // We have no way using the native JS Date to set the parse format or locale, so we ignore these
              // parameters.
              if (typeof value == 'number') {
                  return new Date(value);
              }
              return value ? new Date(Date.parse(value)) : null;
          };
      /**
       * @param {?} date
       * @param {?} displayFormat
       * @return {?}
       */
      NativeDateAdapter.prototype.format = /**
       * @param {?} date
       * @param {?} displayFormat
       * @return {?}
       */
          function (date, displayFormat) {
              if (!this.isValid(date)) {
                  throw Error('NativeDateAdapter: Cannot format invalid date.');
              }
              if (SUPPORTS_INTL_API) {
                  // On IE and Edge the i18n API will throw a hard error that can crash the entire app
                  // if we attempt to format a date whose year is less than 1 or greater than 9999.
                  if (this._clampDate && (date.getFullYear() < 1 || date.getFullYear() > 9999)) {
                      date = this.clone(date);
                      date.setFullYear(Math.max(1, Math.min(9999, date.getFullYear())));
                  }
                  displayFormat = __assign({}, displayFormat, { timeZone: 'utc' });
                  /** @type {?} */
                  var dtf = new Intl.DateTimeFormat(this.locale, displayFormat);
                  return this._stripDirectionalityCharacters(this._format(dtf, date));
              }
              return this._stripDirectionalityCharacters(date.toDateString());
          };
      /**
       * @param {?} date
       * @param {?} years
       * @return {?}
       */
      NativeDateAdapter.prototype.addCalendarYears = /**
       * @param {?} date
       * @param {?} years
       * @return {?}
       */
          function (date, years) {
              return this.addCalendarMonths(date, years * 12);
          };
      /**
       * @param {?} date
       * @param {?} months
       * @return {?}
       */
      NativeDateAdapter.prototype.addCalendarMonths = /**
       * @param {?} date
       * @param {?} months
       * @return {?}
       */
          function (date, months) {
              /** @type {?} */
              var newDate = this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + months, this.getDate(date));
              // It's possible to wind up in the wrong month if the original month has more days than the new
              // month. In this case we want to go to the last day of the desired month.
              // Note: the additional + 12 % 12 ensures we end up with a positive number, since JS % doesn't
              // guarantee this.
              if (this.getMonth(newDate) != ((this.getMonth(date) + months) % 12 + 12) % 12) {
                  newDate = this._createDateWithOverflow(this.getYear(newDate), this.getMonth(newDate), 0);
              }
              return newDate;
          };
      /**
       * @param {?} date
       * @param {?} days
       * @return {?}
       */
      NativeDateAdapter.prototype.addCalendarDays = /**
       * @param {?} date
       * @param {?} days
       * @return {?}
       */
          function (date, days) {
              return this._createDateWithOverflow(this.getYear(date), this.getMonth(date), this.getDate(date) + days);
          };
      /**
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype.toIso8601 = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return [
                  date.getUTCFullYear(),
                  this._2digit(date.getUTCMonth() + 1),
                  this._2digit(date.getUTCDate())
              ].join('-');
          };
      /**
       * Returns the given value if given a valid Date or null. Deserializes valid ISO 8601 strings
       * (https://www.ietf.org/rfc/rfc3339.txt) into valid Dates and empty string into null. Returns an
       * invalid date for all other values.
       */
      /**
       * Returns the given value if given a valid Date or null. Deserializes valid ISO 8601 strings
       * (https://www.ietf.org/rfc/rfc3339.txt) into valid Dates and empty string into null. Returns an
       * invalid date for all other values.
       * @param {?} value
       * @return {?}
       */
      NativeDateAdapter.prototype.deserialize = /**
       * Returns the given value if given a valid Date or null. Deserializes valid ISO 8601 strings
       * (https://www.ietf.org/rfc/rfc3339.txt) into valid Dates and empty string into null. Returns an
       * invalid date for all other values.
       * @param {?} value
       * @return {?}
       */
          function (value) {
              if (typeof value === 'string') {
                  if (!value) {
                      return null;
                  }
                  // The `Date` constructor accepts formats other than ISO 8601, so we need to make sure the
                  // string is the right format first.
                  if (ISO_8601_REGEX.test(value)) {
                      /** @type {?} */
                      var date = new Date(value);
                      if (this.isValid(date)) {
                          return date;
                      }
                  }
              }
              return _super.prototype.deserialize.call(this, value);
          };
      /**
       * @param {?} obj
       * @return {?}
       */
      NativeDateAdapter.prototype.isDateInstance = /**
       * @param {?} obj
       * @return {?}
       */
          function (obj) {
              return obj instanceof Date;
          };
      /**
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype.isValid = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return !isNaN(date.getTime());
          };
      /**
       * @return {?}
       */
      NativeDateAdapter.prototype.invalid = /**
       * @return {?}
       */
          function () {
              return new Date(NaN);
          };
      /**
       * Creates a date but allows the month and date to overflow.
       * @param {?} year
       * @param {?} month
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype._createDateWithOverflow = /**
       * Creates a date but allows the month and date to overflow.
       * @param {?} year
       * @param {?} month
       * @param {?} date
       * @return {?}
       */
          function (year, month, date) {
              /** @type {?} */
              var result = new Date(year, month, date);
              // We need to correct for the fact that JS native Date treats years in range [0, 99] as
              // abbreviations for 19xx.
              if (year >= 0 && year < 100) {
                  result.setFullYear(this.getYear(result) - 1900);
              }
              return result;
          };
      /**
       * Pads a number to make it two digits.
       * @param {?} n The number to pad.
       * @return {?} The padded number.
       */
      NativeDateAdapter.prototype._2digit = /**
       * Pads a number to make it two digits.
       * @param {?} n The number to pad.
       * @return {?} The padded number.
       */
          function (n) {
              return ('00' + n).slice(-2);
          };
      /**
       * Strip out unicode LTR and RTL characters. Edge and IE insert these into formatted dates while
       * other browsers do not. We remove them to make output consistent and because they interfere with
       * date parsing.
       * @param {?} str The string to strip direction characters from.
       * @return {?} The stripped string.
       */
      NativeDateAdapter.prototype._stripDirectionalityCharacters = /**
       * Strip out unicode LTR and RTL characters. Edge and IE insert these into formatted dates while
       * other browsers do not. We remove them to make output consistent and because they interfere with
       * date parsing.
       * @param {?} str The string to strip direction characters from.
       * @return {?} The stripped string.
       */
          function (str) {
              return str.replace(/[\u200e\u200f]/g, '');
          };
      /**
       * When converting Date object to string, javascript built-in functions may return wrong
       * results because it applies its internal DST rules. The DST rules around the world change
       * very frequently, and the current valid rule is not always valid in previous years though.
       * We work around this problem building a new Date object which has its internal UTC
       * representation with the local date and time.
       * @param {?} dtf Intl.DateTimeFormat object, containg the desired string format. It must have
       *    timeZone set to 'utc' to work fine.
       * @param {?} date Date from which we want to get the string representation according to dtf
       * @return {?} A Date object with its UTC representation based on the passed in date info
       */
      NativeDateAdapter.prototype._format = /**
       * When converting Date object to string, javascript built-in functions may return wrong
       * results because it applies its internal DST rules. The DST rules around the world change
       * very frequently, and the current valid rule is not always valid in previous years though.
       * We work around this problem building a new Date object which has its internal UTC
       * representation with the local date and time.
       * @param {?} dtf Intl.DateTimeFormat object, containg the desired string format. It must have
       *    timeZone set to 'utc' to work fine.
       * @param {?} date Date from which we want to get the string representation according to dtf
       * @return {?} A Date object with its UTC representation based on the passed in date info
       */
          function (dtf, date) {
              /** @type {?} */
              var d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
              return dtf.format(d);
          };
      NativeDateAdapter.decorators = [
          { type: i0.Injectable }
      ];
      /** @nocollapse */
      NativeDateAdapter.ctorParameters = function () {
          return [
              { type: String, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [MAT_DATE_LOCALE,] }] },
              { type: platform.Platform }
          ];
      };
      return NativeDateAdapter;
  }(DateAdapter));

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /** @type {?} */
  var MAT_NATIVE_DATE_FORMATS = {
      parse: {
          dateInput: null,
      },
      display: {
          dateInput: { year: 'numeric', month: 'numeric', day: 'numeric' },
          monthYearLabel: { year: 'numeric', month: 'short' },
          dateA11yLabel: { year: 'numeric', month: 'long', day: 'numeric' },
          monthYearA11yLabel: { year: 'numeric', month: 'long' },
      }
  };

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var NativeDateModule = (function () {
      function NativeDateModule() {
      }
      NativeDateModule.decorators = [
          { type: i0.NgModule, args: [{
                      imports: [platform.PlatformModule],
                      providers: [
                          { provide: DateAdapter, useClass: NativeDateAdapter },
                      ],
                  },] }
      ];
      return NativeDateModule;
  }());
  var ɵ0$1 = MAT_NATIVE_DATE_FORMATS;
  var SatNativeDateModule = (function () {
      function SatNativeDateModule() {
      }
      SatNativeDateModule.decorators = [
          { type: i0.NgModule, args: [{
                      imports: [NativeDateModule],
                      providers: [{ provide: MAT_DATE_FORMATS, useValue: ɵ0$1 }],
                  },] }
      ];
      return SatNativeDateModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * \@docs-private
   * @param {?} provider
   * @return {?}
   */
  function createMissingDateImplError(provider) {
      return Error("SatDatepicker: No provider found for " + provider + ". You must import one of the following " +
          "modules at your application root: SatNativeDateModule, MatMomentDateModule, or provide a " +
          "custom implementation.");
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Datepicker data that requires internationalization.
   */
  var SatDatepickerIntl = (function () {
      function SatDatepickerIntl() {
          /**
           * Stream that emits whenever the labels here are changed. Use this to notify
           * components if the labels have changed after initialization.
           */
          this.changes = new rxjs.Subject();
          /**
           * A label for the calendar popup (used by screen readers).
           */
          this.calendarLabel = 'Calendar';
          /**
           * A label for the button used to open the calendar popup (used by screen readers).
           */
          this.openCalendarLabel = 'Open calendar';
          /**
           * A label for the previous month button (used by screen readers).
           */
          this.prevMonthLabel = 'Previous month';
          /**
           * A label for the next month button (used by screen readers).
           */
          this.nextMonthLabel = 'Next month';
          /**
           * A label for the previous year button (used by screen readers).
           */
          this.prevYearLabel = 'Previous year';
          /**
           * A label for the next year button (used by screen readers).
           */
          this.nextYearLabel = 'Next year';
          /**
           * A label for the previous multi-year button (used by screen readers).
           */
          this.prevMultiYearLabel = 'Previous 20 years';
          /**
           * A label for the next multi-year button (used by screen readers).
           */
          this.nextMultiYearLabel = 'Next 20 years';
          /**
           * A label for the 'switch to month view' button (used by screen readers).
           */
          this.switchToMonthViewLabel = 'Choose date';
          /**
           * A label for the 'switch to year view' button (used by screen readers).
           */
          this.switchToMultiYearViewLabel = 'Choose month and year';
      }
      SatDatepickerIntl.decorators = [
          { type: i0.Injectable, args: [{ providedIn: 'root' },] }
      ];
      /** @nocollapse */ SatDatepickerIntl.ngInjectableDef = i0.defineInjectable({ factory: function SatDatepickerIntl_Factory() { return new SatDatepickerIntl(); }, token: SatDatepickerIntl, providedIn: "root" });
      return SatDatepickerIntl;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * An internal class that represents the data corresponding to a single calendar cell.
   * \@docs-private
   */
  var /**
   * An internal class that represents the data corresponding to a single calendar cell.
   * \@docs-private
   */ SatCalendarCell = (function () {
      function SatCalendarCell(value, displayValue, ariaLabel, enabled) {
          this.value = value;
          this.displayValue = displayValue;
          this.ariaLabel = ariaLabel;
          this.enabled = enabled;
      }
      return SatCalendarCell;
  }());
  /**
   * An internal component used to display calendar data in a table.
   * \@docs-private
   */
  var SatCalendarBody = (function () {
      function SatCalendarBody(_elementRef, _ngZone) {
          this._elementRef = _elementRef;
          this._ngZone = _ngZone;
          /**
           * Whether to use date range selection behaviour.
           */
          this.rangeMode = false;
          /**
           * The number of columns in the table.
           */
          this.numCols = 7;
          /**
           * Whether to allow selection of disabled cells.
           */
          this.allowDisabledSelection = false;
          /**
           * The cell number of the active cell in the table.
           */
          this.activeCell = 0;
          /**
           * The aspect ratio (width / height) to use for the cells in the table. This aspect ratio will be
           * maintained even as the table resizes.
           */
          this.cellAspectRatio = 1;
          /**
           * Emits when a new value is selected.
           */
          this.selectedValueChange = new i0.EventEmitter();
      }
      /**
       * @param {?} cell
       * @return {?}
       */
      SatCalendarBody.prototype._cellClicked = /**
       * @param {?} cell
       * @return {?}
       */
          function (cell) {
              if (!this.allowDisabledSelection && !cell.enabled) {
                  return;
              }
              this.selectedValueChange.emit(cell.value);
          };
      Object.defineProperty(SatCalendarBody.prototype, "_firstRowOffset", {
          /** The number of blank cells to put at the beginning for the first row. */
          get: /**
           * The number of blank cells to put at the beginning for the first row.
           * @return {?}
           */ function () {
              return this.rows && this.rows.length && this.rows[0].length ?
                  this.numCols - this.rows[0].length : 0;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @param {?} rowIndex
       * @param {?} colIndex
       * @return {?}
       */
      SatCalendarBody.prototype._isActiveCell = /**
       * @param {?} rowIndex
       * @param {?} colIndex
       * @return {?}
       */
          function (rowIndex, colIndex) {
              /** @type {?} */
              var cellNumber = rowIndex * this.numCols + colIndex;
              // Account for the fact that the first row may not have as many cells.
              if (rowIndex) {
                  cellNumber -= this._firstRowOffset;
              }
              return cellNumber == this.activeCell;
          };
      /** Whenever to mark cell as semi-selected (inside dates interval). */
      /**
       * Whenever to mark cell as semi-selected (inside dates interval).
       * @param {?} date
       * @return {?}
       */
      SatCalendarBody.prototype._isSemiSelected = /**
       * Whenever to mark cell as semi-selected (inside dates interval).
       * @param {?} date
       * @return {?}
       */
          function (date) {
              if (!this.rangeMode) {
                  return false;
              }
              if (this.rangeFull) {
                  return true;
              }
              /** Do not mark start and end of interval. */
              if (date === this.begin || date === this.end) {
                  return false;
              }
              if (this.begin && !this.end) {
                  return date > this.begin;
              }
              if (this.end && !this.begin) {
                  return date < this.end;
              }
              return date > /** @type {?} */ (this.begin) && date < /** @type {?} */ (this.end);
          };
      /** Focuses the active cell after the microtask queue is empty. */
      /**
       * Focuses the active cell after the microtask queue is empty.
       * @return {?}
       */
      SatCalendarBody.prototype._focusActiveCell = /**
       * Focuses the active cell after the microtask queue is empty.
       * @return {?}
       */
          function () {
              var _this = this;
              this._ngZone.runOutsideAngular(function () {
                  _this._ngZone.onStable.asObservable().pipe(operators.take(1)).subscribe(function () {
                      _this._elementRef.nativeElement.querySelector('.mat-calendar-body-active').focus();
                  });
              });
          };
      SatCalendarBody.decorators = [
          { type: i0.Component, args: [{
                      moduleId: module.id,
                      selector: '[sat-calendar-body]',
                      template: "<!--\n  If there's not enough space in the first row, create a separate label row. We mark this row as\n  aria-hidden because we don't want it to be read out as one of the weeks in the month.\n-->\n<tr *ngIf=\"_firstRowOffset < labelMinRequiredCells\" aria-hidden=\"true\">\n  <td class=\"mat-calendar-body-label\"\n      [attr.colspan]=\"numCols\"\n      [style.paddingTop.%]=\"50 * cellAspectRatio / numCols\"\n      [style.paddingBottom.%]=\"50 * cellAspectRatio / numCols\">\n    {{label}}\n  </td>\n</tr>\n\n<!-- Create the first row separately so we can include a special spacer cell. -->\n<tr *ngFor=\"let row of rows; let rowIndex = index\" role=\"row\">\n  <!--\n    We mark this cell as aria-hidden so it doesn't get read out as one of the days in the week.\n    The aspect ratio of the table cells is maintained by setting the top and bottom padding as a\n    percentage of the width (a variant of the trick described here:\n    https://www.w3schools.com/howto/howto_css_aspect_ratio.asp).\n  -->\n  <td *ngIf=\"rowIndex === 0 && _firstRowOffset\"\n      aria-hidden=\"true\"\n      class=\"mat-calendar-body-label\"\n      [attr.colspan]=\"_firstRowOffset\"\n      [style.paddingTop.%]=\"50 * cellAspectRatio / numCols\"\n      [style.paddingBottom.%]=\"50 * cellAspectRatio / numCols\">\n    {{_firstRowOffset >= labelMinRequiredCells ? label : ''}}\n  </td>\n  <td *ngFor=\"let item of row; let colIndex = index\"\n      role=\"gridcell\"\n      class=\"mat-calendar-body-cell\"\n      [tabindex]=\"_isActiveCell(rowIndex, colIndex) ? 0 : -1\"\n      [class.mat-calendar-body-disabled]=\"!item.enabled\"\n      [class.mat-calendar-body-active]=\"_isActiveCell(rowIndex, colIndex)\"\n      [class.mat-calendar-body-begin-range]=\"begin === item.value\"\n      [class.mat-calendar-body-end-range]=\"end === item.value\"\n      [class.mat-calendar-cell-semi-selected]=\"_isSemiSelected(item.value)\"\n      [attr.aria-label]=\"item.ariaLabel\"\n      [attr.aria-disabled]=\"!item.enabled || null\"\n      [attr.aria-selected]=\"selectedValue === item.value\"\n      (click)=\"_cellClicked(item)\"\n      [style.width.%]=\"100 / numCols\"\n      [style.paddingTop.%]=\"50 * cellAspectRatio / numCols\"\n      [style.paddingBottom.%]=\"50 * cellAspectRatio / numCols\">\n    <div class=\"mat-calendar-body-cell-content\"\n         [class.mat-calendar-body-selected]=\"begin === item.value || end === item.value || selectedValue === item.value\"\n         [class.mat-calendar-body-semi-selected]=\"_isSemiSelected(item.value)\"\n         [class.mat-calendar-body-today]=\"todayValue === item.value\">\n      {{item.displayValue}}\n    </div>\n  </td>\n</tr>\n",
                      host: {
                          'class': 'mat-calendar-body',
                          'role': 'grid',
                          'attr.aria-readonly': 'true'
                      },
                      exportAs: 'matCalendarBody',
                      encapsulation: i0.ViewEncapsulation.None,
                      changeDetection: i0.ChangeDetectionStrategy.OnPush,
                      styles: [".mat-calendar-body{min-width:224px}.mat-calendar-body-label{height:0;line-height:0;text-align:left;padding-left:4.71429%;padding-right:4.71429%}.mat-calendar-body-cell{position:relative;height:0;line-height:0;text-align:center;outline:0;cursor:pointer}.mat-calendar-body-disabled{cursor:default}.mat-calendar-body-cell-content{position:absolute;top:5%;left:5%;display:flex;align-items:center;justify-content:center;box-sizing:border-box;width:90%;height:90%;line-height:1;border-width:1px;border-style:solid;border-radius:999px}[dir=rtl] .mat-calendar-body-label{text-align:right}"]
                  }] }
      ];
      /** @nocollapse */
      SatCalendarBody.ctorParameters = function () {
          return [
              { type: i0.ElementRef },
              { type: i0.NgZone }
          ];
      };
      SatCalendarBody.propDecorators = {
          label: [{ type: i0.Input }],
          rows: [{ type: i0.Input }],
          todayValue: [{ type: i0.Input }],
          selectedValue: [{ type: i0.Input }],
          begin: [{ type: i0.Input }],
          end: [{ type: i0.Input }],
          rangeFull: [{ type: i0.Input }],
          rangeMode: [{ type: i0.Input }],
          labelMinRequiredCells: [{ type: i0.Input }],
          numCols: [{ type: i0.Input }],
          allowDisabledSelection: [{ type: i0.Input }],
          activeCell: [{ type: i0.Input }],
          cellAspectRatio: [{ type: i0.Input }],
          selectedValueChange: [{ type: i0.Output }]
      };
      return SatCalendarBody;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** @type {?} */
  var DAYS_PER_WEEK = 7;
  /**
   * An internal component used to display a single month in the datepicker.
   * \@docs-private
   * @template D
   */
  var SatMonthView = (function () {
      function SatMonthView(_changeDetectorRef, _dateFormats, _dateAdapter, _dir) {
          this._changeDetectorRef = _changeDetectorRef;
          this._dateFormats = _dateFormats;
          this._dateAdapter = _dateAdapter;
          this._dir = _dir;
          /**
           * Allow selecting range of dates.
           */
          this.rangeMode = false;
          /**
           * Whenever full month is inside dates interval.
           */
          this._rangeFull = false;
          /**
           * Whenever user already selected start of dates interval.
           */
          this._beginDateSelected = false;
          /**
           * Emits when a new date is selected.
           */
          this.selectedChange = new i0.EventEmitter();
          /**
           * Emits when any date is selected.
           */
          this._userSelection = new i0.EventEmitter();
          /**
           * Emits when any date is activated.
           */
          this.activeDateChange = new i0.EventEmitter();
          if (!this._dateAdapter) {
              throw createMissingDateImplError('DateAdapter');
          }
          if (!this._dateFormats) {
              throw createMissingDateImplError('MAT_DATE_FORMATS');
          }
          /** @type {?} */
          var firstDayOfWeek = this._dateAdapter.getFirstDayOfWeek();
          /** @type {?} */
          var narrowWeekdays = this._dateAdapter.getDayOfWeekNames('narrow');
          /** @type {?} */
          var longWeekdays = this._dateAdapter.getDayOfWeekNames('long');
          /** @type {?} */
          var weekdays = longWeekdays.map(function (long, i) {
              return { long: long, narrow: narrowWeekdays[i] };
          });
          this._weekdays = weekdays.slice(firstDayOfWeek).concat(weekdays.slice(0, firstDayOfWeek));
          this._activeDate = this._dateAdapter.today();
      }
      Object.defineProperty(SatMonthView.prototype, "beginDate", {
          /** Current start of interval. */
          get: /**
           * Current start of interval.
           * @return {?}
           */ function () { return this._beginDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._beginDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
              this.updateRangeSpecificValues();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatMonthView.prototype, "endDate", {
          /** Current end of interval. */
          get: /**
           * Current end of interval.
           * @return {?}
           */ function () { return this._endDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._endDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
              this.updateRangeSpecificValues();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatMonthView.prototype, "activeDate", {
          /**
           * The date to display in this month view (everything other than the month and year is ignored).
           */
          get: /**
           * The date to display in this month view (everything other than the month and year is ignored).
           * @return {?}
           */ function () { return this._activeDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              /** @type {?} */
              var oldActiveDate = this._activeDate;
              /** @type {?} */
              var validDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();
              this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);
              if (!this._hasSameMonthAndYear(oldActiveDate, this._activeDate)) {
                  this._init();
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatMonthView.prototype, "selected", {
          /** The currently selected date. */
          get: /**
           * The currently selected date.
           * @return {?}
           */ function () { return this._selected; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
              this._selectedDate = this._getDateInCurrentMonth(this._selected);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatMonthView.prototype, "minDate", {
          /** The minimum selectable date. */
          get: /**
           * The minimum selectable date.
           * @return {?}
           */ function () { return this._minDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatMonthView.prototype, "maxDate", {
          /** The maximum selectable date. */
          get: /**
           * The maximum selectable date.
           * @return {?}
           */ function () { return this._maxDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      SatMonthView.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              this._init();
          };
      /** Handles when a new date is selected. */
      /**
       * Handles when a new date is selected.
       * @param {?} date
       * @return {?}
       */
      SatMonthView.prototype._dateSelected = /**
       * Handles when a new date is selected.
       * @param {?} date
       * @return {?}
       */
          function (date) {
              if (this.rangeMode) {
                  /** @type {?} */
                  var selectedYear = this._dateAdapter.getYear(this.activeDate);
                  /** @type {?} */
                  var selectedMonth = this._dateAdapter.getMonth(this.activeDate);
                  /** @type {?} */
                  var selectedDate = this._dateAdapter.createDate(selectedYear, selectedMonth, date);
                  if (!this._beginDateSelected) {
                      // At first click emit the same start and end of interval
                      this._beginDateSelected = true;
                      this.selectedChange.emit(selectedDate);
                  }
                  else {
                      this._beginDateSelected = false;
                      this.selectedChange.emit(selectedDate);
                      this._userSelection.emit();
                  }
              }
              else if (this._selectedDate != date) {
                  /** @type {?} */
                  var selectedYear = this._dateAdapter.getYear(this.activeDate);
                  /** @type {?} */
                  var selectedMonth = this._dateAdapter.getMonth(this.activeDate);
                  /** @type {?} */
                  var selectedDate = this._dateAdapter.createDate(selectedYear, selectedMonth, date);
                  this.selectedChange.emit(selectedDate);
                  this._userSelection.emit();
              }
          };
      /** Handles keydown events on the calendar body when calendar is in month view. */
      /**
       * Handles keydown events on the calendar body when calendar is in month view.
       * @param {?} event
       * @return {?}
       */
      SatMonthView.prototype._handleCalendarBodyKeydown = /**
       * Handles keydown events on the calendar body when calendar is in month view.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              /** @type {?} */
              var oldActiveDate = this._activeDate;
              /** @type {?} */
              var isRtl = this._isRtl();
              switch (event.keyCode) {
                  case keycodes.LEFT_ARROW:
                      this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, isRtl ? 1 : -1);
                      break;
                  case keycodes.RIGHT_ARROW:
                      this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, isRtl ? -1 : 1);
                      break;
                  case keycodes.UP_ARROW:
                      this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, -7);
                      break;
                  case keycodes.DOWN_ARROW:
                      this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 7);
                      break;
                  case keycodes.HOME:
                      this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 1 - this._dateAdapter.getDate(this._activeDate));
                      break;
                  case keycodes.END:
                      this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, (this._dateAdapter.getNumDaysInMonth(this._activeDate) -
                          this._dateAdapter.getDate(this._activeDate)));
                      break;
                  case keycodes.PAGE_UP:
                      this.activeDate = event.altKey ?
                          this._dateAdapter.addCalendarYears(this._activeDate, -1) :
                          this._dateAdapter.addCalendarMonths(this._activeDate, -1);
                      break;
                  case keycodes.PAGE_DOWN:
                      this.activeDate = event.altKey ?
                          this._dateAdapter.addCalendarYears(this._activeDate, 1) :
                          this._dateAdapter.addCalendarMonths(this._activeDate, 1);
                      break;
                  case keycodes.ENTER:
                      if (!this.dateFilter || this.dateFilter(this._activeDate)) {
                          this._dateSelected(this._dateAdapter.getDate(this._activeDate));
                          this._userSelection.emit();
                          // Prevent unexpected default actions such as form submission.
                          event.preventDefault();
                      }
                      return;
                  default:
                      // Don't prevent default or focus active cell on keys that we don't explicitly handle.
                      return;
              }
              if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {
                  this.activeDateChange.emit(this.activeDate);
              }
              this._focusActiveCell();
              // Prevent unexpected default actions such as form submission.
              event.preventDefault();
          };
      /** Initializes this month view. */
      /**
       * Initializes this month view.
       * @return {?}
       */
      SatMonthView.prototype._init = /**
       * Initializes this month view.
       * @return {?}
       */
          function () {
              this.updateRangeSpecificValues();
              this._selectedDate = this._getDateInCurrentMonth(this.selected);
              this._todayDate = this._getDateInCurrentMonth(this._dateAdapter.today());
              this._monthLabel =
                  this._dateAdapter.getMonthNames('short')[this._dateAdapter.getMonth(this.activeDate)]
                      .toLocaleUpperCase();
              /** @type {?} */
              var firstOfMonth = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), 1);
              this._firstWeekOffset =
                  (DAYS_PER_WEEK + this._dateAdapter.getDayOfWeek(firstOfMonth) -
                      this._dateAdapter.getFirstDayOfWeek()) % DAYS_PER_WEEK;
              this._createWeekCells();
              this._changeDetectorRef.markForCheck();
          };
      /** Focuses the active cell after the microtask queue is empty. */
      /**
       * Focuses the active cell after the microtask queue is empty.
       * @return {?}
       */
      SatMonthView.prototype._focusActiveCell = /**
       * Focuses the active cell after the microtask queue is empty.
       * @return {?}
       */
          function () {
              this._matCalendarBody._focusActiveCell();
          };
      /**
       * Creates SatCalendarCells for the dates in this month.
       * @return {?}
       */
      SatMonthView.prototype._createWeekCells = /**
       * Creates SatCalendarCells for the dates in this month.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var daysInMonth = this._dateAdapter.getNumDaysInMonth(this.activeDate);
              /** @type {?} */
              var dateNames = this._dateAdapter.getDateNames();
              this._weeks = [[]];
              for (var i = 0, cell = this._firstWeekOffset; i < daysInMonth; i++, cell++) {
                  if (cell == DAYS_PER_WEEK) {
                      this._weeks.push([]);
                      cell = 0;
                  }
                  /** @type {?} */
                  var date = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), i + 1);
                  /** @type {?} */
                  var enabled = this._shouldEnableDate(date);
                  /** @type {?} */
                  var ariaLabel = this._dateAdapter.format(date, this._dateFormats.display.dateA11yLabel);
                  this._weeks[this._weeks.length - 1]
                      .push(new SatCalendarCell(i + 1, dateNames[i], ariaLabel, enabled));
              }
          };
      /**
       * Date filter for the month
       * @param {?} date
       * @return {?}
       */
      SatMonthView.prototype._shouldEnableDate = /**
       * Date filter for the month
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return !!date &&
                  (!this.dateFilter || this.dateFilter(date)) &&
                  (!this.minDate || this._dateAdapter.compareDate(date, this.minDate) >= 0) &&
                  (!this.maxDate || this._dateAdapter.compareDate(date, this.maxDate) <= 0);
          };
      /**
       * Gets the date in this month that the given Date falls on.
       * Returns null if the given Date is in another month.
       * @param {?} date
       * @return {?}
       */
      SatMonthView.prototype._getDateInCurrentMonth = /**
       * Gets the date in this month that the given Date falls on.
       * Returns null if the given Date is in another month.
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return date && this._hasSameMonthAndYear(date, this.activeDate) ?
                  this._dateAdapter.getDate(date) : null;
          };
      /**
       * Checks whether the 2 dates are non-null and fall within the same month of the same year.
       * @param {?} d1
       * @param {?} d2
       * @return {?}
       */
      SatMonthView.prototype._hasSameMonthAndYear = /**
       * Checks whether the 2 dates are non-null and fall within the same month of the same year.
       * @param {?} d1
       * @param {?} d2
       * @return {?}
       */
          function (d1, d2) {
              return !!(d1 && d2 && this._dateAdapter.getMonth(d1) == this._dateAdapter.getMonth(d2) &&
                  this._dateAdapter.getYear(d1) == this._dateAdapter.getYear(d2));
          };
      /**
       * @param {?} obj The object to check.
       * @return {?} The given object if it is both a date instance and valid, otherwise null.
       */
      SatMonthView.prototype._getValidDateOrNull = /**
       * @param {?} obj The object to check.
       * @return {?} The given object if it is both a date instance and valid, otherwise null.
       */
          function (obj) {
              return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
          };
      /**
       * Determines whether the user has the RTL layout direction.
       * @return {?}
       */
      SatMonthView.prototype._isRtl = /**
       * Determines whether the user has the RTL layout direction.
       * @return {?}
       */
          function () {
              return this._dir && this._dir.value === 'rtl';
          };
      /**
       * Updates range full parameter on each begin or end of interval update.
       * Necessary to display calendar-body correctly
       * @return {?}
       */
      SatMonthView.prototype.updateRangeSpecificValues = /**
       * Updates range full parameter on each begin or end of interval update.
       * Necessary to display calendar-body correctly
       * @return {?}
       */
          function () {
              if (this.rangeMode) {
                  this._beginDateNumber = this._getDateInCurrentMonth(this._beginDate);
                  this._endDateNumber = this._getDateInCurrentMonth(this._endDate);
                  this._rangeFull = this.beginDate && this.endDate && !this._beginDateNumber &&
                      !this._endDateNumber &&
                      this._dateAdapter.compareDate(this.beginDate, this.activeDate) <= 0 &&
                      this._dateAdapter.compareDate(this.activeDate, this.endDate) <= 0;
              }
              else {
                  this._beginDateNumber = this._endDateNumber = null;
                  this._rangeFull = false;
              }
          };
      SatMonthView.decorators = [
          { type: i0.Component, args: [{
                      moduleId: module.id,
                      selector: 'sat-month-view',
                      template: "<table class=\"mat-calendar-table\">\n  <thead class=\"mat-calendar-table-header\">\n    <tr><th *ngFor=\"let day of _weekdays\" [attr.aria-label]=\"day.long\">{{day.narrow}}</th></tr>\n    <tr><th class=\"mat-calendar-table-header-divider\" colspan=\"7\" aria-hidden=\"true\"></th></tr>\n  </thead>\n  <tbody sat-calendar-body\n         [label]=\"_monthLabel\"\n         [rows]=\"_weeks\"\n         [todayValue]=\"_todayDate\"\n         [selectedValue]=\"_selectedDate\"\n         [begin]=\"_beginDateNumber\"\n         [end]=\"_endDateNumber\"\n         [rangeFull]=\"_rangeFull\"\n         [rangeMode]=\"rangeMode\"\n         [labelMinRequiredCells]=\"3\"\n         [activeCell]=\"_dateAdapter.getDate(activeDate) - 1\"\n         (selectedValueChange)=\"_dateSelected($event)\"\n         (keydown)=\"_handleCalendarBodyKeydown($event)\">\n  </tbody>\n</table>\n",
                      exportAs: 'matMonthView',
                      encapsulation: i0.ViewEncapsulation.None,
                      changeDetection: i0.ChangeDetectionStrategy.OnPush
                  }] }
      ];
      /** @nocollapse */
      SatMonthView.ctorParameters = function () {
          return [
              { type: i0.ChangeDetectorRef },
              { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [MAT_DATE_FORMATS,] }] },
              { type: DateAdapter, decorators: [{ type: i0.Optional }] },
              { type: bidi.Directionality, decorators: [{ type: i0.Optional }] }
          ];
      };
      SatMonthView.propDecorators = {
          beginDate: [{ type: i0.Input }],
          endDate: [{ type: i0.Input }],
          rangeMode: [{ type: i0.Input }],
          activeDate: [{ type: i0.Input }],
          selected: [{ type: i0.Input }],
          minDate: [{ type: i0.Input }],
          maxDate: [{ type: i0.Input }],
          dateFilter: [{ type: i0.Input }],
          selectedChange: [{ type: i0.Output }],
          _userSelection: [{ type: i0.Output }],
          activeDateChange: [{ type: i0.Output }],
          _matCalendarBody: [{ type: i0.ViewChild, args: [SatCalendarBody,] }]
      };
      return SatMonthView;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** @type {?} */
  var yearsPerPage = 24;
  /** @type {?} */
  var yearsPerRow = 4;
  /**
   * An internal component used to display a year selector in the datepicker.
   * \@docs-private
   * @template D
   */
  var SatMultiYearView = (function () {
      function SatMultiYearView(_changeDetectorRef, _dateAdapter, _dir) {
          this._changeDetectorRef = _changeDetectorRef;
          this._dateAdapter = _dateAdapter;
          this._dir = _dir;
          /**
           * Emits when a new year is selected.
           */
          this.selectedChange = new i0.EventEmitter();
          /**
           * Emits the selected year. This doesn't imply a change on the selected date
           */
          this.yearSelected = new i0.EventEmitter();
          /**
           * Emits when any date is activated.
           */
          this.activeDateChange = new i0.EventEmitter();
          if (!this._dateAdapter) {
              throw createMissingDateImplError('DateAdapter');
          }
          this._activeDate = this._dateAdapter.today();
      }
      Object.defineProperty(SatMultiYearView.prototype, "activeDate", {
          /** The date to display in this multi-year view (everything other than the year is ignored). */
          get: /**
           * The date to display in this multi-year view (everything other than the year is ignored).
           * @return {?}
           */ function () { return this._activeDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              /** @type {?} */
              var oldActiveDate = this._activeDate;
              /** @type {?} */
              var validDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();
              this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);
              if (Math.floor(this._dateAdapter.getYear(oldActiveDate) / yearsPerPage) !=
                  Math.floor(this._dateAdapter.getYear(this._activeDate) / yearsPerPage)) {
                  this._init();
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatMultiYearView.prototype, "selected", {
          /** The currently selected date. */
          get: /**
           * The currently selected date.
           * @return {?}
           */ function () { return this._selected; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
              this._selectedYear = this._selected && this._dateAdapter.getYear(this._selected);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatMultiYearView.prototype, "minDate", {
          /** The minimum selectable date. */
          get: /**
           * The minimum selectable date.
           * @return {?}
           */ function () { return this._minDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatMultiYearView.prototype, "maxDate", {
          /** The maximum selectable date. */
          get: /**
           * The maximum selectable date.
           * @return {?}
           */ function () { return this._maxDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      SatMultiYearView.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              this._init();
          };
      /** Initializes this multi-year view. */
      /**
       * Initializes this multi-year view.
       * @return {?}
       */
      SatMultiYearView.prototype._init = /**
       * Initializes this multi-year view.
       * @return {?}
       */
          function () {
              var _this = this;
              this._todayYear = this._dateAdapter.getYear(this._dateAdapter.today());
              /** @type {?} */
              var activeYear = this._dateAdapter.getYear(this._activeDate);
              /** @type {?} */
              var activeOffset = activeYear % yearsPerPage;
              this._years = [];
              for (var i = 0, row = []; i < yearsPerPage; i++) {
                  row.push(activeYear - activeOffset + i);
                  if (row.length == yearsPerRow) {
                      this._years.push(row.map(function (year) { return _this._createCellForYear(year); }));
                      row = [];
                  }
              }
              this._changeDetectorRef.markForCheck();
          };
      /** Handles when a new year is selected. */
      /**
       * Handles when a new year is selected.
       * @param {?} year
       * @return {?}
       */
      SatMultiYearView.prototype._yearSelected = /**
       * Handles when a new year is selected.
       * @param {?} year
       * @return {?}
       */
          function (year) {
              this.yearSelected.emit(this._dateAdapter.createDate(year, 0, 1));
              /** @type {?} */
              var month = this._dateAdapter.getMonth(this.activeDate);
              /** @type {?} */
              var daysInMonth = this._dateAdapter.getNumDaysInMonth(this._dateAdapter.createDate(year, month, 1));
              this.selectedChange.emit(this._dateAdapter.createDate(year, month, Math.min(this._dateAdapter.getDate(this.activeDate), daysInMonth)));
          };
      /** Handles keydown events on the calendar body when calendar is in multi-year view. */
      /**
       * Handles keydown events on the calendar body when calendar is in multi-year view.
       * @param {?} event
       * @return {?}
       */
      SatMultiYearView.prototype._handleCalendarBodyKeydown = /**
       * Handles keydown events on the calendar body when calendar is in multi-year view.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              /** @type {?} */
              var oldActiveDate = this._activeDate;
              /** @type {?} */
              var isRtl = this._isRtl();
              switch (event.keyCode) {
                  case keycodes.LEFT_ARROW:
                      this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, isRtl ? 1 : -1);
                      break;
                  case keycodes.RIGHT_ARROW:
                      this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, isRtl ? -1 : 1);
                      break;
                  case keycodes.UP_ARROW:
                      this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, -yearsPerRow);
                      break;
                  case keycodes.DOWN_ARROW:
                      this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, yearsPerRow);
                      break;
                  case keycodes.HOME:
                      this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, -this._dateAdapter.getYear(this._activeDate) % yearsPerPage);
                      break;
                  case keycodes.END:
                      this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, yearsPerPage - this._dateAdapter.getYear(this._activeDate) % yearsPerPage - 1);
                      break;
                  case keycodes.PAGE_UP:
                      this.activeDate =
                          this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? -yearsPerPage * 10 : -yearsPerPage);
                      break;
                  case keycodes.PAGE_DOWN:
                      this.activeDate =
                          this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? yearsPerPage * 10 : yearsPerPage);
                      break;
                  case keycodes.ENTER:
                      this._yearSelected(this._dateAdapter.getYear(this._activeDate));
                      break;
                  default:
                      // Don't prevent default or focus active cell on keys that we don't explicitly handle.
                      return;
              }
              if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {
                  this.activeDateChange.emit(this.activeDate);
              }
              this._focusActiveCell();
              // Prevent unexpected default actions such as form submission.
              event.preventDefault();
          };
      /**
       * @return {?}
       */
      SatMultiYearView.prototype._getActiveCell = /**
       * @return {?}
       */
          function () {
              return this._dateAdapter.getYear(this.activeDate) % yearsPerPage;
          };
      /** Focuses the active cell after the microtask queue is empty. */
      /**
       * Focuses the active cell after the microtask queue is empty.
       * @return {?}
       */
      SatMultiYearView.prototype._focusActiveCell = /**
       * Focuses the active cell after the microtask queue is empty.
       * @return {?}
       */
          function () {
              this._matCalendarBody._focusActiveCell();
          };
      /**
       * Creates an SatCalendarCell for the given year.
       * @param {?} year
       * @return {?}
       */
      SatMultiYearView.prototype._createCellForYear = /**
       * Creates an SatCalendarCell for the given year.
       * @param {?} year
       * @return {?}
       */
          function (year) {
              /** @type {?} */
              var yearName = this._dateAdapter.getYearName(this._dateAdapter.createDate(year, 0, 1));
              return new SatCalendarCell(year, yearName, yearName, this._shouldEnableYear(year));
          };
      /**
       * Whether the given year is enabled.
       * @param {?} year
       * @return {?}
       */
      SatMultiYearView.prototype._shouldEnableYear = /**
       * Whether the given year is enabled.
       * @param {?} year
       * @return {?}
       */
          function (year) {
              // disable if the year is greater than maxDate lower than minDate
              if (year === undefined || year === null ||
                  (this.maxDate && year > this._dateAdapter.getYear(this.maxDate)) ||
                  (this.minDate && year < this._dateAdapter.getYear(this.minDate))) {
                  return false;
              }
              // enable if it reaches here and there's no filter defined
              if (!this.dateFilter) {
                  return true;
              }
              /** @type {?} */
              var firstOfYear = this._dateAdapter.createDate(year, 0, 1);
              // If any date in the year is enabled count the year as enabled.
              for (var date = firstOfYear; this._dateAdapter.getYear(date) == year; date = this._dateAdapter.addCalendarDays(date, 1)) {
                  if (this.dateFilter(date)) {
                      return true;
                  }
              }
              return false;
          };
      /**
       * @param {?} obj The object to check.
       * @return {?} The given object if it is both a date instance and valid, otherwise null.
       */
      SatMultiYearView.prototype._getValidDateOrNull = /**
       * @param {?} obj The object to check.
       * @return {?} The given object if it is both a date instance and valid, otherwise null.
       */
          function (obj) {
              return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
          };
      /**
       * Determines whether the user has the RTL layout direction.
       * @return {?}
       */
      SatMultiYearView.prototype._isRtl = /**
       * Determines whether the user has the RTL layout direction.
       * @return {?}
       */
          function () {
              return this._dir && this._dir.value === 'rtl';
          };
      SatMultiYearView.decorators = [
          { type: i0.Component, args: [{
                      moduleId: module.id,
                      selector: 'sat-multi-year-view',
                      template: "<table class=\"mat-calendar-table\">\n  <thead class=\"mat-calendar-table-header\">\n    <tr><th class=\"mat-calendar-table-header-divider\" colspan=\"4\"></th></tr>\n  </thead>\n  <tbody sat-calendar-body\n         allowDisabledSelection=\"true\"\n         [rows]=\"_years\"\n         [todayValue]=\"_todayYear\"\n         [selectedValue]=\"_selectedYear\"\n         [numCols]=\"4\"\n         [cellAspectRatio]=\"4 / 7\"\n         [activeCell]=\"_getActiveCell()\"\n         (selectedValueChange)=\"_yearSelected($event)\"\n         (keydown)=\"_handleCalendarBodyKeydown($event)\">\n  </tbody>\n</table>\n",
                      exportAs: 'matMultiYearView',
                      encapsulation: i0.ViewEncapsulation.None,
                      changeDetection: i0.ChangeDetectionStrategy.OnPush
                  }] }
      ];
      /** @nocollapse */
      SatMultiYearView.ctorParameters = function () {
          return [
              { type: i0.ChangeDetectorRef },
              { type: DateAdapter, decorators: [{ type: i0.Optional }] },
              { type: bidi.Directionality, decorators: [{ type: i0.Optional }] }
          ];
      };
      SatMultiYearView.propDecorators = {
          activeDate: [{ type: i0.Input }],
          selected: [{ type: i0.Input }],
          minDate: [{ type: i0.Input }],
          maxDate: [{ type: i0.Input }],
          dateFilter: [{ type: i0.Input }],
          selectedChange: [{ type: i0.Output }],
          yearSelected: [{ type: i0.Output }],
          activeDateChange: [{ type: i0.Output }],
          _matCalendarBody: [{ type: i0.ViewChild, args: [SatCalendarBody,] }]
      };
      return SatMultiYearView;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * An internal component used to display a single year in the datepicker.
   * \@docs-private
   * @template D
   */
  var SatYearView = (function () {
      function SatYearView(_changeDetectorRef, _dateFormats, _dateAdapter, _dir) {
          this._changeDetectorRef = _changeDetectorRef;
          this._dateFormats = _dateFormats;
          this._dateAdapter = _dateAdapter;
          this._dir = _dir;
          /**
           * Emits when a new month is selected.
           */
          this.selectedChange = new i0.EventEmitter();
          /**
           * Emits the selected month. This doesn't imply a change on the selected date
           */
          this.monthSelected = new i0.EventEmitter();
          /**
           * Emits when any date is activated.
           */
          this.activeDateChange = new i0.EventEmitter();
          if (!this._dateAdapter) {
              throw createMissingDateImplError('DateAdapter');
          }
          if (!this._dateFormats) {
              throw createMissingDateImplError('MAT_DATE_FORMATS');
          }
          this._activeDate = this._dateAdapter.today();
      }
      Object.defineProperty(SatYearView.prototype, "activeDate", {
          /** The date to display in this year view (everything other than the year is ignored). */
          get: /**
           * The date to display in this year view (everything other than the year is ignored).
           * @return {?}
           */ function () { return this._activeDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              /** @type {?} */
              var oldActiveDate = this._activeDate;
              /** @type {?} */
              var validDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();
              this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);
              if (this._dateAdapter.getYear(oldActiveDate) !== this._dateAdapter.getYear(this._activeDate)) {
                  this._init();
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatYearView.prototype, "selected", {
          /** The currently selected date. */
          get: /**
           * The currently selected date.
           * @return {?}
           */ function () { return this._selected; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
              this._selectedMonth = this._getMonthInCurrentYear(this._selected);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatYearView.prototype, "minDate", {
          /** The minimum selectable date. */
          get: /**
           * The minimum selectable date.
           * @return {?}
           */ function () { return this._minDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatYearView.prototype, "maxDate", {
          /** The maximum selectable date. */
          get: /**
           * The maximum selectable date.
           * @return {?}
           */ function () { return this._maxDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      SatYearView.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              this._init();
          };
      /** Handles when a new month is selected. */
      /**
       * Handles when a new month is selected.
       * @param {?} month
       * @return {?}
       */
      SatYearView.prototype._monthSelected = /**
       * Handles when a new month is selected.
       * @param {?} month
       * @return {?}
       */
          function (month) {
              /** @type {?} */
              var normalizedDate = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, 1);
              this.monthSelected.emit(normalizedDate);
              /** @type {?} */
              var daysInMonth = this._dateAdapter.getNumDaysInMonth(normalizedDate);
              this.selectedChange.emit(this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, Math.min(this._dateAdapter.getDate(this.activeDate), daysInMonth)));
          };
      /** Handles keydown events on the calendar body when calendar is in year view. */
      /**
       * Handles keydown events on the calendar body when calendar is in year view.
       * @param {?} event
       * @return {?}
       */
      SatYearView.prototype._handleCalendarBodyKeydown = /**
       * Handles keydown events on the calendar body when calendar is in year view.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              /** @type {?} */
              var oldActiveDate = this._activeDate;
              /** @type {?} */
              var isRtl = this._isRtl();
              switch (event.keyCode) {
                  case keycodes.LEFT_ARROW:
                      this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, isRtl ? 1 : -1);
                      break;
                  case keycodes.RIGHT_ARROW:
                      this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, isRtl ? -1 : 1);
                      break;
                  case keycodes.UP_ARROW:
                      this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, -4);
                      break;
                  case keycodes.DOWN_ARROW:
                      this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, 4);
                      break;
                  case keycodes.HOME:
                      this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, -this._dateAdapter.getMonth(this._activeDate));
                      break;
                  case keycodes.END:
                      this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, 11 - this._dateAdapter.getMonth(this._activeDate));
                      break;
                  case keycodes.PAGE_UP:
                      this.activeDate =
                          this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? -10 : -1);
                      break;
                  case keycodes.PAGE_DOWN:
                      this.activeDate =
                          this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? 10 : 1);
                      break;
                  case keycodes.ENTER:
                      this._monthSelected(this._dateAdapter.getMonth(this._activeDate));
                      break;
                  default:
                      // Don't prevent default or focus active cell on keys that we don't explicitly handle.
                      return;
              }
              if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {
                  this.activeDateChange.emit(this.activeDate);
              }
              this._focusActiveCell();
              // Prevent unexpected default actions such as form submission.
              event.preventDefault();
          };
      /** Initializes this year view. */
      /**
       * Initializes this year view.
       * @return {?}
       */
      SatYearView.prototype._init = /**
       * Initializes this year view.
       * @return {?}
       */
          function () {
              var _this = this;
              this._selectedMonth = this._getMonthInCurrentYear(this.selected);
              this._todayMonth = this._getMonthInCurrentYear(this._dateAdapter.today());
              this._yearLabel = this._dateAdapter.getYearName(this.activeDate);
              /** @type {?} */
              var monthNames = this._dateAdapter.getMonthNames('short');
              // First row of months only contains 5 elements so we can fit the year label on the same row.
              this._months = [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]].map(function (row) { return row.map(function (month) { return _this._createCellForMonth(month, monthNames[month]); }); });
              this._changeDetectorRef.markForCheck();
          };
      /** Focuses the active cell after the microtask queue is empty. */
      /**
       * Focuses the active cell after the microtask queue is empty.
       * @return {?}
       */
      SatYearView.prototype._focusActiveCell = /**
       * Focuses the active cell after the microtask queue is empty.
       * @return {?}
       */
          function () {
              this._matCalendarBody._focusActiveCell();
          };
      /**
       * Gets the month in this year that the given Date falls on.
       * Returns null if the given Date is in another year.
       * @param {?} date
       * @return {?}
       */
      SatYearView.prototype._getMonthInCurrentYear = /**
       * Gets the month in this year that the given Date falls on.
       * Returns null if the given Date is in another year.
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return date && this._dateAdapter.getYear(date) == this._dateAdapter.getYear(this.activeDate) ?
                  this._dateAdapter.getMonth(date) : null;
          };
      /**
       * Creates an SatCalendarCell for the given month.
       * @param {?} month
       * @param {?} monthName
       * @return {?}
       */
      SatYearView.prototype._createCellForMonth = /**
       * Creates an SatCalendarCell for the given month.
       * @param {?} month
       * @param {?} monthName
       * @return {?}
       */
          function (month, monthName) {
              /** @type {?} */
              var ariaLabel = this._dateAdapter.format(this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, 1), this._dateFormats.display.monthYearA11yLabel);
              return new SatCalendarCell(month, monthName.toLocaleUpperCase(), ariaLabel, this._shouldEnableMonth(month));
          };
      /**
       * Whether the given month is enabled.
       * @param {?} month
       * @return {?}
       */
      SatYearView.prototype._shouldEnableMonth = /**
       * Whether the given month is enabled.
       * @param {?} month
       * @return {?}
       */
          function (month) {
              /** @type {?} */
              var activeYear = this._dateAdapter.getYear(this.activeDate);
              if (month === undefined || month === null ||
                  this._isYearAndMonthAfterMaxDate(activeYear, month) ||
                  this._isYearAndMonthBeforeMinDate(activeYear, month)) {
                  return false;
              }
              if (!this.dateFilter) {
                  return true;
              }
              /** @type {?} */
              var firstOfMonth = this._dateAdapter.createDate(activeYear, month, 1);
              // If any date in the month is enabled count the month as enabled.
              for (var date = firstOfMonth; this._dateAdapter.getMonth(date) == month; date = this._dateAdapter.addCalendarDays(date, 1)) {
                  if (this.dateFilter(date)) {
                      return true;
                  }
              }
              return false;
          };
      /**
       * Tests whether the combination month/year is after this.maxDate, considering
       * just the month and year of this.maxDate
       * @param {?} year
       * @param {?} month
       * @return {?}
       */
      SatYearView.prototype._isYearAndMonthAfterMaxDate = /**
       * Tests whether the combination month/year is after this.maxDate, considering
       * just the month and year of this.maxDate
       * @param {?} year
       * @param {?} month
       * @return {?}
       */
          function (year, month) {
              if (this.maxDate) {
                  /** @type {?} */
                  var maxYear = this._dateAdapter.getYear(this.maxDate);
                  /** @type {?} */
                  var maxMonth = this._dateAdapter.getMonth(this.maxDate);
                  return year > maxYear || (year === maxYear && month > maxMonth);
              }
              return false;
          };
      /**
       * Tests whether the combination month/year is before this.minDate, considering
       * just the month and year of this.minDate
       * @param {?} year
       * @param {?} month
       * @return {?}
       */
      SatYearView.prototype._isYearAndMonthBeforeMinDate = /**
       * Tests whether the combination month/year is before this.minDate, considering
       * just the month and year of this.minDate
       * @param {?} year
       * @param {?} month
       * @return {?}
       */
          function (year, month) {
              if (this.minDate) {
                  /** @type {?} */
                  var minYear = this._dateAdapter.getYear(this.minDate);
                  /** @type {?} */
                  var minMonth = this._dateAdapter.getMonth(this.minDate);
                  return year < minYear || (year === minYear && month < minMonth);
              }
              return false;
          };
      /**
       * @param {?} obj The object to check.
       * @return {?} The given object if it is both a date instance and valid, otherwise null.
       */
      SatYearView.prototype._getValidDateOrNull = /**
       * @param {?} obj The object to check.
       * @return {?} The given object if it is both a date instance and valid, otherwise null.
       */
          function (obj) {
              return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
          };
      /**
       * Determines whether the user has the RTL layout direction.
       * @return {?}
       */
      SatYearView.prototype._isRtl = /**
       * Determines whether the user has the RTL layout direction.
       * @return {?}
       */
          function () {
              return this._dir && this._dir.value === 'rtl';
          };
      SatYearView.decorators = [
          { type: i0.Component, args: [{
                      moduleId: module.id,
                      selector: 'sat-year-view',
                      template: "<table class=\"mat-calendar-table\">\n  <thead class=\"mat-calendar-table-header\">\n  <tr><th class=\"mat-calendar-table-header-divider\" colspan=\"4\"></th></tr>\n  </thead>\n  <tbody sat-calendar-body\n         allowDisabledSelection=\"true\"\n         [label]=\"_yearLabel\"\n         [rows]=\"_months\"\n         [todayValue]=\"_todayMonth\"\n         [selectedValue]=\"_selectedMonth\"\n         [labelMinRequiredCells]=\"2\"\n         [numCols]=\"4\"\n         [cellAspectRatio]=\"4 / 7\"\n         [activeCell]=\"_dateAdapter.getMonth(activeDate)\"\n         (selectedValueChange)=\"_monthSelected($event)\"\n         (keydown)=\"_handleCalendarBodyKeydown($event)\">\n  </tbody>\n</table>\n",
                      exportAs: 'matYearView',
                      encapsulation: i0.ViewEncapsulation.None,
                      changeDetection: i0.ChangeDetectionStrategy.OnPush
                  }] }
      ];
      /** @nocollapse */
      SatYearView.ctorParameters = function () {
          return [
              { type: i0.ChangeDetectorRef },
              { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [MAT_DATE_FORMATS,] }] },
              { type: DateAdapter, decorators: [{ type: i0.Optional }] },
              { type: bidi.Directionality, decorators: [{ type: i0.Optional }] }
          ];
      };
      SatYearView.propDecorators = {
          activeDate: [{ type: i0.Input }],
          selected: [{ type: i0.Input }],
          minDate: [{ type: i0.Input }],
          maxDate: [{ type: i0.Input }],
          dateFilter: [{ type: i0.Input }],
          selectedChange: [{ type: i0.Output }],
          monthSelected: [{ type: i0.Output }],
          activeDateChange: [{ type: i0.Output }],
          _matCalendarBody: [{ type: i0.ViewChild, args: [SatCalendarBody,] }]
      };
      return SatYearView;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Default header for SatCalendar
   * @template D
   */
  var SatCalendarHeader = (function () {
      function SatCalendarHeader(_intl, calendar, _dateAdapter, _dateFormats, changeDetectorRef) {
          this._intl = _intl;
          this.calendar = calendar;
          this._dateAdapter = _dateAdapter;
          this._dateFormats = _dateFormats;
          this.calendar.stateChanges.subscribe(function () { return changeDetectorRef.markForCheck(); });
      }
      Object.defineProperty(SatCalendarHeader.prototype, "periodButtonText", {
          /** The label for the current calendar view. */
          get: /**
           * The label for the current calendar view.
           * @return {?}
           */ function () {
              if (this.calendar.currentView == 'month') {
                  return this._dateAdapter
                      .format(this.calendar.activeDate, this._dateFormats.display.monthYearLabel)
                      .toLocaleUpperCase();
              }
              if (this.calendar.currentView == 'year') {
                  return this._dateAdapter.getYearName(this.calendar.activeDate);
              }
              /** @type {?} */
              var activeYear = this._dateAdapter.getYear(this.calendar.activeDate);
              /** @type {?} */
              var firstYearInView = this._dateAdapter.getYearName(this._dateAdapter.createDate(activeYear - activeYear % 24, 0, 1));
              /** @type {?} */
              var lastYearInView = this._dateAdapter.getYearName(this._dateAdapter.createDate(activeYear + yearsPerPage - 1 - activeYear % 24, 0, 1));
              return firstYearInView + " \u2013 " + lastYearInView;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatCalendarHeader.prototype, "periodButtonLabel", {
          get: /**
           * @return {?}
           */ function () {
              return this.calendar.currentView == 'month' ?
                  this._intl.switchToMultiYearViewLabel : this._intl.switchToMonthViewLabel;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatCalendarHeader.prototype, "prevButtonLabel", {
          /** The label for the the previous button. */
          get: /**
           * The label for the the previous button.
           * @return {?}
           */ function () {
              return {
                  'month': this._intl.prevMonthLabel,
                  'year': this._intl.prevYearLabel,
                  'multi-year': this._intl.prevMultiYearLabel
              }[this.calendar.currentView];
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatCalendarHeader.prototype, "nextButtonLabel", {
          /** The label for the the next button. */
          get: /**
           * The label for the the next button.
           * @return {?}
           */ function () {
              return {
                  'month': this._intl.nextMonthLabel,
                  'year': this._intl.nextYearLabel,
                  'multi-year': this._intl.nextMultiYearLabel
              }[this.calendar.currentView];
          },
          enumerable: true,
          configurable: true
      });
      /** Handles user clicks on the period label.
       * Option`calendar.orderPeriodLabel` sort the label period views.
       * - Default [multi-year]: multi-year then back to month
       * - Month [month]: month > year > multi-year
       */
      /**
       * Handles user clicks on the period label.
       * Option`calendar.orderPeriodLabel` sort the label period views.
       * - Default [multi-year]: multi-year then back to month
       * - Month [month]: month > year > multi-year
       * @return {?}
       */
      SatCalendarHeader.prototype.currentPeriodClicked = /**
       * Handles user clicks on the period label.
       * Option`calendar.orderPeriodLabel` sort the label period views.
       * - Default [multi-year]: multi-year then back to month
       * - Month [month]: month > year > multi-year
       * @return {?}
       */
          function () {
              /** @type {?} */
              var mouthFirstOrder = ['month', 'year', 'multi-year'];
              /** @type {?} */
              var defaultOrder = ['month', 'multi-year', 'month'];
              /** @type {?} */
              var orderPeriod = this.calendar.orderPeriodLabel === 'month' ? mouthFirstOrder : defaultOrder;
              switch (this.calendar.currentView) {
                  case 'month':
                      this.calendar.currentView = orderPeriod[1];
                      break;
                  case 'year':
                      this.calendar.currentView = orderPeriod[2];
                      break;
                  default:
                      this.calendar.currentView = orderPeriod[0];
                      break;
              }
          };
      /** Handles user clicks on the previous button. */
      /**
       * Handles user clicks on the previous button.
       * @return {?}
       */
      SatCalendarHeader.prototype.previousClicked = /**
       * Handles user clicks on the previous button.
       * @return {?}
       */
          function () {
              this.calendar.activeDate = this.calendar.currentView == 'month' ?
                  this._dateAdapter.addCalendarMonths(this.calendar.activeDate, -1) :
                  this._dateAdapter.addCalendarYears(this.calendar.activeDate, this.calendar.currentView == 'year' ? -1 : -yearsPerPage);
          };
      /** Handles user clicks on the next button. */
      /**
       * Handles user clicks on the next button.
       * @return {?}
       */
      SatCalendarHeader.prototype.nextClicked = /**
       * Handles user clicks on the next button.
       * @return {?}
       */
          function () {
              this.calendar.activeDate = this.calendar.currentView == 'month' ?
                  this._dateAdapter.addCalendarMonths(this.calendar.activeDate, 1) :
                  this._dateAdapter.addCalendarYears(this.calendar.activeDate, this.calendar.currentView == 'year' ? 1 : yearsPerPage);
          };
      /** Whether the previous period button is enabled. */
      /**
       * Whether the previous period button is enabled.
       * @return {?}
       */
      SatCalendarHeader.prototype.previousEnabled = /**
       * Whether the previous period button is enabled.
       * @return {?}
       */
          function () {
              if (!this.calendar.minDate) {
                  return true;
              }
              return !this.calendar.minDate ||
                  !this._isSameView(this.calendar.activeDate, this.calendar.minDate);
          };
      /** Whether the next period button is enabled. */
      /**
       * Whether the next period button is enabled.
       * @return {?}
       */
      SatCalendarHeader.prototype.nextEnabled = /**
       * Whether the next period button is enabled.
       * @return {?}
       */
          function () {
              return !this.calendar.maxDate ||
                  !this._isSameView(this.calendar.activeDate, this.calendar.maxDate);
          };
      /**
       * Whether the two dates represent the same view in the current view mode (month or year).
       * @param {?} date1
       * @param {?} date2
       * @return {?}
       */
      SatCalendarHeader.prototype._isSameView = /**
       * Whether the two dates represent the same view in the current view mode (month or year).
       * @param {?} date1
       * @param {?} date2
       * @return {?}
       */
          function (date1, date2) {
              if (this.calendar.currentView == 'month') {
                  return this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2) &&
                      this._dateAdapter.getMonth(date1) == this._dateAdapter.getMonth(date2);
              }
              if (this.calendar.currentView == 'year') {
                  return this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2);
              }
              // Otherwise we are in 'multi-year' view.
              return Math.floor(this._dateAdapter.getYear(date1) / yearsPerPage) ==
                  Math.floor(this._dateAdapter.getYear(date2) / yearsPerPage);
          };
      SatCalendarHeader.decorators = [
          { type: i0.Component, args: [{
                      moduleId: module.id,
                      selector: 'sat-calendar-header',
                      template: "<div class=\"mat-calendar-header\">\n  <div class=\"mat-calendar-controls\">\n    <button mat-button type=\"button\" class=\"mat-calendar-period-button\"\n            (click)=\"currentPeriodClicked()\" [attr.aria-label]=\"periodButtonLabel\"\n            cdkAriaLive=\"polite\">\n      {{periodButtonText}}\n      <div class=\"mat-calendar-arrow\"\n           [class.mat-calendar-invert]=\"calendar.currentView != 'month'\"></div>\n    </button>\n\n    <div class=\"mat-calendar-spacer\"></div>\n\n    <button mat-icon-button type=\"button\" class=\"mat-calendar-previous-button\"\n            [disabled]=\"!previousEnabled()\" (click)=\"previousClicked()\"\n            [attr.aria-label]=\"prevButtonLabel\">\n    </button>\n\n    <button mat-icon-button type=\"button\" class=\"mat-calendar-next-button\"\n            [disabled]=\"!nextEnabled()\" (click)=\"nextClicked()\"\n            [attr.aria-label]=\"nextButtonLabel\">\n    </button>\n  </div>\n</div>\n",
                      exportAs: 'matCalendarHeader',
                      encapsulation: i0.ViewEncapsulation.None,
                      changeDetection: i0.ChangeDetectionStrategy.OnPush
                  }] }
      ];
      /** @nocollapse */
      SatCalendarHeader.ctorParameters = function () {
          return [
              { type: SatDatepickerIntl },
              { type: SatCalendar, decorators: [{ type: i0.Inject, args: [i0.forwardRef(function () { return SatCalendar; }),] }] },
              { type: DateAdapter, decorators: [{ type: i0.Optional }] },
              { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [MAT_DATE_FORMATS,] }] },
              { type: i0.ChangeDetectorRef }
          ];
      };
      return SatCalendarHeader;
  }());
  /**
   * A calendar that is used as part of the datepicker.
   * \@docs-private
   * @template D
   */
  var SatCalendar = (function () {
      function SatCalendar(_intl, _dateAdapter, _dateFormats, _changeDetectorRef) {
          var _this = this;
          this._dateAdapter = _dateAdapter;
          this._dateFormats = _dateFormats;
          this._changeDetectorRef = _changeDetectorRef;
          /**
           * Whenever datepicker is for selecting range of dates.
           */
          this.rangeMode = false;
          /**
           * Emits when new pair of dates selected.
           */
          this.dateRangesChange = new i0.EventEmitter();
          /**
           * Whenever user already selected start of dates interval.
           */
          this._beginDateSelected = false;
          /**
           * Used for scheduling that focus should be moved to the active cell on the next tick.
           * We need to schedule it, rather than do it immediately, because we have to wait
           * for Angular to re-evaluate the view children.
           */
          this._moveFocusOnNextTick = false;
          /**
           * Whether the calendar should be started in month or year view.
           */
          this.startView = 'month';
          /**
           * Order the views when clicking on period label button
           */
          this.orderPeriodLabel = 'multi-year';
          /**
           * Emits when the currently selected date changes.
           */
          this.selectedChange = new i0.EventEmitter();
          /**
           * Emits the year chosen in multiyear view.
           * This doesn't imply a change on the selected date.
           */
          this.yearSelected = new i0.EventEmitter();
          /**
           * Emits the month chosen in year view.
           * This doesn't imply a change on the selected date.
           */
          this.monthSelected = new i0.EventEmitter();
          /**
           * Emits when any date is selected.
           */
          this._userSelection = new i0.EventEmitter();
          /**
           * Emits whenever there is a state change that the header may need to respond to.
           */
          this.stateChanges = new rxjs.Subject();
          if (!this._dateAdapter) {
              throw createMissingDateImplError('DateAdapter');
          }
          if (!this._dateFormats) {
              throw createMissingDateImplError('MAT_DATE_FORMATS');
          }
          this._intlChanges = _intl.changes.subscribe(function () {
              _changeDetectorRef.markForCheck();
              _this.stateChanges.next();
          });
      }
      Object.defineProperty(SatCalendar.prototype, "beginDate", {
          /** Beginning of date range. */
          get: /**
           * Beginning of date range.
           * @return {?}
           */ function () { return this._beginDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._beginDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatCalendar.prototype, "endDate", {
          /** Date range end. */
          get: /**
           * Date range end.
           * @return {?}
           */ function () { return this._endDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._endDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatCalendar.prototype, "startAt", {
          /** A date representing the period (month or year) to start the calendar in. */
          get: /**
           * A date representing the period (month or year) to start the calendar in.
           * @return {?}
           */ function () { return this._startAt; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._startAt = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatCalendar.prototype, "selected", {
          /** The currently selected date. */
          get: /**
           * The currently selected date.
           * @return {?}
           */ function () { return this._selected; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatCalendar.prototype, "minDate", {
          /** The minimum selectable date. */
          get: /**
           * The minimum selectable date.
           * @return {?}
           */ function () { return this._minDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatCalendar.prototype, "maxDate", {
          /** The maximum selectable date. */
          get: /**
           * The maximum selectable date.
           * @return {?}
           */ function () { return this._maxDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatCalendar.prototype, "activeDate", {
          /**
           * The current active date. This determines which time period is shown and which date is
           * highlighted when using keyboard navigation.
           */
          get: /**
           * The current active date. This determines which time period is shown and which date is
           * highlighted when using keyboard navigation.
           * @return {?}
           */ function () { return this._clampedActiveDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._clampedActiveDate = this._dateAdapter.clampDate(value, this.minDate, this.maxDate);
              this.stateChanges.next();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatCalendar.prototype, "currentView", {
          /** Whether the calendar is in month view. */
          get: /**
           * Whether the calendar is in month view.
           * @return {?}
           */ function () { return this._currentView; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._currentView = value;
              this._moveFocusOnNextTick = true;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      SatCalendar.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              this._calendarHeaderPortal = new portal.ComponentPortal(this.headerComponent || SatCalendarHeader);
              this.activeDate = this.startAt || this._dateAdapter.today();
              // Assign to the private property since we don't want to move focus on init.
              this._currentView = this.startView;
          };
      /**
       * @return {?}
       */
      SatCalendar.prototype.ngAfterViewChecked = /**
       * @return {?}
       */
          function () {
              if (this._moveFocusOnNextTick) {
                  this._moveFocusOnNextTick = false;
                  this.focusActiveCell();
              }
          };
      /**
       * @return {?}
       */
      SatCalendar.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._intlChanges.unsubscribe();
              this.stateChanges.complete();
          };
      /**
       * @param {?} changes
       * @return {?}
       */
      SatCalendar.prototype.ngOnChanges = /**
       * @param {?} changes
       * @return {?}
       */
          function (changes) {
              /** @type {?} */
              var change = changes["minDate"] || changes["maxDate"] || changes["dateFilter"];
              if (change && !change.firstChange) {
                  /** @type {?} */
                  var view = this._getCurrentViewComponent();
                  if (view) {
                      // We need to `detectChanges` manually here, because the `minDate`, `maxDate` etc. are
                      // passed down to the view via data bindings which won't be up-to-date when we call `_init`.
                      this._changeDetectorRef.detectChanges();
                      view._init();
                  }
              }
              this.stateChanges.next();
          };
      /**
       * @return {?}
       */
      SatCalendar.prototype.focusActiveCell = /**
       * @return {?}
       */
          function () {
              this._getCurrentViewComponent()._focusActiveCell();
          };
      /** Handles date selection in the month view. */
      /**
       * Handles date selection in the month view.
       * @param {?} date
       * @return {?}
       */
      SatCalendar.prototype._dateSelected = /**
       * Handles date selection in the month view.
       * @param {?} date
       * @return {?}
       */
          function (date) {
              if (this.rangeMode) {
                  if (!this._beginDateSelected) {
                      this._beginDateSelected = true;
                      this.beginDate = date;
                      this.endDate = date;
                  }
                  else {
                      this._beginDateSelected = false;
                      if (this._dateAdapter.compareDate(/** @type {?} */ (this.beginDate), date) <= 0) {
                          this.dateRangesChange.emit({ begin: /** @type {?} */ (this.beginDate), end: date });
                      }
                      else {
                          this.dateRangesChange.emit({ begin: date, end: /** @type {?} */ (this.beginDate) });
                      }
                  }
              }
              else if (!this._dateAdapter.sameDate(date, this.selected)) {
                  this.selectedChange.emit(date);
              }
          };
      /** Handles year selection in the multiyear view. */
      /**
       * Handles year selection in the multiyear view.
       * @param {?} normalizedYear
       * @return {?}
       */
      SatCalendar.prototype._yearSelectedInMultiYearView = /**
       * Handles year selection in the multiyear view.
       * @param {?} normalizedYear
       * @return {?}
       */
          function (normalizedYear) {
              this.yearSelected.emit(normalizedYear);
          };
      /** Handles month selection in the year view. */
      /**
       * Handles month selection in the year view.
       * @param {?} normalizedMonth
       * @return {?}
       */
      SatCalendar.prototype._monthSelectedInYearView = /**
       * Handles month selection in the year view.
       * @param {?} normalizedMonth
       * @return {?}
       */
          function (normalizedMonth) {
              this.monthSelected.emit(normalizedMonth);
          };
      /**
       * @return {?}
       */
      SatCalendar.prototype._userSelected = /**
       * @return {?}
       */
          function () {
              this._userSelection.emit();
          };
      /** Handles year/month selection in the multi-year/year views. */
      /**
       * Handles year/month selection in the multi-year/year views.
       * @param {?} date
       * @param {?} view
       * @return {?}
       */
      SatCalendar.prototype._goToDateInView = /**
       * Handles year/month selection in the multi-year/year views.
       * @param {?} date
       * @param {?} view
       * @return {?}
       */
          function (date, view) {
              this.activeDate = date;
              this.currentView = view;
          };
      /**
       * @param {?} obj The object to check.
       * @return {?} The given object if it is both a date instance and valid, otherwise null.
       */
      SatCalendar.prototype._getValidDateOrNull = /**
       * @param {?} obj The object to check.
       * @return {?} The given object if it is both a date instance and valid, otherwise null.
       */
          function (obj) {
              return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
          };
      /**
       * Returns the component instance that corresponds to the current calendar view.
       * @return {?}
       */
      SatCalendar.prototype._getCurrentViewComponent = /**
       * Returns the component instance that corresponds to the current calendar view.
       * @return {?}
       */
          function () {
              return this.monthView || this.yearView || this.multiYearView;
          };
      SatCalendar.decorators = [
          { type: i0.Component, args: [{
                      moduleId: module.id,
                      selector: 'sat-calendar',
                      template: "\n<ng-template [cdkPortalOutlet]=\"_calendarHeaderPortal\"></ng-template>\n\n<div class=\"mat-calendar-content\" [ngSwitch]=\"currentView\" cdkMonitorSubtreeFocus tabindex=\"-1\">\n  <sat-month-view\n      *ngSwitchCase=\"'month'\"\n      [(activeDate)]=\"activeDate\"\n      [selected]=\"selected\"\n      [beginDate]=\"beginDate\"\n      [endDate]=\"endDate\"\n      [rangeMode]=\"rangeMode\"\n      [dateFilter]=\"dateFilter\"\n      [maxDate]=\"maxDate\"\n      [minDate]=\"minDate\"\n      (selectedChange)=\"_dateSelected($event)\"\n      (_userSelection)=\"_userSelected()\">\n  </sat-month-view>\n\n  <sat-year-view\n      *ngSwitchCase=\"'year'\"\n      [(activeDate)]=\"activeDate\"\n      [selected]=\"selected\"\n      [dateFilter]=\"dateFilter\"\n      [maxDate]=\"maxDate\"\n      [minDate]=\"minDate\"\n      (monthSelected)=\"_monthSelectedInYearView($event)\"\n      (selectedChange)=\"_goToDateInView($event, 'month')\">\n  </sat-year-view>\n\n  <sat-multi-year-view\n      *ngSwitchCase=\"'multi-year'\"\n      [(activeDate)]=\"activeDate\"\n      [selected]=\"selected\"\n      [dateFilter]=\"dateFilter\"\n      [maxDate]=\"maxDate\"\n      [minDate]=\"minDate\"\n      (yearSelected)=\"_yearSelectedInMultiYearView($event)\"\n      (selectedChange)=\"_goToDateInView($event, 'year')\">\n  </sat-multi-year-view>\n</div>\n",
                      host: {
                          'class': 'mat-calendar',
                      },
                      exportAs: 'matCalendar',
                      encapsulation: i0.ViewEncapsulation.None,
                      changeDetection: i0.ChangeDetectionStrategy.OnPush,
                      styles: [".mat-calendar{display:block}.mat-calendar-header{padding:8px 8px 0}.mat-calendar-content{padding:0 8px 8px;outline:0}.mat-calendar-controls{display:flex;margin:5% calc(33% / 7 - 16px)}.mat-calendar-spacer{flex:1 1 auto}.mat-calendar-period-button{min-width:0}.mat-calendar-arrow{display:inline-block;width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top-width:5px;border-top-style:solid;margin:0 0 0 5px;vertical-align:middle}.mat-calendar-arrow.mat-calendar-invert{-webkit-transform:rotate(180deg);transform:rotate(180deg)}[dir=rtl] .mat-calendar-arrow{margin:0 5px 0 0}.mat-calendar-next-button,.mat-calendar-previous-button{position:relative}.mat-calendar-next-button::after,.mat-calendar-previous-button::after{top:0;left:0;right:0;bottom:0;position:absolute;content:'';margin:15.5px;border:0 solid currentColor;border-top-width:2px}[dir=rtl] .mat-calendar-next-button,[dir=rtl] .mat-calendar-previous-button{-webkit-transform:rotate(180deg);transform:rotate(180deg)}.mat-calendar-previous-button::after{border-left-width:2px;-webkit-transform:translateX(2px) rotate(-45deg);transform:translateX(2px) rotate(-45deg)}.mat-calendar-next-button::after{border-right-width:2px;-webkit-transform:translateX(-2px) rotate(45deg);transform:translateX(-2px) rotate(45deg)}.mat-calendar-table{border-spacing:0;border-collapse:collapse;width:100%}.mat-calendar-table-header th{text-align:center;padding:0 0 8px}.mat-calendar-table-header-divider{position:relative;height:1px}.mat-calendar-table-header-divider::after{content:'';position:absolute;top:0;left:-8px;right:-8px;height:1px}"]
                  }] }
      ];
      /** @nocollapse */
      SatCalendar.ctorParameters = function () {
          return [
              { type: SatDatepickerIntl },
              { type: DateAdapter, decorators: [{ type: i0.Optional }] },
              { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [MAT_DATE_FORMATS,] }] },
              { type: i0.ChangeDetectorRef }
          ];
      };
      SatCalendar.propDecorators = {
          beginDate: [{ type: i0.Input }],
          endDate: [{ type: i0.Input }],
          rangeMode: [{ type: i0.Input }],
          dateRangesChange: [{ type: i0.Output }],
          headerComponent: [{ type: i0.Input }],
          startAt: [{ type: i0.Input }],
          startView: [{ type: i0.Input }],
          selected: [{ type: i0.Input }],
          minDate: [{ type: i0.Input }],
          maxDate: [{ type: i0.Input }],
          dateFilter: [{ type: i0.Input }],
          orderPeriodLabel: [{ type: i0.Input }],
          selectedChange: [{ type: i0.Output }],
          yearSelected: [{ type: i0.Output }],
          monthSelected: [{ type: i0.Output }],
          _userSelection: [{ type: i0.Output }],
          monthView: [{ type: i0.ViewChild, args: [SatMonthView,] }],
          yearView: [{ type: i0.ViewChild, args: [SatYearView,] }],
          multiYearView: [{ type: i0.ViewChild, args: [SatMultiYearView,] }]
      };
      return SatCalendar;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** *
   * Animations used by the Material datepicker.
    @type {?} */
  var matDatepickerAnimations = {
      /** Transforms the height of the datepicker's calendar. */
      transformPanel: animations.trigger('transformPanel', [
          animations.state('void', animations.style({ opacity: 0, transform: 'scale(1, 0)' })),
          animations.state('enter', animations.style({ opacity: 1, transform: 'scale(1, 1)' })),
          animations.transition('void => enter', animations.group([
              animations.query('@fadeInCalendar', animations.animateChild()),
              animations.animate('400ms cubic-bezier(0.25, 0.8, 0.25, 1)')
          ])),
          animations.transition('* => void', animations.animate('100ms linear', animations.style({ opacity: 0 })))
      ]),
      /** Fades in the content of the calendar. */
      fadeInCalendar: animations.trigger('fadeInCalendar', [
          animations.state('void', animations.style({ opacity: 0 })),
          animations.state('enter', animations.style({ opacity: 1 })),
          animations.transition('void => *', animations.animate('400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)'))
      ])
  };

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** *
   * Used to generate a unique ID for each datepicker instance.
    @type {?} */
  var datepickerUid = 0;
  /** *
   * Injection token that determines the scroll handling while the calendar is open.
    @type {?} */
  var MAT_DATEPICKER_SCROLL_STRATEGY = new i0.InjectionToken('sat-datepicker-scroll-strategy');
  /**
   * \@docs-private
   * @param {?} overlay
   * @return {?}
   */
  function MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY(overlay$$1) {
      return function () { return overlay$$1.scrollStrategies.reposition(); };
  }
  /** *
   * \@docs-private
    @type {?} */
  var MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER = {
      provide: MAT_DATEPICKER_SCROLL_STRATEGY,
      deps: [overlay.Overlay],
      useFactory: MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY,
  };
  /**
   * \@docs-private
   */
  var /**
   * \@docs-private
   */ SatDatepickerContentBase = (function () {
      function SatDatepickerContentBase(_elementRef) {
          this._elementRef = _elementRef;
      }
      return SatDatepickerContentBase;
  }());
  /** @type {?} */
  var _SatDatepickerContentMixinBase = core.mixinColor(SatDatepickerContentBase);
  /**
   * Component used as the content for the datepicker dialog and popup. We use this instead of using
   * SatCalendar directly as the content so we can control the initial focus. This also gives us a
   * place to put additional features of the popup that are not part of the calendar itself in the
   * future. (e.g. confirmation buttons).
   * \@docs-private
   * @template D
   */
  var SatDatepickerContent = (function (_super) {
      __extends(SatDatepickerContent, _super);
      function SatDatepickerContent(elementRef) {
          return _super.call(this, elementRef) || this;
      }
      /**
       * @return {?}
       */
      SatDatepickerContent.prototype.ngAfterViewInit = /**
       * @return {?}
       */
          function () {
              this._calendar.focusActiveCell();
          };
      /**
       * @return {?}
       */
      SatDatepickerContent.prototype.close = /**
       * @return {?}
       */
          function () {
              if (this.datepicker.closeAfterSelection) {
                  this.datepicker.close();
              }
          };
      SatDatepickerContent.decorators = [
          { type: i0.Component, args: [{
                      moduleId: module.id,
                      selector: 'sat-datepicker-content',
                      template: "<sat-calendar cdkTrapFocus\n              [id]=\"datepicker.id\"\n              [ngClass]=\"datepicker.panelClass\"\n              [startAt]=\"datepicker.startAt\"\n              [startView]=\"datepicker.startView\"\n              [minDate]=\"datepicker._minDate\"\n              [maxDate]=\"datepicker._maxDate\"\n              [dateFilter]=\"datepicker._dateFilter\"\n              [beginDate]=\"datepicker._beginDate\"\n              [endDate]=\"datepicker._endDate\"\n              [headerComponent]=\"datepicker.calendarHeaderComponent\"\n              [rangeMode]=\"datepicker.rangeMode\"\n              [selected]=\"datepicker._selected\"\n              [@fadeInCalendar]=\"'enter'\"\n              [orderPeriodLabel]=\"datepicker.orderPeriodLabel\"\n              (selectedChange)=\"datepicker._select($event)\"\n              (dateRangesChange)=\"datepicker._selectRange($event)\"\n              (yearSelected)=\"datepicker._selectYear($event)\"\n              (monthSelected)=\"datepicker._selectMonth($event)\"\n              (_userSelection)=\"close()\">\n</sat-calendar>\n",
                      host: {
                          'class': 'mat-datepicker-content',
                          '[@transformPanel]': '"enter"',
                          '[class.mat-datepicker-content-touch]': 'datepicker.touchUi',
                      },
                      animations: [
                          matDatepickerAnimations.transformPanel,
                          matDatepickerAnimations.fadeInCalendar,
                      ],
                      exportAs: 'matDatepickerContent',
                      encapsulation: i0.ViewEncapsulation.None,
                      changeDetection: i0.ChangeDetectionStrategy.OnPush,
                      inputs: ['color'],
                      styles: [".mat-datepicker-content{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);display:block}.mat-datepicker-content .mat-calendar{width:296px;height:354px}.mat-datepicker-content-touch{box-shadow:0 0 0 0 rgba(0,0,0,.2),0 0 0 0 rgba(0,0,0,.14),0 0 0 0 rgba(0,0,0,.12);display:block;max-height:80vh;overflow:auto;margin:-24px}.mat-datepicker-content-touch .mat-calendar{min-width:250px;min-height:312px;max-width:750px;max-height:788px}@media all and (orientation:landscape){.mat-datepicker-content-touch .mat-calendar{width:64vh;height:80vh}}@media all and (orientation:portrait){.mat-datepicker-content-touch .mat-calendar{width:80vw;height:100vw}}"]
                  }] }
      ];
      /** @nocollapse */
      SatDatepickerContent.ctorParameters = function () {
          return [
              { type: i0.ElementRef }
          ];
      };
      SatDatepickerContent.propDecorators = {
          _calendar: [{ type: i0.ViewChild, args: [SatCalendar,] }]
      };
      return SatDatepickerContent;
  }(_SatDatepickerContentMixinBase));
  /**
   * Component responsible for managing the datepicker popup/dialog.
   * @template D
   */
  var SatDatepicker = (function () {
      function SatDatepicker(_dialog, _overlay, _ngZone, _viewContainerRef, _scrollStrategy, _dateAdapter, _dir, _document) {
          this._dialog = _dialog;
          this._overlay = _overlay;
          this._ngZone = _ngZone;
          this._viewContainerRef = _viewContainerRef;
          this._scrollStrategy = _scrollStrategy;
          this._dateAdapter = _dateAdapter;
          this._dir = _dir;
          this._document = _document;
          /**
           * The view that the calendar should start in.
           */
          this.startView = 'month';
          this._touchUi = false;
          /**
           * Emits selected year in multiyear view.
           * This doesn't imply a change on the selected date.
           */
          this.yearSelected = new i0.EventEmitter();
          /**
           * Emits selected month in year view.
           * This doesn't imply a change on the selected date.
           */
          this.monthSelected = new i0.EventEmitter();
          /**
           * Emits when the datepicker has been opened.
           */
          this.openedStream = new i0.EventEmitter();
          /**
           * Emits when the datepicker has been closed.
           */
          this.closedStream = new i0.EventEmitter();
          /**
           * Enables datepicker closing after selection
           */
          this.closeAfterSelection = true;
          /**
           * Order the views when clicking on period label button
           */
          this.orderPeriodLabel = 'multi-year';
          this._opened = false;
          /**
           * The id for the datepicker calendar.
           */
          this.id = "sat-datepicker-" + datepickerUid++;
          this._validSelected = null;
          /**
           * The element that was focused before the datepicker was opened.
           */
          this._focusedElementBeforeOpen = null;
          /**
           * Subscription to value changes in the associated input element.
           */
          this._inputSubscription = rxjs.Subscription.EMPTY;
          /**
           * Emits when the datepicker is disabled.
           */
          this._disabledChange = new rxjs.Subject();
          /**
           * Emits new selected date when selected date changes.
           */
          this._selectedChanged = new rxjs.Subject();
          if (!this._dateAdapter) {
              throw createMissingDateImplError('DateAdapter');
          }
      }
      Object.defineProperty(SatDatepicker.prototype, "rangeMode", {
          /** Whenever datepicker is for selecting range of dates. */
          get: /**
           * Whenever datepicker is for selecting range of dates.
           * @return {?}
           */ function () {
              return this._rangeMode;
          },
          set: /**
           * @param {?} mode
           * @return {?}
           */ function (mode) {
              this._rangeMode = mode;
              if (this.rangeMode) {
                  this._validSelected = null;
              }
              else {
                  this._beginDate = this._endDate = null;
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatDatepicker.prototype, "beginDate", {
          /** Start of dates interval. */
          get: /**
           * Start of dates interval.
           * @return {?}
           */ function () { return this._beginDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._validSelected = null;
              this._beginDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatDatepicker.prototype, "endDate", {
          /** End of dates interval. */
          get: /**
           * End of dates interval.
           * @return {?}
           */ function () { return this._endDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._validSelected = null;
              this._endDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatDatepicker.prototype, "startAt", {
          /** The date to open the calendar to initially. */
          get: /**
           * The date to open the calendar to initially.
           * @return {?}
           */ function () {
              // If an explicit startAt is set we start there, otherwise we start at whatever the currently
              // selected value is.
              if (this.rangeMode) {
                  return this._startAt || (this._datepickerInput && this._datepickerInput.value ?
                      ((this._datepickerInput.value)).begin : null);
              }
              return this._startAt || (this._datepickerInput ? /** @type {?} */ (this._datepickerInput.value) : null);
          },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._startAt = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatDatepicker.prototype, "color", {
          /** Color palette to use on the datepicker's calendar. */
          get: /**
           * Color palette to use on the datepicker's calendar.
           * @return {?}
           */ function () {
              return this._color ||
                  (this._datepickerInput ? this._datepickerInput._getThemePalette() : undefined);
          },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._color = value;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatDatepicker.prototype, "touchUi", {
          /**
           * Whether the calendar UI is in touch mode. In touch mode the calendar opens in a dialog rather
           * than a popup and elements have more padding to allow for bigger touch targets.
           */
          get: /**
           * Whether the calendar UI is in touch mode. In touch mode the calendar opens in a dialog rather
           * than a popup and elements have more padding to allow for bigger touch targets.
           * @return {?}
           */ function () { return this._touchUi; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._touchUi = coercion.coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatDatepicker.prototype, "disabled", {
          /** Whether the datepicker pop-up should be disabled. */
          get: /**
           * Whether the datepicker pop-up should be disabled.
           * @return {?}
           */ function () {
              return this._disabled === undefined && this._datepickerInput ?
                  this._datepickerInput.disabled : !!this._disabled;
          },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              /** @type {?} */
              var newValue = coercion.coerceBooleanProperty(value);
              if (newValue !== this._disabled) {
                  this._disabled = newValue;
                  this._disabledChange.next(newValue);
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatDatepicker.prototype, "opened", {
          /** Whether the calendar is open. */
          get: /**
           * Whether the calendar is open.
           * @return {?}
           */ function () { return this._opened; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { value ? this.open() : this.close(); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatDatepicker.prototype, "_selected", {
          /** The currently selected date. */
          get: /**
           * The currently selected date.
           * @return {?}
           */ function () { return this._validSelected; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._validSelected = value; },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatDatepicker.prototype, "_minDate", {
          /** The minimum selectable date. */
          get: /**
           * The minimum selectable date.
           * @return {?}
           */ function () {
              return this._datepickerInput && this._datepickerInput.min;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatDatepicker.prototype, "_maxDate", {
          /** The maximum selectable date. */
          get: /**
           * The maximum selectable date.
           * @return {?}
           */ function () {
              return this._datepickerInput && this._datepickerInput.max;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatDatepicker.prototype, "_dateFilter", {
          get: /**
           * @return {?}
           */ function () {
              return this._datepickerInput && this._datepickerInput._dateFilter;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      SatDatepicker.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this.close();
              this._inputSubscription.unsubscribe();
              this._disabledChange.complete();
              if (this._popupRef) {
                  this._popupRef.dispose();
                  this._popupComponentRef = null;
              }
          };
      /** Selects the given date */
      /**
       * Selects the given date
       * @param {?} date
       * @return {?}
       */
      SatDatepicker.prototype._select = /**
       * Selects the given date
       * @param {?} date
       * @return {?}
       */
          function (date) {
              /** @type {?} */
              var oldValue = this._selected;
              this._selected = date;
              if (!this._dateAdapter.sameDate(oldValue, this._selected)) {
                  this._selectedChanged.next(date);
              }
          };
      /** Selects the given date range */
      /**
       * Selects the given date range
       * @param {?} dates
       * @return {?}
       */
      SatDatepicker.prototype._selectRange = /**
       * Selects the given date range
       * @param {?} dates
       * @return {?}
       */
          function (dates) {
              if (!this._dateAdapter.sameDate(dates.begin, this.beginDate) ||
                  !this._dateAdapter.sameDate(dates.end, this.endDate)) {
                  this._selectedChanged.next(dates);
              }
              this._beginDate = dates.begin;
              this._endDate = dates.end;
          };
      /** Emits the selected year in multiyear view */
      /**
       * Emits the selected year in multiyear view
       * @param {?} normalizedYear
       * @return {?}
       */
      SatDatepicker.prototype._selectYear = /**
       * Emits the selected year in multiyear view
       * @param {?} normalizedYear
       * @return {?}
       */
          function (normalizedYear) {
              this.yearSelected.emit(normalizedYear);
          };
      /** Emits selected month in year view */
      /**
       * Emits selected month in year view
       * @param {?} normalizedMonth
       * @return {?}
       */
      SatDatepicker.prototype._selectMonth = /**
       * Emits selected month in year view
       * @param {?} normalizedMonth
       * @return {?}
       */
          function (normalizedMonth) {
              this.monthSelected.emit(normalizedMonth);
          };
      /**
       * Register an input with this datepicker.
       * @param input The datepicker input to register with this datepicker.
       */
      /**
       * Register an input with this datepicker.
       * @param {?} input The datepicker input to register with this datepicker.
       * @return {?}
       */
      SatDatepicker.prototype._registerInput = /**
       * Register an input with this datepicker.
       * @param {?} input The datepicker input to register with this datepicker.
       * @return {?}
       */
          function (input$$1) {
              var _this = this;
              if (this._datepickerInput) {
                  throw Error('A SatDatepicker can only be associated with a single input.');
              }
              this._datepickerInput = input$$1;
              this._inputSubscription =
                  this._datepickerInput._valueChange
                      .subscribe(function (value) {
                      if (value === null) {
                          _this.beginDate = _this.endDate = _this._selected = null;
                          return;
                      }
                      if (value && value.hasOwnProperty('begin') && value.hasOwnProperty('end')) {
                          value = /** @type {?} */ (value);
                          if (value.begin && value.end &&
                              _this._dateAdapter.compareDate(value.begin, value.end) <= 0) {
                              _this.beginDate = value.begin;
                              _this.endDate = value.end;
                          }
                          else {
                              _this.beginDate = _this.endDate = null;
                          }
                      }
                      else {
                          _this._selected = /** @type {?} */ (value);
                      }
                  });
          };
      /** Open the calendar. */
      /**
       * Open the calendar.
       * @return {?}
       */
      SatDatepicker.prototype.open = /**
       * Open the calendar.
       * @return {?}
       */
          function () {
              if (this._opened || this.disabled) {
                  return;
              }
              if (!this._datepickerInput) {
                  throw Error('Attempted to open an SatDatepicker with no associated input.');
              }
              if (this._document) {
                  this._focusedElementBeforeOpen = this._document.activeElement;
              }
              this.touchUi ? this._openAsDialog() : this._openAsPopup();
              this._opened = true;
              this.openedStream.emit();
          };
      /** Close the calendar. */
      /**
       * Close the calendar.
       * @return {?}
       */
      SatDatepicker.prototype.close = /**
       * Close the calendar.
       * @return {?}
       */
          function () {
              var _this = this;
              if (!this._opened) {
                  return;
              }
              if (this._popupRef && this._popupRef.hasAttached()) {
                  this._popupRef.detach();
              }
              if (this._dialogRef) {
                  this._dialogRef.close();
                  this._dialogRef = null;
              }
              if (this._calendarPortal && this._calendarPortal.isAttached) {
                  this._calendarPortal.detach();
              }
              /** @type {?} */
              var completeClose = function () {
                  // The `_opened` could've been reset already if
                  // we got two events in quick succession.
                  if (_this._opened) {
                      _this._opened = false;
                      _this.closedStream.emit();
                      _this._focusedElementBeforeOpen = null;
                  }
              };
              if (this._focusedElementBeforeOpen &&
                  typeof this._focusedElementBeforeOpen.focus === 'function') {
                  // Because IE moves focus asynchronously, we can't count on it being restored before we've
                  // marked the datepicker as closed. If the event fires out of sequence and the element that
                  // we're refocusing opens the datepicker on focus, the user could be stuck with not being
                  // able to close the calendar at all. We work around it by making the logic, that marks
                  // the datepicker as closed, async as well.
                  this._focusedElementBeforeOpen.focus();
                  setTimeout(completeClose);
              }
              else {
                  completeClose();
              }
          };
      /**
       * Open the calendar as a dialog.
       * @return {?}
       */
      SatDatepicker.prototype._openAsDialog = /**
       * Open the calendar as a dialog.
       * @return {?}
       */
          function () {
              var _this = this;
              this._dialogRef = this._dialog.open(SatDatepickerContent, {
                  direction: this._dir ? this._dir.value : 'ltr',
                  viewContainerRef: this._viewContainerRef,
                  panelClass: 'mat-datepicker-dialog',
              });
              this._dialogRef.afterClosed().subscribe(function () { return _this.close(); });
              this._dialogRef.componentInstance.datepicker = this;
              this._setColor();
          };
      /**
       * Open the calendar as a popup.
       * @return {?}
       */
      SatDatepicker.prototype._openAsPopup = /**
       * Open the calendar as a popup.
       * @return {?}
       */
          function () {
              var _this = this;
              if (!this._calendarPortal) {
                  this._calendarPortal = new portal.ComponentPortal(SatDatepickerContent, this._viewContainerRef);
              }
              if (!this._popupRef) {
                  this._createPopup();
              }
              if (!this._popupRef.hasAttached()) {
                  this._popupComponentRef = this._popupRef.attach(this._calendarPortal);
                  this._popupComponentRef.instance.datepicker = this;
                  this._setColor();
                  // Update the position once the calendar has rendered.
                  this._ngZone.onStable.asObservable().pipe(operators.take(1)).subscribe(function () {
                      _this._popupRef.updatePosition();
                  });
              }
          };
      /**
       * Create the popup.
       * @return {?}
       */
      SatDatepicker.prototype._createPopup = /**
       * Create the popup.
       * @return {?}
       */
          function () {
              var _this = this;
              /** @type {?} */
              var overlayConfig = new overlay.OverlayConfig({
                  positionStrategy: this._createPopupPositionStrategy(),
                  hasBackdrop: true,
                  backdropClass: 'mat-overlay-transparent-backdrop',
                  direction: this._dir,
                  scrollStrategy: this._scrollStrategy(),
                  panelClass: 'mat-datepicker-popup',
              });
              this._popupRef = this._overlay.create(overlayConfig);
              this._popupRef.overlayElement.setAttribute('role', 'dialog');
              rxjs.merge(this._popupRef.backdropClick(), this._popupRef.detachments(), this._popupRef.keydownEvents().pipe(operators.filter(function (event) {
                  // Closing on alt + up is only valid when there's an input associated with the datepicker.
                  return event.keyCode === keycodes.ESCAPE ||
                      (_this._datepickerInput && event.altKey && event.keyCode === keycodes.UP_ARROW);
              }))).subscribe(function () { return _this.close(); });
          };
      /**
       * Create the popup PositionStrategy.
       * @return {?}
       */
      SatDatepicker.prototype._createPopupPositionStrategy = /**
       * Create the popup PositionStrategy.
       * @return {?}
       */
          function () {
              return this._overlay.position()
                  .flexibleConnectedTo(this._datepickerInput.getConnectedOverlayOrigin())
                  .withTransformOriginOn('.mat-datepicker-content')
                  .withFlexibleDimensions(false)
                  .withViewportMargin(8)
                  .withPush(false)
                  .withPositions([
                  {
                      originX: 'start',
                      originY: 'bottom',
                      overlayX: 'start',
                      overlayY: 'top'
                  },
                  {
                      originX: 'start',
                      originY: 'top',
                      overlayX: 'start',
                      overlayY: 'bottom'
                  },
                  {
                      originX: 'end',
                      originY: 'bottom',
                      overlayX: 'end',
                      overlayY: 'top'
                  },
                  {
                      originX: 'end',
                      originY: 'top',
                      overlayX: 'end',
                      overlayY: 'bottom'
                  }
              ]);
          };
      /**
       * @param {?} obj The object to check.
       * @return {?} The given object if it is both a date instance and valid, otherwise null.
       */
      SatDatepicker.prototype._getValidDateOrNull = /**
       * @param {?} obj The object to check.
       * @return {?} The given object if it is both a date instance and valid, otherwise null.
       */
          function (obj) {
              return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
          };
      /**
       * Passes the current theme color along to the calendar overlay.
       * @return {?}
       */
      SatDatepicker.prototype._setColor = /**
       * Passes the current theme color along to the calendar overlay.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var color = this.color;
              if (this._popupComponentRef) {
                  this._popupComponentRef.instance.color = color;
              }
              if (this._dialogRef) {
                  this._dialogRef.componentInstance.color = color;
              }
          };
      SatDatepicker.decorators = [
          { type: i0.Component, args: [{
                      moduleId: module.id,
                      selector: 'sat-datepicker',
                      template: '',
                      exportAs: 'matDatepicker',
                      changeDetection: i0.ChangeDetectionStrategy.OnPush,
                      encapsulation: i0.ViewEncapsulation.None
                  }] }
      ];
      /** @nocollapse */
      SatDatepicker.ctorParameters = function () {
          return [
              { type: dialog.MatDialog },
              { type: overlay.Overlay },
              { type: i0.NgZone },
              { type: i0.ViewContainerRef },
              { type: undefined, decorators: [{ type: i0.Inject, args: [MAT_DATEPICKER_SCROLL_STRATEGY,] }] },
              { type: DateAdapter, decorators: [{ type: i0.Optional }] },
              { type: bidi.Directionality, decorators: [{ type: i0.Optional }] },
              { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [common.DOCUMENT,] }] }
          ];
      };
      SatDatepicker.propDecorators = {
          rangeMode: [{ type: i0.Input }],
          beginDate: [{ type: i0.Input }],
          endDate: [{ type: i0.Input }],
          calendarHeaderComponent: [{ type: i0.Input }],
          startAt: [{ type: i0.Input }],
          startView: [{ type: i0.Input }],
          color: [{ type: i0.Input }],
          touchUi: [{ type: i0.Input }],
          disabled: [{ type: i0.Input }],
          yearSelected: [{ type: i0.Output }],
          monthSelected: [{ type: i0.Output }],
          panelClass: [{ type: i0.Input }],
          openedStream: [{ type: i0.Output, args: ['opened',] }],
          closedStream: [{ type: i0.Output, args: ['closed',] }],
          closeAfterSelection: [{ type: i0.Input }],
          orderPeriodLabel: [{ type: i0.Input }],
          opened: [{ type: i0.Input }]
      };
      return SatDatepicker;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** @type {?} */
  var MAT_DATEPICKER_VALUE_ACCESSOR = {
      provide: forms.NG_VALUE_ACCESSOR,
      useExisting: i0.forwardRef(function () { return SatDatepickerInput; }),
      multi: true
  };
  /** @type {?} */
  var MAT_DATEPICKER_VALIDATORS = {
      provide: forms.NG_VALIDATORS,
      useExisting: i0.forwardRef(function () { return SatDatepickerInput; }),
      multi: true
  };
  /**
   * An event used for datepicker input and change events. We don't always have access to a native
   * input or change event because the event may have been triggered by the user clicking on the
   * calendar popup. For consistency, we always use SatDatepickerInputEvent instead.
   * @template D
   */
  var /**
   * An event used for datepicker input and change events. We don't always have access to a native
   * input or change event because the event may have been triggered by the user clicking on the
   * calendar popup. For consistency, we always use SatDatepickerInputEvent instead.
   * @template D
   */ SatDatepickerInputEvent = (function () {
      function SatDatepickerInputEvent(target, targetElement) {
          this.target = target;
          this.targetElement = targetElement;
          this.value = this.target.value;
      }
      return SatDatepickerInputEvent;
  }());
  /**
   * Directive used to connect an input to a SatDatepicker.
   * @template D
   */
  var SatDatepickerInput = (function () {
      function SatDatepickerInput(_elementRef, _dateAdapter, _dateFormats, _formField) {
          var _this = this;
          this._elementRef = _elementRef;
          this._dateAdapter = _dateAdapter;
          this._dateFormats = _dateFormats;
          this._formField = _formField;
          /**
           * Emits when a `change` event is fired on this `<input>`.
           */
          this.dateChange = new i0.EventEmitter();
          /**
           * Emits when an `input` event is fired on this `<input>`.
           */
          this.dateInput = new i0.EventEmitter();
          /**
           * Emits when the value changes (either due to user input or programmatic change).
           */
          this._valueChange = new i0.EventEmitter();
          /**
           * Emits when the disabled state has changed
           */
          this._disabledChange = new i0.EventEmitter();
          this._onTouched = function () { };
          this._cvaOnChange = function () { };
          this._validatorOnChange = function () { };
          this._datepickerSubscription = rxjs.Subscription.EMPTY;
          this._localeSubscription = rxjs.Subscription.EMPTY;
          /**
           * The form control validator for whether the input parses.
           */
          this._parseValidator = function () {
              return _this._lastValueValid ?
                  null : { 'matDatepickerParse': { 'text': _this._elementRef.nativeElement.value } };
          };
          /**
           * The form control validator for the min date.
           */
          this._minValidator = function (control) {
              if (_this._datepicker.rangeMode && control.value) {
                  /** @type {?} */
                  var beginDate = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value.begin));
                  /** @type {?} */
                  var endDate = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value.end));
                  if (_this.min) {
                      if (beginDate && _this._dateAdapter.compareDate(_this.min, beginDate) > 0) {
                          return { 'matDatepickerMin': { 'min': _this.min, 'actual': beginDate } };
                      }
                      if (endDate && _this._dateAdapter.compareDate(_this.min, endDate) > 0) {
                          return { 'matDatepickerMin': { 'min': _this.min, 'actual': endDate } };
                      }
                  }
                  return null;
              }
              /** @type {?} */
              var controlValue = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value));
              return (!_this.min || !controlValue ||
                  _this._dateAdapter.compareDate(_this.min, controlValue) <= 0) ?
                  null : { 'matDatepickerMin': { 'min': _this.min, 'actual': controlValue } };
          };
          /**
           * The form control validator for the max date.
           */
          this._maxValidator = function (control) {
              if (_this._datepicker.rangeMode && control.value) {
                  /** @type {?} */
                  var beginDate = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value.begin));
                  /** @type {?} */
                  var endDate = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value.end));
                  if (_this.max) {
                      if (beginDate && _this._dateAdapter.compareDate(_this.max, beginDate) < 0) {
                          return { 'matDatepickerMax': { 'max': _this.max, 'actual': beginDate } };
                      }
                      if (endDate && _this._dateAdapter.compareDate(_this.max, endDate) < 0) {
                          return { 'matDatepickerMax': { 'max': _this.max, 'actual': endDate } };
                      }
                  }
                  return null;
              }
              /** @type {?} */
              var controlValue = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value));
              return (!_this.max || !controlValue ||
                  _this._dateAdapter.compareDate(_this.max, controlValue) >= 0) ?
                  null : { 'matDatepickerMax': { 'max': _this.max, 'actual': controlValue } };
          };
          /**
           * The form control validator for the date filter.
           */
          this._filterValidator = function (control) {
              if (_this._datepicker.rangeMode && control.value) {
                  /** @type {?} */
                  var beginDate = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value.begin));
                  /** @type {?} */
                  var endDate = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value.end));
                  return !_this._dateFilter || !beginDate && !endDate ||
                      _this._dateFilter(beginDate) && _this._dateFilter(endDate) ?
                      null : { 'matDatepickerFilter': true };
              }
              /** @type {?} */
              var controlValue = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value));
              return !_this._dateFilter || !controlValue || _this._dateFilter(controlValue) ?
                  null : { 'matDatepickerFilter': true };
          };
          /**
           * The form control validator for the date filter.
           */
          this._rangeValidator = function (control) {
              if (_this._datepicker.rangeMode && control.value) {
                  /** @type {?} */
                  var beginDate = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value.begin));
                  /** @type {?} */
                  var endDate = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value.end));
                  return !beginDate || !endDate || _this._dateAdapter.compareDate(beginDate, endDate) <= 0 ?
                      null : { 'matDatepickerRange': true };
              }
              return null;
          };
          /**
           * The combined form control validator for this input.
           */
          this._validator = forms.Validators.compose([this._parseValidator, this._minValidator, this._maxValidator,
              this._filterValidator, this._rangeValidator]);
          /**
           * Whether the last value set on the input was valid.
           */
          this._lastValueValid = false;
          if (!this._dateAdapter) {
              throw createMissingDateImplError('DateAdapter');
          }
          if (!this._dateFormats) {
              throw createMissingDateImplError('MAT_DATE_FORMATS');
          }
          // Update the displayed date when the locale changes.
          this._localeSubscription = _dateAdapter.localeChanges.subscribe(function () {
              _this.value = _this.value;
          });
      }
      Object.defineProperty(SatDatepickerInput.prototype, "satDatepicker", {
          /** The datepicker that this input is associated with. */
          set: /**
           * The datepicker that this input is associated with.
           * @param {?} value
           * @return {?}
           */ function (value) {
              this.registerDatepicker(value);
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @param {?} value
       * @return {?}
       */
      SatDatepickerInput.prototype.registerDatepicker = /**
       * @param {?} value
       * @return {?}
       */
          function (value) {
              if (value) {
                  this._datepicker = value;
                  this._datepicker._registerInput(this);
              }
          };
      Object.defineProperty(SatDatepickerInput.prototype, "matDatepickerFilter", {
          /** Function that can be used to filter out dates within the datepicker. */
          set: /**
           * Function that can be used to filter out dates within the datepicker.
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._dateFilter = value;
              this._validatorOnChange();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatDatepickerInput.prototype, "value", {
          /** The value of the input. */
          get: /**
           * The value of the input.
           * @return {?}
           */ function () {
              return this._value;
          },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              if (value && value.hasOwnProperty('begin') && value.hasOwnProperty('end')) {
                  /** *
                   * Range mode
                    @type {?} */
                  var rangeValue = (value);
                  rangeValue.begin = this._dateAdapter.deserialize(rangeValue.begin);
                  rangeValue.end = this._dateAdapter.deserialize(rangeValue.end);
                  this._lastValueValid = !rangeValue.begin || !rangeValue.end ||
                      this._dateAdapter.isValid(rangeValue.begin) && this._dateAdapter.isValid(rangeValue.end);
                  rangeValue.begin = this._getValidDateOrNull(rangeValue.begin);
                  rangeValue.end = this._getValidDateOrNull(rangeValue.end);
                  /** @type {?} */
                  var oldDate = (this.value);
                  this._elementRef.nativeElement.value =
                      rangeValue && rangeValue.begin && rangeValue.end
                          ? this._dateAdapter.format(rangeValue.begin, this._dateFormats.display.dateInput) +
                              ' - ' +
                              this._dateAdapter.format(rangeValue.end, this._dateFormats.display.dateInput)
                          : '';
                  if (oldDate == null && rangeValue != null || oldDate != null && rangeValue == null ||
                      !this._dateAdapter.sameDate(((oldDate)).begin, rangeValue.begin) ||
                      !this._dateAdapter.sameDate(((oldDate)).end, rangeValue.end)) {
                      if (rangeValue.end && rangeValue.begin &&
                          this._dateAdapter
                              .compareDate(rangeValue.begin, rangeValue.end) > 0) {
                          // if begin > end
                          value = null;
                      }
                      this._value = value;
                      this._valueChange.emit(value);
                  }
              }
              else {
                  /** Not range mode */
                  value = this._dateAdapter.deserialize(value);
                  this._lastValueValid = !value || this._dateAdapter.isValid(value);
                  value = this._getValidDateOrNull(value);
                  /** @type {?} */
                  var oldDate = this.value;
                  this._value = value;
                  this._elementRef.nativeElement.value =
                      value ? this._dateAdapter.format(value, this._dateFormats.display.dateInput) : '';
                  if (!this._dateAdapter.sameDate(/** @type {?} */ (oldDate), value)) {
                      this._valueChange.emit(value);
                  }
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatDatepickerInput.prototype, "min", {
          /** The minimum valid date. */
          get: /**
           * The minimum valid date.
           * @return {?}
           */ function () { return this._min; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._min = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
              this._validatorOnChange();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatDatepickerInput.prototype, "max", {
          /** The maximum valid date. */
          get: /**
           * The maximum valid date.
           * @return {?}
           */ function () { return this._max; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._max = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
              this._validatorOnChange();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(SatDatepickerInput.prototype, "disabled", {
          /** Whether the datepicker-input is disabled. */
          get: /**
           * Whether the datepicker-input is disabled.
           * @return {?}
           */ function () { return !!this._disabled; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              /** @type {?} */
              var newValue = coercion.coerceBooleanProperty(value);
              /** @type {?} */
              var element = this._elementRef.nativeElement;
              if (this._disabled !== newValue) {
                  this._disabled = newValue;
                  this._disabledChange.emit(newValue);
              }
              // We need to null check the `blur` method, because it's undefined during SSR.
              if (newValue && element.blur) {
                  // Normally, native input elements automatically blur if they turn disabled. This behavior
                  // is problematic, because it would mean that it triggers another change detection cycle,
                  // which then causes a changed after checked error if the input element was focused before.
                  element.blur();
              }
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      SatDatepickerInput.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              if (this._datepicker) {
                  this._datepickerSubscription =
                      this._datepicker._selectedChanged.subscribe(function (selected) {
                          _this.value = selected;
                          _this._cvaOnChange(selected);
                          _this._onTouched();
                          _this.dateInput.emit(new SatDatepickerInputEvent(_this, _this._elementRef.nativeElement));
                          _this.dateChange.emit(new SatDatepickerInputEvent(_this, _this._elementRef.nativeElement));
                      });
              }
          };
      /**
       * @return {?}
       */
      SatDatepickerInput.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._datepickerSubscription.unsubscribe();
              this._localeSubscription.unsubscribe();
              this._valueChange.complete();
              this._disabledChange.complete();
          };
      /** @docs-private */
      /**
       * \@docs-private
       * @param {?} fn
       * @return {?}
       */
      SatDatepickerInput.prototype.registerOnValidatorChange = /**
       * \@docs-private
       * @param {?} fn
       * @return {?}
       */
          function (fn) {
              this._validatorOnChange = fn;
          };
      /** @docs-private */
      /**
       * \@docs-private
       * @param {?} c
       * @return {?}
       */
      SatDatepickerInput.prototype.validate = /**
       * \@docs-private
       * @param {?} c
       * @return {?}
       */
          function (c) {
              return this._validator ? this._validator(c) : null;
          };
      /**
       * @deprecated
       * @deletion-target 7.0.0 Use `getConnectedOverlayOrigin` instead
       */
      /**
       * @deprecated
       * \@deletion-target 7.0.0 Use `getConnectedOverlayOrigin` instead
       * @return {?}
       */
      SatDatepickerInput.prototype.getPopupConnectionElementRef = /**
       * @deprecated
       * \@deletion-target 7.0.0 Use `getConnectedOverlayOrigin` instead
       * @return {?}
       */
          function () {
              return this.getConnectedOverlayOrigin();
          };
      /**
       * Gets the element that the datepicker popup should be connected to.
       * @return The element to connect the popup to.
       */
      /**
       * Gets the element that the datepicker popup should be connected to.
       * @return {?} The element to connect the popup to.
       */
      SatDatepickerInput.prototype.getConnectedOverlayOrigin = /**
       * Gets the element that the datepicker popup should be connected to.
       * @return {?} The element to connect the popup to.
       */
          function () {
              return this._formField ? this._formField.getConnectedOverlayOrigin() : this._elementRef;
          };
      // Implemented as part of ControlValueAccessor
      /**
       * @param {?} value
       * @return {?}
       */
      SatDatepickerInput.prototype.writeValue = /**
       * @param {?} value
       * @return {?}
       */
          function (value) {
              this.value = value;
          };
      // Implemented as part of ControlValueAccessor.
      /**
       * @param {?} fn
       * @return {?}
       */
      SatDatepickerInput.prototype.registerOnChange = /**
       * @param {?} fn
       * @return {?}
       */
          function (fn) {
              this._cvaOnChange = fn;
          };
      // Implemented as part of ControlValueAccessor.
      /**
       * @param {?} fn
       * @return {?}
       */
      SatDatepickerInput.prototype.registerOnTouched = /**
       * @param {?} fn
       * @return {?}
       */
          function (fn) {
              this._onTouched = fn;
          };
      // Implemented as part of ControlValueAccessor.
      /**
       * @param {?} isDisabled
       * @return {?}
       */
      SatDatepickerInput.prototype.setDisabledState = /**
       * @param {?} isDisabled
       * @return {?}
       */
          function (isDisabled) {
              this.disabled = isDisabled;
          };
      /**
       * @param {?} event
       * @return {?}
       */
      SatDatepickerInput.prototype._onKeydown = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              if (event.altKey && event.keyCode === keycodes.DOWN_ARROW) {
                  this._datepicker.open();
                  event.preventDefault();
              }
          };
      /**
       * @param {?} value
       * @return {?}
       */
      SatDatepickerInput.prototype._onInput = /**
       * @param {?} value
       * @return {?}
       */
          function (value) {
              /** @type {?} */
              var date = null;
              if (this._datepicker.rangeMode) {
                  /** @type {?} */
                  var parts = value.split('-');
                  if (parts.length > 1) {
                      /** @type {?} */
                      var position = Math.floor(parts.length / 2);
                      /** @type {?} */
                      var beginDateString = parts.slice(0, position).join('-');
                      /** @type {?} */
                      var endDateString = parts.slice(position).join('-');
                      /** @type {?} */
                      var beginDate = this._dateAdapter.parse(beginDateString, this._dateFormats.parse.dateInput);
                      /** @type {?} */
                      var endDate = this._dateAdapter.parse(endDateString, this._dateFormats.parse.dateInput);
                      this._lastValueValid = !beginDate || !endDate || this._dateAdapter.isValid(beginDate) &&
                          this._dateAdapter.isValid(endDate);
                      beginDate = this._getValidDateOrNull(beginDate);
                      endDate = this._getValidDateOrNull(endDate);
                      if (beginDate && endDate) {
                          date = /** @type {?} */ ({ begin: beginDate, end: endDate });
                      }
                  }
              }
              else {
                  date = this._dateAdapter.parse(value, this._dateFormats.parse.dateInput);
                  this._lastValueValid = !date || this._dateAdapter.isValid(date);
                  date = this._getValidDateOrNull(date);
              }
              this._value = date;
              this._cvaOnChange(date);
              this._valueChange.emit(date);
              this.dateInput.emit(new SatDatepickerInputEvent(this, this._elementRef.nativeElement));
          };
      /**
       * @return {?}
       */
      SatDatepickerInput.prototype._onChange = /**
       * @return {?}
       */
          function () {
              this.dateChange.emit(new SatDatepickerInputEvent(this, this._elementRef.nativeElement));
          };
      /** Returns the palette used by the input's form field, if any. */
      /**
       * Returns the palette used by the input's form field, if any.
       * @return {?}
       */
      SatDatepickerInput.prototype._getThemePalette = /**
       * Returns the palette used by the input's form field, if any.
       * @return {?}
       */
          function () {
              return this._formField ? this._formField.color : undefined;
          };
      /** Handles blur events on the input. */
      /**
       * Handles blur events on the input.
       * @return {?}
       */
      SatDatepickerInput.prototype._onBlur = /**
       * Handles blur events on the input.
       * @return {?}
       */
          function () {
              // Reformat the input only if we have a valid value.
              if (this.value) {
                  this._formatValue(this.value);
              }
              this._onTouched();
          };
      /**
       * Formats a value and sets it on the input element.
       * @param {?} value
       * @return {?}
       */
      SatDatepickerInput.prototype._formatValue = /**
       * Formats a value and sets it on the input element.
       * @param {?} value
       * @return {?}
       */
          function (value) {
              if (value && value.hasOwnProperty('begin') && value.hasOwnProperty('end')) {
                  value = /** @type {?} */ (value);
                  this._elementRef.nativeElement.value =
                      value && value.begin && value.end
                          ? this._dateAdapter.format(value.begin, this._dateFormats.display.dateInput) +
                              ' - ' +
                              this._dateAdapter.format(value.end, this._dateFormats.display.dateInput)
                          : '';
              }
              else {
                  value = /** @type {?} */ (value);
                  this._elementRef.nativeElement.value =
                      value ? this._dateAdapter.format(value, this._dateFormats.display.dateInput) : '';
              }
          };
      /**
       * @param {?} obj The object to check.
       * @return {?} The given object if it is both a date instance and valid, otherwise null.
       */
      SatDatepickerInput.prototype._getValidDateOrNull = /**
       * @param {?} obj The object to check.
       * @return {?} The given object if it is both a date instance and valid, otherwise null.
       */
          function (obj) {
              return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
          };
      SatDatepickerInput.decorators = [
          { type: i0.Directive, args: [{
                      selector: 'input[satDatepicker]',
                      providers: [
                          MAT_DATEPICKER_VALUE_ACCESSOR,
                          MAT_DATEPICKER_VALIDATORS,
                          { provide: input.MAT_INPUT_VALUE_ACCESSOR, useExisting: SatDatepickerInput },
                      ],
                      host: {
                          '[attr.aria-haspopup]': 'true',
                          '[attr.aria-owns]': '(_datepicker?.opened && _datepicker.id) || null',
                          '[attr.min]': 'min ? _dateAdapter.toIso8601(min) : null',
                          '[attr.max]': 'max ? _dateAdapter.toIso8601(max) : null',
                          '[disabled]': 'disabled',
                          '(input)': '_onInput($event.target.value)',
                          '(change)': '_onChange()',
                          '(blur)': '_onBlur()',
                          '(keydown)': '_onKeydown($event)',
                      },
                      exportAs: 'matDatepickerInput',
                  },] }
      ];
      /** @nocollapse */
      SatDatepickerInput.ctorParameters = function () {
          return [
              { type: i0.ElementRef },
              { type: DateAdapter, decorators: [{ type: i0.Optional }] },
              { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [MAT_DATE_FORMATS,] }] },
              { type: formField.MatFormField, decorators: [{ type: i0.Optional }] }
          ];
      };
      SatDatepickerInput.propDecorators = {
          satDatepicker: [{ type: i0.Input }],
          matDatepickerFilter: [{ type: i0.Input }],
          value: [{ type: i0.Input }],
          min: [{ type: i0.Input }],
          max: [{ type: i0.Input }],
          disabled: [{ type: i0.Input }],
          dateChange: [{ type: i0.Output }],
          dateInput: [{ type: i0.Output }]
      };
      return SatDatepickerInput;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Can be used to override the icon of a `matDatepickerToggle`.
   */
  var SatDatepickerToggleIcon = (function () {
      function SatDatepickerToggleIcon() {
      }
      SatDatepickerToggleIcon.decorators = [
          { type: i0.Directive, args: [{
                      selector: '[matDatepickerToggleIcon]'
                  },] }
      ];
      return SatDatepickerToggleIcon;
  }());
  /**
   * @template D
   */
  var SatDatepickerToggle = (function () {
      function SatDatepickerToggle(_intl, _changeDetectorRef) {
          this._intl = _intl;
          this._changeDetectorRef = _changeDetectorRef;
          this._stateChanges = rxjs.Subscription.EMPTY;
      }
      Object.defineProperty(SatDatepickerToggle.prototype, "disabled", {
          /** Whether the toggle button is disabled. */
          get: /**
           * Whether the toggle button is disabled.
           * @return {?}
           */ function () {
              return this._disabled === undefined ? this.datepicker.disabled : !!this._disabled;
          },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._disabled = coercion.coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @param {?} changes
       * @return {?}
       */
      SatDatepickerToggle.prototype.ngOnChanges = /**
       * @param {?} changes
       * @return {?}
       */
          function (changes) {
              if (changes["datepicker"]) {
                  this._watchStateChanges();
              }
          };
      /**
       * @return {?}
       */
      SatDatepickerToggle.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._stateChanges.unsubscribe();
          };
      /**
       * @return {?}
       */
      SatDatepickerToggle.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              this._watchStateChanges();
          };
      /**
       * @param {?} event
       * @return {?}
       */
      SatDatepickerToggle.prototype._open = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              if (this.datepicker && !this.disabled) {
                  this.datepicker.open();
                  event.stopPropagation();
              }
          };
      /**
       * @return {?}
       */
      SatDatepickerToggle.prototype._watchStateChanges = /**
       * @return {?}
       */
          function () {
              var _this = this;
              /** @type {?} */
              var datepickerDisabled = this.datepicker ? this.datepicker._disabledChange : rxjs.of();
              /** @type {?} */
              var inputDisabled = this.datepicker && this.datepicker._datepickerInput ?
                  this.datepicker._datepickerInput._disabledChange : rxjs.of();
              /** @type {?} */
              var datepickerToggled = this.datepicker ?
                  rxjs.merge(this.datepicker.openedStream, this.datepicker.closedStream) :
                  rxjs.of();
              this._stateChanges.unsubscribe();
              this._stateChanges = rxjs.merge(this._intl.changes, datepickerDisabled, inputDisabled, datepickerToggled).subscribe(function () { return _this._changeDetectorRef.markForCheck(); });
          };
      SatDatepickerToggle.decorators = [
          { type: i0.Component, args: [{
                      moduleId: module.id,
                      selector: 'sat-datepicker-toggle',
                      template: "<button\n        mat-icon-button\n        type=\"button\"\n        aria-haspopup=\"true\"\n        [attr.aria-label]=\"_intl.openCalendarLabel\"\n        [disabled]=\"disabled\"\n        (click)=\"_open($event)\">\n\n    <svg\n            *ngIf=\"!_customIcon\"\n            class=\"mat-datepicker-toggle-default-icon\"\n            viewBox=\"0 0 24 24\"\n            width=\"24px\"\n            height=\"24px\"\n            fill=\"currentColor\"\n            focusable=\"false\">\n        <path d=\"M0 0h24v24H0z\" fill=\"none\"/>\n        <path d=\"M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z\"/>\n    </svg>\n\n    <ng-content select=\"[matDatepickerToggleIcon]\"></ng-content>\n</button>\n",
                      host: {
                          'class': 'mat-datepicker-toggle',
                          '[class.mat-datepicker-toggle-active]': 'datepicker && datepicker.opened',
                          '[class.mat-accent]': 'datepicker && datepicker.color === "accent"',
                          '[class.mat-warn]': 'datepicker && datepicker.color === "warn"',
                      },
                      exportAs: 'matDatepickerToggle',
                      encapsulation: i0.ViewEncapsulation.None,
                      changeDetection: i0.ChangeDetectionStrategy.OnPush,
                      styles: [".mat-form-field-appearance-legacy .mat-form-field-prefix .mat-datepicker-toggle-default-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-datepicker-toggle-default-icon{width:1em}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-datepicker-toggle-default-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-datepicker-toggle-default-icon{display:block;width:1.5em;height:1.5em}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-datepicker-toggle-default-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-datepicker-toggle-default-icon{margin:auto}"]
                  }] }
      ];
      /** @nocollapse */
      SatDatepickerToggle.ctorParameters = function () {
          return [
              { type: SatDatepickerIntl },
              { type: i0.ChangeDetectorRef }
          ];
      };
      SatDatepickerToggle.propDecorators = {
          datepicker: [{ type: i0.Input, args: ['for',] }],
          disabled: [{ type: i0.Input }],
          _customIcon: [{ type: i0.ContentChild, args: [SatDatepickerToggleIcon,] }]
      };
      return SatDatepickerToggle;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var SatDatepickerModule = (function () {
      function SatDatepickerModule() {
      }
      SatDatepickerModule.decorators = [
          { type: i0.NgModule, args: [{
                      imports: [
                          common.CommonModule,
                          button.MatButtonModule,
                          dialog.MatDialogModule,
                          overlay.OverlayModule,
                          a11y.A11yModule,
                          portal.PortalModule,
                      ],
                      exports: [
                          SatCalendar,
                          SatCalendarBody,
                          SatDatepicker,
                          SatDatepickerContent,
                          SatDatepickerInput,
                          SatDatepickerToggle,
                          SatDatepickerToggleIcon,
                          SatMonthView,
                          SatYearView,
                          SatMultiYearView,
                          SatCalendarHeader,
                      ],
                      declarations: [
                          SatCalendar,
                          SatCalendarBody,
                          SatDatepicker,
                          SatDatepickerContent,
                          SatDatepickerInput,
                          SatDatepickerToggle,
                          SatDatepickerToggleIcon,
                          SatMonthView,
                          SatYearView,
                          SatMultiYearView,
                          SatCalendarHeader,
                      ],
                      providers: [
                          SatDatepickerIntl,
                          MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER,
                      ],
                      entryComponents: [
                          SatDatepickerContent,
                          SatCalendarHeader,
                      ]
                  },] }
      ];
      return SatDatepickerModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */

  exports.NativeDateModule = NativeDateModule;
  exports.SatNativeDateModule = SatNativeDateModule;
  exports.MAT_DATE_LOCALE = MAT_DATE_LOCALE;
  exports.MAT_DATE_LOCALE_FACTORY = MAT_DATE_LOCALE_FACTORY;
  exports.MAT_DATE_LOCALE_PROVIDER = MAT_DATE_LOCALE_PROVIDER;
  exports.DateAdapter = DateAdapter;
  exports.MAT_DATE_FORMATS = MAT_DATE_FORMATS;
  exports.NativeDateAdapter = NativeDateAdapter;
  exports.MAT_NATIVE_DATE_FORMATS = MAT_NATIVE_DATE_FORMATS;
  exports.SatDatepickerModule = SatDatepickerModule;
  exports.SatCalendarHeader = SatCalendarHeader;
  exports.SatCalendar = SatCalendar;
  exports.SatCalendarCell = SatCalendarCell;
  exports.SatCalendarBody = SatCalendarBody;
  exports.MAT_DATEPICKER_SCROLL_STRATEGY = MAT_DATEPICKER_SCROLL_STRATEGY;
  exports.MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY = MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY;
  exports.MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER = MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER;
  exports.SatDatepickerContentBase = SatDatepickerContentBase;
  exports._SatDatepickerContentMixinBase = _SatDatepickerContentMixinBase;
  exports.SatDatepickerContent = SatDatepickerContent;
  exports.SatDatepicker = SatDatepicker;
  exports.matDatepickerAnimations = matDatepickerAnimations;
  exports.MAT_DATEPICKER_VALUE_ACCESSOR = MAT_DATEPICKER_VALUE_ACCESSOR;
  exports.MAT_DATEPICKER_VALIDATORS = MAT_DATEPICKER_VALIDATORS;
  exports.SatDatepickerInputEvent = SatDatepickerInputEvent;
  exports.SatDatepickerInput = SatDatepickerInput;
  exports.SatDatepickerIntl = SatDatepickerIntl;
  exports.SatDatepickerToggleIcon = SatDatepickerToggleIcon;
  exports.SatDatepickerToggle = SatDatepickerToggle;
  exports.SatMonthView = SatMonthView;
  exports.SatYearView = SatYearView;
  exports.ɵa = SatMultiYearView;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2F0dXJuLWRhdGVwaWNrZXIudW1kLmpzLm1hcCIsInNvdXJjZXMiOlsibmc6Ly9zYXR1cm4tZGF0ZXBpY2tlci9kYXRldGltZS9kYXRlLWFkYXB0ZXIudHMiLCJuZzovL3NhdHVybi1kYXRlcGlja2VyL2RhdGV0aW1lL2RhdGUtZm9ybWF0cy50cyIsbnVsbCwibmc6Ly9zYXR1cm4tZGF0ZXBpY2tlci9kYXRldGltZS9uYXRpdmUtZGF0ZS1hZGFwdGVyLnRzIiwibmc6Ly9zYXR1cm4tZGF0ZXBpY2tlci9kYXRldGltZS9uYXRpdmUtZGF0ZS1mb3JtYXRzLnRzIiwibmc6Ly9zYXR1cm4tZGF0ZXBpY2tlci9kYXRldGltZS9pbmRleC50cyIsIm5nOi8vc2F0dXJuLWRhdGVwaWNrZXIvZGF0ZXBpY2tlci9kYXRlcGlja2VyLWVycm9ycy50cyIsIm5nOi8vc2F0dXJuLWRhdGVwaWNrZXIvZGF0ZXBpY2tlci9kYXRlcGlja2VyLWludGwudHMiLCJuZzovL3NhdHVybi1kYXRlcGlja2VyL2RhdGVwaWNrZXIvY2FsZW5kYXItYm9keS50cyIsIm5nOi8vc2F0dXJuLWRhdGVwaWNrZXIvZGF0ZXBpY2tlci9tb250aC12aWV3LnRzIiwibmc6Ly9zYXR1cm4tZGF0ZXBpY2tlci9kYXRlcGlja2VyL211bHRpLXllYXItdmlldy50cyIsIm5nOi8vc2F0dXJuLWRhdGVwaWNrZXIvZGF0ZXBpY2tlci95ZWFyLXZpZXcudHMiLCJuZzovL3NhdHVybi1kYXRlcGlja2VyL2RhdGVwaWNrZXIvY2FsZW5kYXIudHMiLCJuZzovL3NhdHVybi1kYXRlcGlja2VyL2RhdGVwaWNrZXIvZGF0ZXBpY2tlci1hbmltYXRpb25zLnRzIiwibmc6Ly9zYXR1cm4tZGF0ZXBpY2tlci9kYXRlcGlja2VyL2RhdGVwaWNrZXIudHMiLCJuZzovL3NhdHVybi1kYXRlcGlja2VyL2RhdGVwaWNrZXIvZGF0ZXBpY2tlci1pbnB1dC50cyIsIm5nOi8vc2F0dXJuLWRhdGVwaWNrZXIvZGF0ZXBpY2tlci9kYXRlcGlja2VyLXRvZ2dsZS50cyIsIm5nOi8vc2F0dXJuLWRhdGVwaWNrZXIvZGF0ZXBpY2tlci9kYXRlcGlja2VyLW1vZHVsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtpbmplY3QsIEluamVjdGlvblRva2VuLCBMT0NBTEVfSUR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtPYnNlcnZhYmxlLCBTdWJqZWN0fSBmcm9tICdyeGpzJztcblxuLyoqIEluamVjdGlvblRva2VuIGZvciBkYXRlcGlja2VyIHRoYXQgY2FuIGJlIHVzZWQgdG8gb3ZlcnJpZGUgZGVmYXVsdCBsb2NhbGUgY29kZS4gKi9cbmV4cG9ydCBjb25zdCBNQVRfREFURV9MT0NBTEUgPSBuZXcgSW5qZWN0aW9uVG9rZW48c3RyaW5nPignTUFUX0RBVEVfTE9DQUxFJywge1xuICBwcm92aWRlZEluOiAncm9vdCcsXG4gIGZhY3Rvcnk6IE1BVF9EQVRFX0xPQ0FMRV9GQUNUT1JZLFxufSk7XG5cbi8qKiBAZG9jcy1wcml2YXRlICovXG5leHBvcnQgZnVuY3Rpb24gTUFUX0RBVEVfTE9DQUxFX0ZBQ1RPUlkoKTogc3RyaW5nIHtcbiAgcmV0dXJuIGluamVjdChMT0NBTEVfSUQpO1xufVxuXG4vKipcbiAqIE5vIGxvbmdlciBuZWVkZWQgc2luY2UgTUFUX0RBVEVfTE9DQUxFIGhhcyBiZWVuIGNoYW5nZWQgdG8gYSBzY29wZWQgaW5qZWN0YWJsZS5cbiAqIElmIHlvdSBhcmUgaW1wb3J0aW5nIGFuZCBwcm92aWRpbmcgdGhpcyBpbiB5b3VyIGNvZGUgeW91IGNhbiBzaW1wbHkgcmVtb3ZlIGl0LlxuICogQGRlcHJlY2F0ZWRcbiAqIEBicmVha2luZy1jaGFuZ2UgNy4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IE1BVF9EQVRFX0xPQ0FMRV9QUk9WSURFUiA9IHtwcm92aWRlOiBNQVRfREFURV9MT0NBTEUsIHVzZUV4aXN0aW5nOiBMT0NBTEVfSUR9O1xuXG4vKiogQWRhcHRzIHR5cGUgYERgIHRvIGJlIHVzYWJsZSBhcyBhIGRhdGUgYnkgY2RrLWJhc2VkIGNvbXBvbmVudHMgdGhhdCB3b3JrIHdpdGggZGF0ZXMuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRGF0ZUFkYXB0ZXI8RD4ge1xuICAvKiogVGhlIGxvY2FsZSB0byB1c2UgZm9yIGFsbCBkYXRlcy4gKi9cbiAgcHJvdGVjdGVkIGxvY2FsZTogYW55O1xuXG4gIC8qKiBBIHN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gdGhlIGxvY2FsZSBjaGFuZ2VzLiAqL1xuICBnZXQgbG9jYWxlQ2hhbmdlcygpOiBPYnNlcnZhYmxlPHZvaWQ+IHsgcmV0dXJuIHRoaXMuX2xvY2FsZUNoYW5nZXM7IH1cbiAgcHJvdGVjdGVkIF9sb2NhbGVDaGFuZ2VzID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgeWVhciBjb21wb25lbnQgb2YgdGhlIGdpdmVuIGRhdGUuXG4gICAqIEBwYXJhbSBkYXRlIFRoZSBkYXRlIHRvIGV4dHJhY3QgdGhlIHllYXIgZnJvbS5cbiAgICogQHJldHVybnMgVGhlIHllYXIgY29tcG9uZW50LlxuICAgKi9cbiAgYWJzdHJhY3QgZ2V0WWVhcihkYXRlOiBEKTogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBtb250aCBjb21wb25lbnQgb2YgdGhlIGdpdmVuIGRhdGUuXG4gICAqIEBwYXJhbSBkYXRlIFRoZSBkYXRlIHRvIGV4dHJhY3QgdGhlIG1vbnRoIGZyb20uXG4gICAqIEByZXR1cm5zIFRoZSBtb250aCBjb21wb25lbnQgKDAtaW5kZXhlZCwgMCA9IEphbnVhcnkpLlxuICAgKi9cbiAgYWJzdHJhY3QgZ2V0TW9udGgoZGF0ZTogRCk6IG51bWJlcjtcblxuICAvKipcbiAgICogR2V0cyB0aGUgZGF0ZSBvZiB0aGUgbW9udGggY29tcG9uZW50IG9mIHRoZSBnaXZlbiBkYXRlLlxuICAgKiBAcGFyYW0gZGF0ZSBUaGUgZGF0ZSB0byBleHRyYWN0IHRoZSBkYXRlIG9mIHRoZSBtb250aCBmcm9tLlxuICAgKiBAcmV0dXJucyBUaGUgbW9udGggY29tcG9uZW50ICgxLWluZGV4ZWQsIDEgPSBmaXJzdCBvZiBtb250aCkuXG4gICAqL1xuICBhYnN0cmFjdCBnZXREYXRlKGRhdGU6IEQpOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGRheSBvZiB0aGUgd2VlayBjb21wb25lbnQgb2YgdGhlIGdpdmVuIGRhdGUuXG4gICAqIEBwYXJhbSBkYXRlIFRoZSBkYXRlIHRvIGV4dHJhY3QgdGhlIGRheSBvZiB0aGUgd2VlayBmcm9tLlxuICAgKiBAcmV0dXJucyBUaGUgbW9udGggY29tcG9uZW50ICgwLWluZGV4ZWQsIDAgPSBTdW5kYXkpLlxuICAgKi9cbiAgYWJzdHJhY3QgZ2V0RGF5T2ZXZWVrKGRhdGU6IEQpOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEdldHMgYSBsaXN0IG9mIG5hbWVzIGZvciB0aGUgbW9udGhzLlxuICAgKiBAcGFyYW0gc3R5bGUgVGhlIG5hbWluZyBzdHlsZSAoZS5nLiBsb25nID0gJ0phbnVhcnknLCBzaG9ydCA9ICdKYW4nLCBuYXJyb3cgPSAnSicpLlxuICAgKiBAcmV0dXJucyBBbiBvcmRlcmVkIGxpc3Qgb2YgYWxsIG1vbnRoIG5hbWVzLCBzdGFydGluZyB3aXRoIEphbnVhcnkuXG4gICAqL1xuICBhYnN0cmFjdCBnZXRNb250aE5hbWVzKHN0eWxlOiAnbG9uZycgfCAnc2hvcnQnIHwgJ25hcnJvdycpOiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogR2V0cyBhIGxpc3Qgb2YgbmFtZXMgZm9yIHRoZSBkYXRlcyBvZiB0aGUgbW9udGguXG4gICAqIEByZXR1cm5zIEFuIG9yZGVyZWQgbGlzdCBvZiBhbGwgZGF0ZSBvZiB0aGUgbW9udGggbmFtZXMsIHN0YXJ0aW5nIHdpdGggJzEnLlxuICAgKi9cbiAgYWJzdHJhY3QgZ2V0RGF0ZU5hbWVzKCk6IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBHZXRzIGEgbGlzdCBvZiBuYW1lcyBmb3IgdGhlIGRheXMgb2YgdGhlIHdlZWsuXG4gICAqIEBwYXJhbSBzdHlsZSBUaGUgbmFtaW5nIHN0eWxlIChlLmcuIGxvbmcgPSAnU3VuZGF5Jywgc2hvcnQgPSAnU3VuJywgbmFycm93ID0gJ1MnKS5cbiAgICogQHJldHVybnMgQW4gb3JkZXJlZCBsaXN0IG9mIGFsbCB3ZWVrZGF5IG5hbWVzLCBzdGFydGluZyB3aXRoIFN1bmRheS5cbiAgICovXG4gIGFic3RyYWN0IGdldERheU9mV2Vla05hbWVzKHN0eWxlOiAnbG9uZycgfCAnc2hvcnQnIHwgJ25hcnJvdycpOiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgbmFtZSBmb3IgdGhlIHllYXIgb2YgdGhlIGdpdmVuIGRhdGUuXG4gICAqIEBwYXJhbSBkYXRlIFRoZSBkYXRlIHRvIGdldCB0aGUgeWVhciBuYW1lIGZvci5cbiAgICogQHJldHVybnMgVGhlIG5hbWUgb2YgdGhlIGdpdmVuIHllYXIgKGUuZy4gJzIwMTcnKS5cbiAgICovXG4gIGFic3RyYWN0IGdldFllYXJOYW1lKGRhdGU6IEQpOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICogQHJldHVybnMgVGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlayAoMC1pbmRleGVkLCAwID0gU3VuZGF5KS5cbiAgICovXG4gIGFic3RyYWN0IGdldEZpcnN0RGF5T2ZXZWVrKCk6IG51bWJlcjtcblxuICAvKipcbiAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGRheXMgaW4gdGhlIG1vbnRoIG9mIHRoZSBnaXZlbiBkYXRlLlxuICAgKiBAcGFyYW0gZGF0ZSBUaGUgZGF0ZSB3aG9zZSBtb250aCBzaG91bGQgYmUgY2hlY2tlZC5cbiAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiBkYXlzIGluIHRoZSBtb250aCBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICovXG4gIGFic3RyYWN0IGdldE51bURheXNJbk1vbnRoKGRhdGU6IEQpOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICogQHBhcmFtIGRhdGUgVGhlIGRhdGUgdG8gY2xvbmVcbiAgICogQHJldHVybnMgQSBuZXcgZGF0ZSBlcXVhbCB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICovXG4gIGFic3RyYWN0IGNsb25lKGRhdGU6IEQpOiBEO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZGF0ZSB3aXRoIHRoZSBnaXZlbiB5ZWFyLCBtb250aCwgYW5kIGRhdGUuIERvZXMgbm90IGFsbG93IG92ZXIvdW5kZXItZmxvdyBvZiB0aGVcbiAgICogbW9udGggYW5kIGRhdGUuXG4gICAqIEBwYXJhbSB5ZWFyIFRoZSBmdWxsIHllYXIgb2YgdGhlIGRhdGUuIChlLmcuIDg5IG1lYW5zIHRoZSB5ZWFyIDg5LCBub3QgdGhlIHllYXIgMTk4OSkuXG4gICAqIEBwYXJhbSBtb250aCBUaGUgbW9udGggb2YgdGhlIGRhdGUgKDAtaW5kZXhlZCwgMCA9IEphbnVhcnkpLiBNdXN0IGJlIGFuIGludGVnZXIgMCAtIDExLlxuICAgKiBAcGFyYW0gZGF0ZSBUaGUgZGF0ZSBvZiBtb250aCBvZiB0aGUgZGF0ZS4gTXVzdCBiZSBhbiBpbnRlZ2VyIDEgLSBsZW5ndGggb2YgdGhlIGdpdmVuIG1vbnRoLlxuICAgKiBAcmV0dXJucyBUaGUgbmV3IGRhdGUsIG9yIG51bGwgaWYgaW52YWxpZC5cbiAgICovXG4gIGFic3RyYWN0IGNyZWF0ZURhdGUoeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCBkYXRlOiBudW1iZXIpOiBEO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRvZGF5J3MgZGF0ZS5cbiAgICogQHJldHVybnMgVG9kYXkncyBkYXRlLlxuICAgKi9cbiAgYWJzdHJhY3QgdG9kYXkoKTogRDtcblxuICAvKipcbiAgICogUGFyc2VzIGEgZGF0ZSBmcm9tIGEgdXNlci1wcm92aWRlZCB2YWx1ZS5cbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBwYXJzZS5cbiAgICogQHBhcmFtIHBhcnNlRm9ybWF0IFRoZSBleHBlY3RlZCBmb3JtYXQgb2YgdGhlIHZhbHVlIGJlaW5nIHBhcnNlZFxuICAgKiAgICAgKHR5cGUgaXMgaW1wbGVtZW50YXRpb24tZGVwZW5kZW50KS5cbiAgICogQHJldHVybnMgVGhlIHBhcnNlZCBkYXRlLlxuICAgKi9cbiAgYWJzdHJhY3QgcGFyc2UodmFsdWU6IGFueSwgcGFyc2VGb3JtYXQ6IGFueSk6IEQgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBGb3JtYXRzIGEgZGF0ZSBhcyBhIHN0cmluZyBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGZvcm1hdC5cbiAgICogQHBhcmFtIGRhdGUgVGhlIHZhbHVlIHRvIGZvcm1hdC5cbiAgICogQHBhcmFtIGRpc3BsYXlGb3JtYXQgVGhlIGZvcm1hdCB0byB1c2UgdG8gZGlzcGxheSB0aGUgZGF0ZSBhcyBhIHN0cmluZy5cbiAgICogQHJldHVybnMgVGhlIGZvcm1hdHRlZCBkYXRlIHN0cmluZy5cbiAgICovXG4gIGFic3RyYWN0IGZvcm1hdChkYXRlOiBELCBkaXNwbGF5Rm9ybWF0OiBhbnkpOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGdpdmVuIG51bWJlciBvZiB5ZWFycyB0byB0aGUgZGF0ZS4gWWVhcnMgYXJlIGNvdW50ZWQgYXMgaWYgZmxpcHBpbmcgMTIgcGFnZXMgb24gdGhlXG4gICAqIGNhbGVuZGFyIGZvciBlYWNoIHllYXIgYW5kIHRoZW4gZmluZGluZyB0aGUgY2xvc2VzdCBkYXRlIGluIHRoZSBuZXcgbW9udGguIEZvciBleGFtcGxlIHdoZW5cbiAgICogYWRkaW5nIDEgeWVhciB0byBGZWIgMjksIDIwMTYsIHRoZSByZXN1bHRpbmcgZGF0ZSB3aWxsIGJlIEZlYiAyOCwgMjAxNy5cbiAgICogQHBhcmFtIGRhdGUgVGhlIGRhdGUgdG8gYWRkIHllYXJzIHRvLlxuICAgKiBAcGFyYW0geWVhcnMgVGhlIG51bWJlciBvZiB5ZWFycyB0byBhZGQgKG1heSBiZSBuZWdhdGl2ZSkuXG4gICAqIEByZXR1cm5zIEEgbmV3IGRhdGUgZXF1YWwgdG8gdGhlIGdpdmVuIG9uZSB3aXRoIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHllYXJzIGFkZGVkLlxuICAgKi9cbiAgYWJzdHJhY3QgYWRkQ2FsZW5kYXJZZWFycyhkYXRlOiBELCB5ZWFyczogbnVtYmVyKTogRDtcblxuICAvKipcbiAgICogQWRkcyB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1vbnRocyB0byB0aGUgZGF0ZS4gTW9udGhzIGFyZSBjb3VudGVkIGFzIGlmIGZsaXBwaW5nIGEgcGFnZSBvbiB0aGVcbiAgICogY2FsZW5kYXIgZm9yIGVhY2ggbW9udGggYW5kIHRoZW4gZmluZGluZyB0aGUgY2xvc2VzdCBkYXRlIGluIHRoZSBuZXcgbW9udGguIEZvciBleGFtcGxlIHdoZW5cbiAgICogYWRkaW5nIDEgbW9udGggdG8gSmFuIDMxLCAyMDE3LCB0aGUgcmVzdWx0aW5nIGRhdGUgd2lsbCBiZSBGZWIgMjgsIDIwMTcuXG4gICAqIEBwYXJhbSBkYXRlIFRoZSBkYXRlIHRvIGFkZCBtb250aHMgdG8uXG4gICAqIEBwYXJhbSBtb250aHMgVGhlIG51bWJlciBvZiBtb250aHMgdG8gYWRkIChtYXkgYmUgbmVnYXRpdmUpLlxuICAgKiBAcmV0dXJucyBBIG5ldyBkYXRlIGVxdWFsIHRvIHRoZSBnaXZlbiBvbmUgd2l0aCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtb250aHMgYWRkZWQuXG4gICAqL1xuICBhYnN0cmFjdCBhZGRDYWxlbmRhck1vbnRocyhkYXRlOiBELCBtb250aHM6IG51bWJlcik6IEQ7XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGdpdmVuIG51bWJlciBvZiBkYXlzIHRvIHRoZSBkYXRlLiBEYXlzIGFyZSBjb3VudGVkIGFzIGlmIG1vdmluZyBvbmUgY2VsbCBvbiB0aGVcbiAgICogY2FsZW5kYXIgZm9yIGVhY2ggZGF5LlxuICAgKiBAcGFyYW0gZGF0ZSBUaGUgZGF0ZSB0byBhZGQgZGF5cyB0by5cbiAgICogQHBhcmFtIGRheXMgVGhlIG51bWJlciBvZiBkYXlzIHRvIGFkZCAobWF5IGJlIG5lZ2F0aXZlKS5cbiAgICogQHJldHVybnMgQSBuZXcgZGF0ZSBlcXVhbCB0byB0aGUgZ2l2ZW4gb25lIHdpdGggdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgZGF5cyBhZGRlZC5cbiAgICovXG4gIGFic3RyYWN0IGFkZENhbGVuZGFyRGF5cyhkYXRlOiBELCBkYXlzOiBudW1iZXIpOiBEO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBSRkMgMzMzOSBjb21wYXRpYmxlIHN0cmluZyAoaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkpIGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBnZW5lcmF0ZSBkYXRlIHN0cmluZ3MgdGhhdCBhcmUgY29tcGF0aWJsZSB3aXRoIG5hdGl2ZSBIVE1MIGF0dHJpYnV0ZXNcbiAgICogc3VjaCBhcyB0aGUgYG1pbmAgb3IgYG1heGAgYXR0cmlidXRlIG9mIGFuIGA8aW5wdXQ+YC5cbiAgICogQHBhcmFtIGRhdGUgVGhlIGRhdGUgdG8gZ2V0IHRoZSBJU08gZGF0ZSBzdHJpbmcgZm9yLlxuICAgKiBAcmV0dXJucyBUaGUgSVNPIGRhdGUgc3RyaW5nIGRhdGUgc3RyaW5nLlxuICAgKi9cbiAgYWJzdHJhY3QgdG9Jc284NjAxKGRhdGU6IEQpOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgY29uc2lkZXJlZCBhIGRhdGUgaW5zdGFuY2UgYnkgdGhpcyBEYXRlQWRhcHRlci5cbiAgICogQHBhcmFtIG9iaiBUaGUgb2JqZWN0IHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIG9iamVjdCBpcyBhIGRhdGUgaW5zdGFuY2UuXG4gICAqL1xuICBhYnN0cmFjdCBpc0RhdGVJbnN0YW5jZShvYmo6IGFueSk6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBkYXRlIGlzIHZhbGlkLlxuICAgKiBAcGFyYW0gZGF0ZSBUaGUgZGF0ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMgV2hldGhlciB0aGUgZGF0ZSBpcyB2YWxpZC5cbiAgICovXG4gIGFic3RyYWN0IGlzVmFsaWQoZGF0ZTogRCk6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEdldHMgZGF0ZSBpbnN0YW5jZSB0aGF0IGlzIG5vdCB2YWxpZC5cbiAgICogQHJldHVybnMgQW4gaW52YWxpZCBkYXRlLlxuICAgKi9cbiAgYWJzdHJhY3QgaW52YWxpZCgpOiBEO1xuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBkZXNlcmlhbGl6ZSBhIHZhbHVlIHRvIGEgdmFsaWQgZGF0ZSBvYmplY3QuIFRoaXMgaXMgZGlmZmVyZW50IGZyb20gcGFyc2luZyBpbiB0aGF0XG4gICAqIGRlc2VyaWFsaXplIHNob3VsZCBvbmx5IGFjY2VwdCBub24tYW1iaWd1b3VzLCBsb2NhbGUtaW5kZXBlbmRlbnQgZm9ybWF0cyAoZS5nLiBhIElTTyA4NjAxXG4gICAqIHN0cmluZykuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGRvZXMgbm90IGFsbG93IGFueSBkZXNlcmlhbGl6YXRpb24sIGl0IHNpbXBseSBjaGVja3MgdGhhdFxuICAgKiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYWxyZWFkeSBhIHZhbGlkIGRhdGUgb2JqZWN0IG9yIG51bGwuIFRoZSBgPHNhdC1kYXRlcGlja2VyPmAgd2lsbCBjYWxsIHRoaXNcbiAgICogbWV0aG9kIG9uIGFsbCBvZiBpdCdzIGBASW5wdXQoKWAgcHJvcGVydGllcyB0aGF0IGFjY2VwdCBkYXRlcy4gSXQgaXMgdGhlcmVmb3JlIHBvc3NpYmxlIHRvXG4gICAqIHN1cHBvcnQgcGFzc2luZyB2YWx1ZXMgZnJvbSB5b3VyIGJhY2tlbmQgZGlyZWN0bHkgdG8gdGhlc2UgcHJvcGVydGllcyBieSBvdmVycmlkaW5nIHRoaXMgbWV0aG9kXG4gICAqIHRvIGFsc28gZGVzZXJpYWxpemUgdGhlIGZvcm1hdCB1c2VkIGJ5IHlvdXIgYmFja2VuZC5cbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBkZXNlcmlhbGl6ZWQgaW50byBhIGRhdGUgb2JqZWN0LlxuICAgKiBAcmV0dXJucyBUaGUgZGVzZXJpYWxpemVkIGRhdGUgb2JqZWN0LCBlaXRoZXIgYSB2YWxpZCBkYXRlLCBudWxsIGlmIHRoZSB2YWx1ZSBjYW4gYmVcbiAgICogICAgIGRlc2VyaWFsaXplZCBpbnRvIGEgbnVsbCBkYXRlIChlLmcuIHRoZSBlbXB0eSBzdHJpbmcpLCBvciBhbiBpbnZhbGlkIGRhdGUuXG4gICAqL1xuICBkZXNlcmlhbGl6ZSh2YWx1ZTogYW55KTogRCB8IG51bGwge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHRoaXMuaXNEYXRlSW5zdGFuY2UodmFsdWUpICYmIHRoaXMuaXNWYWxpZCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGxvY2FsZSB1c2VkIGZvciBhbGwgZGF0ZXMuXG4gICAqIEBwYXJhbSBsb2NhbGUgVGhlIG5ldyBsb2NhbGUuXG4gICAqL1xuICBzZXRMb2NhbGUobG9jYWxlOiBhbnkpIHtcbiAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcbiAgICB0aGlzLl9sb2NhbGVDaGFuZ2VzLm5leHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJlcyB0d28gZGF0ZXMuXG4gICAqIEBwYXJhbSBmaXJzdCBUaGUgZmlyc3QgZGF0ZSB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0gc2Vjb25kIFRoZSBzZWNvbmQgZGF0ZSB0byBjb21wYXJlLlxuICAgKiBAcmV0dXJucyAwIGlmIHRoZSBkYXRlcyBhcmUgZXF1YWwsIGEgbnVtYmVyIGxlc3MgdGhhbiAwIGlmIHRoZSBmaXJzdCBkYXRlIGlzIGVhcmxpZXIsXG4gICAqICAgICBhIG51bWJlciBncmVhdGVyIHRoYW4gMCBpZiB0aGUgZmlyc3QgZGF0ZSBpcyBsYXRlci5cbiAgICovXG4gIGNvbXBhcmVEYXRlKGZpcnN0OiBELCBzZWNvbmQ6IEQpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdldFllYXIoZmlyc3QpIC0gdGhpcy5nZXRZZWFyKHNlY29uZCkgfHxcbiAgICAgICAgdGhpcy5nZXRNb250aChmaXJzdCkgLSB0aGlzLmdldE1vbnRoKHNlY29uZCkgfHxcbiAgICAgICAgdGhpcy5nZXREYXRlKGZpcnN0KSAtIHRoaXMuZ2V0RGF0ZShzZWNvbmQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0d28gZGF0ZXMgYXJlIGVxdWFsLlxuICAgKiBAcGFyYW0gZmlyc3QgVGhlIGZpcnN0IGRhdGUgdG8gY2hlY2suXG4gICAqIEBwYXJhbSBzZWNvbmQgVGhlIHNlY29uZCBkYXRlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB0d28gZGF0ZXMgYXJlIGVxdWFsLlxuICAgKiAgICAgTnVsbCBkYXRlcyBhcmUgY29uc2lkZXJlZCBlcXVhbCB0byBvdGhlciBudWxsIGRhdGVzLlxuICAgKi9cbiAgc2FtZURhdGUoZmlyc3Q6IEQgfCBudWxsLCBzZWNvbmQ6IEQgfCBudWxsKTogYm9vbGVhbiB7XG4gICAgaWYgKGZpcnN0ICYmIHNlY29uZCkge1xuICAgICAgbGV0IGZpcnN0VmFsaWQgPSB0aGlzLmlzVmFsaWQoZmlyc3QpO1xuICAgICAgbGV0IHNlY29uZFZhbGlkID0gdGhpcy5pc1ZhbGlkKHNlY29uZCk7XG4gICAgICBpZiAoZmlyc3RWYWxpZCAmJiBzZWNvbmRWYWxpZCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY29tcGFyZURhdGUoZmlyc3QsIHNlY29uZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmlyc3RWYWxpZCA9PSBzZWNvbmRWYWxpZDtcbiAgICB9XG4gICAgcmV0dXJuIGZpcnN0ID09IHNlY29uZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGFtcCB0aGUgZ2l2ZW4gZGF0ZSBiZXR3ZWVuIG1pbiBhbmQgbWF4IGRhdGVzLlxuICAgKiBAcGFyYW0gZGF0ZSBUaGUgZGF0ZSB0byBjbGFtcC5cbiAgICogQHBhcmFtIG1pbiBUaGUgbWluaW11bSB2YWx1ZSB0byBhbGxvdy4gSWYgbnVsbCBvciBvbWl0dGVkIG5vIG1pbiBpcyBlbmZvcmNlZC5cbiAgICogQHBhcmFtIG1heCBUaGUgbWF4aW11bSB2YWx1ZSB0byBhbGxvdy4gSWYgbnVsbCBvciBvbWl0dGVkIG5vIG1heCBpcyBlbmZvcmNlZC5cbiAgICogQHJldHVybnMgYG1pbmAgaWYgYGRhdGVgIGlzIGxlc3MgdGhhbiBgbWluYCwgYG1heGAgaWYgZGF0ZSBpcyBncmVhdGVyIHRoYW4gYG1heGAsXG4gICAqICAgICBvdGhlcndpc2UgYGRhdGVgLlxuICAgKi9cbiAgY2xhbXBEYXRlKGRhdGU6IEQsIG1pbj86IEQgfCBudWxsLCBtYXg/OiBEIHwgbnVsbCk6IEQge1xuICAgIGlmIChtaW4gJiYgdGhpcy5jb21wYXJlRGF0ZShkYXRlLCBtaW4pIDwgMCkge1xuICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgaWYgKG1heCAmJiB0aGlzLmNvbXBhcmVEYXRlKGRhdGUsIG1heCkgPiAwKSB7XG4gICAgICByZXR1cm4gbWF4O1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCB7SW5qZWN0aW9uVG9rZW59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5cbmV4cG9ydCB0eXBlIE1hdERhdGVGb3JtYXRzID0ge1xuICBwYXJzZToge1xuICAgIGRhdGVJbnB1dDogYW55XG4gIH0sXG4gIGRpc3BsYXk6IHtcbiAgICBkYXRlSW5wdXQ6IGFueSxcbiAgICBtb250aFllYXJMYWJlbDogYW55LFxuICAgIGRhdGVBMTF5TGFiZWw6IGFueSxcbiAgICBtb250aFllYXJBMTF5TGFiZWw6IGFueSxcbiAgfVxufTtcblxuXG5leHBvcnQgY29uc3QgTUFUX0RBVEVfRk9STUFUUyA9IG5ldyBJbmplY3Rpb25Ub2tlbjxNYXREYXRlRm9ybWF0cz4oJ21hdC1kYXRlLWZvcm1hdHMnKTtcbiIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIGlmIChlLmluZGV4T2YocFtpXSkgPCAwKVxyXG4gICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7ICB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpZiAob1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgcmVzdWx0LmRlZmF1bHQgPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtQbGF0Zm9ybX0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BsYXRmb3JtJztcbmltcG9ydCB7SW5qZWN0LCBJbmplY3RhYmxlLCBPcHRpb25hbH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0RhdGVBZGFwdGVyLCBNQVRfREFURV9MT0NBTEV9IGZyb20gJy4vZGF0ZS1hZGFwdGVyJztcblxuLy8gVE9ETyhtbWFsZXJiYSk6IFJlbW92ZSB3aGVuIHdlIG5vIGxvbmdlciBzdXBwb3J0IHNhZmFyaSA5LlxuLyoqIFdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIEludGwgQVBJLiAqL1xuY29uc3QgU1VQUE9SVFNfSU5UTF9BUEkgPSB0eXBlb2YgSW50bCAhPSAndW5kZWZpbmVkJztcblxuXG4vKiogVGhlIGRlZmF1bHQgbW9udGggbmFtZXMgdG8gdXNlIGlmIEludGwgQVBJIGlzIG5vdCBhdmFpbGFibGUuICovXG5jb25zdCBERUZBVUxUX01PTlRIX05BTUVTID0ge1xuICAnbG9uZyc6IFtcbiAgICAnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsICdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLFxuICAgICdPY3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJ1xuICBdLFxuICAnc2hvcnQnOiBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ10sXG4gICduYXJyb3cnOiBbJ0onLCAnRicsICdNJywgJ0EnLCAnTScsICdKJywgJ0onLCAnQScsICdTJywgJ08nLCAnTicsICdEJ11cbn07XG5cblxuLyoqIFRoZSBkZWZhdWx0IGRhdGUgbmFtZXMgdG8gdXNlIGlmIEludGwgQVBJIGlzIG5vdCBhdmFpbGFibGUuICovXG5jb25zdCBERUZBVUxUX0RBVEVfTkFNRVMgPSByYW5nZSgzMSwgaSA9PiBTdHJpbmcoaSArIDEpKTtcblxuXG4vKiogVGhlIGRlZmF1bHQgZGF5IG9mIHRoZSB3ZWVrIG5hbWVzIHRvIHVzZSBpZiBJbnRsIEFQSSBpcyBub3QgYXZhaWxhYmxlLiAqL1xuY29uc3QgREVGQVVMVF9EQVlfT0ZfV0VFS19OQU1FUyA9IHtcbiAgJ2xvbmcnOiBbJ1N1bmRheScsICdNb25kYXknLCAnVHVlc2RheScsICdXZWRuZXNkYXknLCAnVGh1cnNkYXknLCAnRnJpZGF5JywgJ1NhdHVyZGF5J10sXG4gICdzaG9ydCc6IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J10sXG4gICduYXJyb3cnOiBbJ1MnLCAnTScsICdUJywgJ1cnLCAnVCcsICdGJywgJ1MnXVxufTtcblxuLyoqIEZpcnN0IGRheSBvZiB3ZWVrIGFjY29yZGluZyBsb2NhbGUuXG4gKiBUYWtlbiBmb3JtIG1vbWVudC5qcyBzb3VyY2UgY29kZSBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC90cmVlL2RldmVsb3Avc3JjL2xvY2FsZVxuICovXG5jb25zdCBGSVJTVF9EQVlfT0ZfV0VFSyA9IHtcbiAgYWY6MSwgYXI6NiwgJ2FyLWx5Jzo2LCAnYXItbWEnOjYsICdhci10bic6MSwgYXo6MSwgYmU6MSwgYmc6MSwgYm06MSwgYnI6MSwgYnM6MSwgY2E6MSwgY3M6MSwgY3Y6MSxcbiAgY3k6MSwgZGE6MSwgZGU6MSwgJ2RlLWF0JzoxLCAnZGUtY2gnOjEsIGVsOjEsICdlbi1hdSc6MSwgJ2VuLWdiJzoxLCAnZW4taWUnOjEsICdlbi1ueic6MSwgZW86MSxcbiAgZXM6MSwgJ2VzLWRvJzoxLCBldDoxLCBldToxLCBmYTo2LCBmaToxLCBmbzoxLCBmcjoxLCAnZnItY2gnOjEsIGZ5OjEsIGdkOjEsIGdsOjEsICdnb20tbGF0bic6MSxcbiAgaHI6MSwgaHU6MSwgJ2h5LWFtJzoxLCBpZDoxLCBpczoxLCBpdDoxLCBqdjoxLCBrYToxLCBrazoxLCBrbToxLCBreToxLCBsYjoxLCBsdDoxLCBsdjoxLCBtZToxLFxuICBtaToxLCBtazoxLCBtczoxLCAnbXMtbXknOjEsIG10OjEsIG15OjEsIG5iOjEsIG5sOjEsICdubC1iZSc6MSwgbm46MSwgcGw6MSwgcHQ6MSwgJ3B0LUJSJzogMCwgcm86MSwgcnU6MSxcbiAgc2Q6MSwgc2U6MSwgc2s6MSwgc2w6MSwgc3E6MSwgc3I6MSwgJ3NyLWN5cmwnOjEsIHNzOjEsIHN2OjEsIHN3OjEsICd0ZXQnOjEsIHRnOjEsICd0bC1waCc6MSxcbiAgJ3RsaCc6MSwgdHI6MSwgJ3R6bCc6MSwgJ3R6bSc6NiwgJ3R6bS1sYXRuJzo2LCAndWctY24nOjEsIHVrOjEsIHVyOjEsIHV6OjEsICd1ei1sYXRuJzoxLCB2aToxLFxuICAneC1wc2V1ZG8nOjEsIHlvOjEsICd6aC1jbic6MSxcbn07XG5cbi8qKlxuICogTWF0Y2hlcyBzdHJpbmdzIHRoYXQgaGF2ZSB0aGUgZm9ybSBvZiBhIHZhbGlkIFJGQyAzMzM5IHN0cmluZ1xuICogKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5KS4gTm90ZSB0aGF0IHRoZSBzdHJpbmcgbWF5IG5vdCBhY3R1YWxseSBiZSBhIHZhbGlkIGRhdGVcbiAqIGJlY2F1c2UgdGhlIHJlZ2V4IHdpbGwgbWF0Y2ggc3RyaW5ncyBhbiB3aXRoIG91dCBvZiBib3VuZHMgbW9udGgsIGRhdGUsIGV0Yy5cbiAqL1xuY29uc3QgSVNPXzg2MDFfUkVHRVggPVxuICAgIC9eXFxkezR9LVxcZHsyfS1cXGR7Mn0oPzpUXFxkezJ9OlxcZHsyfTpcXGR7Mn0oPzpcXC5cXGQrKT8oPzpafCg/Oig/OlxcK3wtKVxcZHsyfTpcXGR7Mn0pKT8pPyQvO1xuXG5cbi8qKiBDcmVhdGVzIGFuIGFycmF5IGFuZCBmaWxscyBpdCB3aXRoIHZhbHVlcy4gKi9cbmZ1bmN0aW9uIHJhbmdlPFQ+KGxlbmd0aDogbnVtYmVyLCB2YWx1ZUZ1bmN0aW9uOiAoaW5kZXg6IG51bWJlcikgPT4gVCk6IFRbXSB7XG4gIGNvbnN0IHZhbHVlc0FycmF5ID0gQXJyYXkobGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhbHVlc0FycmF5W2ldID0gdmFsdWVGdW5jdGlvbihpKTtcbiAgfVxuICByZXR1cm4gdmFsdWVzQXJyYXk7XG59XG5cbi8qKiBBZGFwdHMgdGhlIG5hdGl2ZSBKUyBEYXRlIGZvciB1c2Ugd2l0aCBjZGstYmFzZWQgY29tcG9uZW50cyB0aGF0IHdvcmsgd2l0aCBkYXRlcy4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBOYXRpdmVEYXRlQWRhcHRlciBleHRlbmRzIERhdGVBZGFwdGVyPERhdGU+IHtcbiAgLyoqIFdoZXRoZXIgdG8gY2xhbXAgdGhlIGRhdGUgYmV0d2VlbiAxIGFuZCA5OTk5IHRvIGF2b2lkIElFIGFuZCBFZGdlIGVycm9ycy4gKi9cbiAgcHJpdmF0ZSByZWFkb25seSBfY2xhbXBEYXRlOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHVzZSBgdGltZVpvbmU6ICd1dGMnYCB3aXRoIGBJbnRsLkRhdGVUaW1lRm9ybWF0YCB3aGVuIGZvcm1hdHRpbmcgZGF0ZXMuXG4gICAqIFdpdGhvdXQgdGhpcyBgSW50bC5EYXRlVGltZUZvcm1hdGAgc29tZXRpbWVzIGNob29zZXMgdGhlIHdyb25nIHRpbWVab25lLCB3aGljaCBjYW4gdGhyb3cgb2ZmXG4gICAqIHRoZSByZXN1bHQuIChlLmcuIGluIHRoZSBlbi1VUyBsb2NhbGUgYG5ldyBEYXRlKDE4MDAsIDcsIDE0KS50b0xvY2FsZURhdGVTdHJpbmcoKWBcbiAgICogd2lsbCBwcm9kdWNlIGAnOC8xMy8xODAwJ2AuXG4gICAqXG4gICAqIFRPRE8obW1hbGVyYmEpOiBkcm9wIHRoaXMgdmFyaWFibGUuIEl0J3Mgbm90IGJlaW5nIHVzZWQgaW4gdGhlIGNvZGUgcmlnaHQgbm93LiBXZSdyZSBub3dcbiAgICogZ2V0dGluZyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgRGF0ZSBvYmplY3QgZnJvbSBpdCdzIHV0YyByZXByZXNlbnRhdGlvbi4gV2UncmUga2VlcGluZ1xuICAgKiBpdCBoZXJlIGZvciBzb21ldGltZSwganVzdCBmb3IgcHJlY2F1dGlvbiwgaW4gY2FzZSB3ZSBkZWNpZGUgdG8gcmV2ZXJ0IHNvbWUgb2YgdGhlc2UgY2hhbmdlc1xuICAgKiB0aG91Z2guXG4gICAqL1xuICB1c2VVdGNGb3JEaXNwbGF5OiBib29sZWFuID0gdHJ1ZTtcblxuICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBASW5qZWN0KE1BVF9EQVRFX0xPQ0FMRSkgbWF0RGF0ZUxvY2FsZTogc3RyaW5nLCBwbGF0Zm9ybTogUGxhdGZvcm0pIHtcbiAgICBzdXBlcigpO1xuICAgIHN1cGVyLnNldExvY2FsZShtYXREYXRlTG9jYWxlKTtcblxuICAgIC8vIElFIGRvZXMgaXRzIG93biB0aW1lIHpvbmUgY29ycmVjdGlvbiwgc28gd2UgZGlzYWJsZSB0aGlzIG9uIElFLlxuICAgIHRoaXMudXNlVXRjRm9yRGlzcGxheSA9ICFwbGF0Zm9ybS5UUklERU5UO1xuICAgIHRoaXMuX2NsYW1wRGF0ZSA9IHBsYXRmb3JtLlRSSURFTlQgfHwgcGxhdGZvcm0uRURHRTtcbiAgfVxuXG4gIGdldFllYXIoZGF0ZTogRGF0ZSk6IG51bWJlciB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgfVxuXG4gIGdldE1vbnRoKGRhdGU6IERhdGUpOiBudW1iZXIge1xuICAgIHJldHVybiBkYXRlLmdldE1vbnRoKCk7XG4gIH1cblxuICBnZXREYXRlKGRhdGU6IERhdGUpOiBudW1iZXIge1xuICAgIHJldHVybiBkYXRlLmdldERhdGUoKTtcbiAgfVxuXG4gIGdldERheU9mV2VlayhkYXRlOiBEYXRlKTogbnVtYmVyIHtcbiAgICByZXR1cm4gZGF0ZS5nZXREYXkoKTtcbiAgfVxuXG4gIGdldE1vbnRoTmFtZXMoc3R5bGU6ICdsb25nJyB8ICdzaG9ydCcgfCAnbmFycm93Jyk6IHN0cmluZ1tdIHtcbiAgICBpZiAoU1VQUE9SVFNfSU5UTF9BUEkpIHtcbiAgICAgIGNvbnN0IGR0ZiA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHRoaXMubG9jYWxlLCB7bW9udGg6IHN0eWxlLCB0aW1lWm9uZTogJ3V0Yyd9KTtcbiAgICAgIHJldHVybiByYW5nZSgxMiwgaSA9PlxuICAgICAgICAgIHRoaXMuX3N0cmlwRGlyZWN0aW9uYWxpdHlDaGFyYWN0ZXJzKHRoaXMuX2Zvcm1hdChkdGYsIG5ldyBEYXRlKDIwMTcsIGksIDEpKSkpO1xuICAgIH1cbiAgICByZXR1cm4gREVGQVVMVF9NT05USF9OQU1FU1tzdHlsZV07XG4gIH1cblxuICBnZXREYXRlTmFtZXMoKTogc3RyaW5nW10ge1xuICAgIGlmIChTVVBQT1JUU19JTlRMX0FQSSkge1xuICAgICAgY29uc3QgZHRmID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQodGhpcy5sb2NhbGUsIHtkYXk6ICdudW1lcmljJywgdGltZVpvbmU6ICd1dGMnfSk7XG4gICAgICByZXR1cm4gcmFuZ2UoMzEsIGkgPT4gdGhpcy5fc3RyaXBEaXJlY3Rpb25hbGl0eUNoYXJhY3RlcnMoXG4gICAgICAgICAgdGhpcy5fZm9ybWF0KGR0ZiwgbmV3IERhdGUoMjAxNywgMCwgaSArIDEpKSkpO1xuICAgIH1cbiAgICByZXR1cm4gREVGQVVMVF9EQVRFX05BTUVTO1xuICB9XG5cbiAgZ2V0RGF5T2ZXZWVrTmFtZXMoc3R5bGU6ICdsb25nJyB8ICdzaG9ydCcgfCAnbmFycm93Jyk6IHN0cmluZ1tdIHtcbiAgICBpZiAoU1VQUE9SVFNfSU5UTF9BUEkpIHtcbiAgICAgIGNvbnN0IGR0ZiA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHRoaXMubG9jYWxlLCB7d2Vla2RheTogc3R5bGUsIHRpbWVab25lOiAndXRjJ30pO1xuICAgICAgcmV0dXJuIHJhbmdlKDcsIGkgPT4gdGhpcy5fc3RyaXBEaXJlY3Rpb25hbGl0eUNoYXJhY3RlcnMoXG4gICAgICAgICAgdGhpcy5fZm9ybWF0KGR0ZiwgbmV3IERhdGUoMjAxNywgMCwgaSArIDEpKSkpO1xuICAgIH1cbiAgICByZXR1cm4gREVGQVVMVF9EQVlfT0ZfV0VFS19OQU1FU1tzdHlsZV07XG4gIH1cblxuICBnZXRZZWFyTmFtZShkYXRlOiBEYXRlKTogc3RyaW5nIHtcbiAgICBpZiAoU1VQUE9SVFNfSU5UTF9BUEkpIHtcbiAgICAgIGNvbnN0IGR0ZiA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHRoaXMubG9jYWxlLCB7eWVhcjogJ251bWVyaWMnLCB0aW1lWm9uZTogJ3V0Yyd9KTtcbiAgICAgIHJldHVybiB0aGlzLl9zdHJpcERpcmVjdGlvbmFsaXR5Q2hhcmFjdGVycyh0aGlzLl9mb3JtYXQoZHRmLCBkYXRlKSk7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcodGhpcy5nZXRZZWFyKGRhdGUpKTtcbiAgfVxuXG4gIGdldEZpcnN0RGF5T2ZXZWVrKCk6IG51bWJlciB7XG4gICAgLy8gV2UgY2FuJ3QgdGVsbCB1c2luZyBuYXRpdmUgSlMgRGF0ZSB3aGF0IHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsgaXMuXG4gICAgLy8gU29tZXRpbWVzIHBlb3BsZSB1c2UgZXhjZXNzIGxhbmd1YWdlIGRlZmluaXRpb24sIGUuZy4gcnUtUlUsXG4gICAgLy8gc28gd2UgdXNlIGZhbGxiYWNrIHRvIHR3by1sZXR0ZXIgbGFuZ3VhZ2UgY29kZVxuICAgIGNvbnN0IGxvY2FsZSA9IHRoaXMubG9jYWxlLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIEZJUlNUX0RBWV9PRl9XRUVLW2xvY2FsZV0gfHwgRklSU1RfREFZX09GX1dFRUtbbG9jYWxlLnN1YnN0cigwLCAyKV0gfHwgMDtcbiAgfVxuXG4gIGdldE51bURheXNJbk1vbnRoKGRhdGU6IERhdGUpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdldERhdGUodGhpcy5fY3JlYXRlRGF0ZVdpdGhPdmVyZmxvdyhcbiAgICAgICAgdGhpcy5nZXRZZWFyKGRhdGUpLCB0aGlzLmdldE1vbnRoKGRhdGUpICsgMSwgMCkpO1xuICB9XG5cbiAgY2xvbmUoZGF0ZTogRGF0ZSk6IERhdGUge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZURhdGUodGhpcy5nZXRZZWFyKGRhdGUpLCB0aGlzLmdldE1vbnRoKGRhdGUpLCB0aGlzLmdldERhdGUoZGF0ZSkpO1xuICB9XG5cbiAgY3JlYXRlRGF0ZSh5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIsIGRhdGU6IG51bWJlcik6IERhdGUge1xuICAgIC8vIENoZWNrIGZvciBpbnZhbGlkIG1vbnRoIGFuZCBkYXRlIChleGNlcHQgdXBwZXIgYm91bmQgb24gZGF0ZSB3aGljaCB3ZSBoYXZlIHRvIGNoZWNrIGFmdGVyXG4gICAgLy8gY3JlYXRpbmcgdGhlIERhdGUpLlxuICAgIGlmIChtb250aCA8IDAgfHwgbW9udGggPiAxMSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEludmFsaWQgbW9udGggaW5kZXggXCIke21vbnRofVwiLiBNb250aCBpbmRleCBoYXMgdG8gYmUgYmV0d2VlbiAwIGFuZCAxMS5gKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0ZSA8IDEpIHtcbiAgICAgIHRocm93IEVycm9yKGBJbnZhbGlkIGRhdGUgXCIke2RhdGV9XCIuIERhdGUgaGFzIHRvIGJlIGdyZWF0ZXIgdGhhbiAwLmApO1xuICAgIH1cblxuICAgIGxldCByZXN1bHQgPSB0aGlzLl9jcmVhdGVEYXRlV2l0aE92ZXJmbG93KHllYXIsIG1vbnRoLCBkYXRlKTtcbiAgICAvLyBDaGVjayB0aGF0IHRoZSBkYXRlIHdhc24ndCBhYm92ZSB0aGUgdXBwZXIgYm91bmQgZm9yIHRoZSBtb250aCwgY2F1c2luZyB0aGUgbW9udGggdG8gb3ZlcmZsb3dcbiAgICBpZiAocmVzdWx0LmdldE1vbnRoKCkgIT0gbW9udGgpIHtcbiAgICAgIHRocm93IEVycm9yKGBJbnZhbGlkIGRhdGUgXCIke2RhdGV9XCIgZm9yIG1vbnRoIHdpdGggaW5kZXggXCIke21vbnRofVwiLmApO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB0b2RheSgpOiBEYXRlIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKTtcbiAgfVxuXG4gIHBhcnNlKHZhbHVlOiBhbnkpOiBEYXRlIHwgbnVsbCB7XG4gICAgLy8gV2UgaGF2ZSBubyB3YXkgdXNpbmcgdGhlIG5hdGl2ZSBKUyBEYXRlIHRvIHNldCB0aGUgcGFyc2UgZm9ybWF0IG9yIGxvY2FsZSwgc28gd2UgaWdub3JlIHRoZXNlXG4gICAgLy8gcGFyYW1ldGVycy5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUgPyBuZXcgRGF0ZShEYXRlLnBhcnNlKHZhbHVlKSkgOiBudWxsO1xuICB9XG5cbiAgZm9ybWF0KGRhdGU6IERhdGUsIGRpc3BsYXlGb3JtYXQ6IE9iamVjdCk6IHN0cmluZyB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoZGF0ZSkpIHtcbiAgICAgIHRocm93IEVycm9yKCdOYXRpdmVEYXRlQWRhcHRlcjogQ2Fubm90IGZvcm1hdCBpbnZhbGlkIGRhdGUuJyk7XG4gICAgfVxuXG4gICAgaWYgKFNVUFBPUlRTX0lOVExfQVBJKSB7XG4gICAgICAvLyBPbiBJRSBhbmQgRWRnZSB0aGUgaTE4biBBUEkgd2lsbCB0aHJvdyBhIGhhcmQgZXJyb3IgdGhhdCBjYW4gY3Jhc2ggdGhlIGVudGlyZSBhcHBcbiAgICAgIC8vIGlmIHdlIGF0dGVtcHQgdG8gZm9ybWF0IGEgZGF0ZSB3aG9zZSB5ZWFyIGlzIGxlc3MgdGhhbiAxIG9yIGdyZWF0ZXIgdGhhbiA5OTk5LlxuICAgICAgaWYgKHRoaXMuX2NsYW1wRGF0ZSAmJiAoZGF0ZS5nZXRGdWxsWWVhcigpIDwgMSB8fCBkYXRlLmdldEZ1bGxZZWFyKCkgPiA5OTk5KSkge1xuICAgICAgICBkYXRlID0gdGhpcy5jbG9uZShkYXRlKTtcbiAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcihNYXRoLm1heCgxLCBNYXRoLm1pbig5OTk5LCBkYXRlLmdldEZ1bGxZZWFyKCkpKSk7XG4gICAgICB9XG5cbiAgICAgIGRpc3BsYXlGb3JtYXQgPSB7Li4uZGlzcGxheUZvcm1hdCwgdGltZVpvbmU6ICd1dGMnfTtcblxuICAgICAgY29uc3QgZHRmID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQodGhpcy5sb2NhbGUsIGRpc3BsYXlGb3JtYXQpO1xuICAgICAgcmV0dXJuIHRoaXMuX3N0cmlwRGlyZWN0aW9uYWxpdHlDaGFyYWN0ZXJzKHRoaXMuX2Zvcm1hdChkdGYsIGRhdGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwRGlyZWN0aW9uYWxpdHlDaGFyYWN0ZXJzKGRhdGUudG9EYXRlU3RyaW5nKCkpO1xuICB9XG5cbiAgYWRkQ2FsZW5kYXJZZWFycyhkYXRlOiBEYXRlLCB5ZWFyczogbnVtYmVyKTogRGF0ZSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkQ2FsZW5kYXJNb250aHMoZGF0ZSwgeWVhcnMgKiAxMik7XG4gIH1cblxuICBhZGRDYWxlbmRhck1vbnRocyhkYXRlOiBEYXRlLCBtb250aHM6IG51bWJlcik6IERhdGUge1xuICAgIGxldCBuZXdEYXRlID0gdGhpcy5fY3JlYXRlRGF0ZVdpdGhPdmVyZmxvdyhcbiAgICAgICAgdGhpcy5nZXRZZWFyKGRhdGUpLCB0aGlzLmdldE1vbnRoKGRhdGUpICsgbW9udGhzLCB0aGlzLmdldERhdGUoZGF0ZSkpO1xuXG4gICAgLy8gSXQncyBwb3NzaWJsZSB0byB3aW5kIHVwIGluIHRoZSB3cm9uZyBtb250aCBpZiB0aGUgb3JpZ2luYWwgbW9udGggaGFzIG1vcmUgZGF5cyB0aGFuIHRoZSBuZXdcbiAgICAvLyBtb250aC4gSW4gdGhpcyBjYXNlIHdlIHdhbnQgdG8gZ28gdG8gdGhlIGxhc3QgZGF5IG9mIHRoZSBkZXNpcmVkIG1vbnRoLlxuICAgIC8vIE5vdGU6IHRoZSBhZGRpdGlvbmFsICsgMTIgJSAxMiBlbnN1cmVzIHdlIGVuZCB1cCB3aXRoIGEgcG9zaXRpdmUgbnVtYmVyLCBzaW5jZSBKUyAlIGRvZXNuJ3RcbiAgICAvLyBndWFyYW50ZWUgdGhpcy5cbiAgICBpZiAodGhpcy5nZXRNb250aChuZXdEYXRlKSAhPSAoKHRoaXMuZ2V0TW9udGgoZGF0ZSkgKyBtb250aHMpICUgMTIgKyAxMikgJSAxMikge1xuICAgICAgbmV3RGF0ZSA9IHRoaXMuX2NyZWF0ZURhdGVXaXRoT3ZlcmZsb3codGhpcy5nZXRZZWFyKG5ld0RhdGUpLCB0aGlzLmdldE1vbnRoKG5ld0RhdGUpLCAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RGF0ZTtcbiAgfVxuXG4gIGFkZENhbGVuZGFyRGF5cyhkYXRlOiBEYXRlLCBkYXlzOiBudW1iZXIpOiBEYXRlIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRGF0ZVdpdGhPdmVyZmxvdyhcbiAgICAgICAgdGhpcy5nZXRZZWFyKGRhdGUpLCB0aGlzLmdldE1vbnRoKGRhdGUpLCB0aGlzLmdldERhdGUoZGF0ZSkgKyBkYXlzKTtcbiAgfVxuXG4gIHRvSXNvODYwMShkYXRlOiBEYXRlKTogc3RyaW5nIHtcbiAgICByZXR1cm4gW1xuICAgICAgZGF0ZS5nZXRVVENGdWxsWWVhcigpLFxuICAgICAgdGhpcy5fMmRpZ2l0KGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpLFxuICAgICAgdGhpcy5fMmRpZ2l0KGRhdGUuZ2V0VVRDRGF0ZSgpKVxuICAgIF0uam9pbignLScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGdpdmVuIHZhbHVlIGlmIGdpdmVuIGEgdmFsaWQgRGF0ZSBvciBudWxsLiBEZXNlcmlhbGl6ZXMgdmFsaWQgSVNPIDg2MDEgc3RyaW5nc1xuICAgKiAoaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzMzMzkudHh0KSBpbnRvIHZhbGlkIERhdGVzIGFuZCBlbXB0eSBzdHJpbmcgaW50byBudWxsLiBSZXR1cm5zIGFuXG4gICAqIGludmFsaWQgZGF0ZSBmb3IgYWxsIG90aGVyIHZhbHVlcy5cbiAgICovXG4gIGRlc2VyaWFsaXplKHZhbHVlOiBhbnkpOiBEYXRlIHwgbnVsbCB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICAvLyBUaGUgYERhdGVgIGNvbnN0cnVjdG9yIGFjY2VwdHMgZm9ybWF0cyBvdGhlciB0aGFuIElTTyA4NjAxLCBzbyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGVcbiAgICAgIC8vIHN0cmluZyBpcyB0aGUgcmlnaHQgZm9ybWF0IGZpcnN0LlxuICAgICAgaWYgKElTT184NjAxX1JFR0VYLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIGxldCBkYXRlID0gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKGRhdGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmRlc2VyaWFsaXplKHZhbHVlKTtcbiAgfVxuXG4gIGlzRGF0ZUluc3RhbmNlKG9iajogYW55KSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIERhdGU7XG4gIH1cblxuICBpc1ZhbGlkKGRhdGU6IERhdGUpIHtcbiAgICByZXR1cm4gIWlzTmFOKGRhdGUuZ2V0VGltZSgpKTtcbiAgfVxuXG4gIGludmFsaWQoKTogRGF0ZSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gIH1cblxuICAvKiogQ3JlYXRlcyBhIGRhdGUgYnV0IGFsbG93cyB0aGUgbW9udGggYW5kIGRhdGUgdG8gb3ZlcmZsb3cuICovXG4gIHByaXZhdGUgX2NyZWF0ZURhdGVXaXRoT3ZlcmZsb3coeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCBkYXRlOiBudW1iZXIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF0ZSk7XG5cbiAgICAvLyBXZSBuZWVkIHRvIGNvcnJlY3QgZm9yIHRoZSBmYWN0IHRoYXQgSlMgbmF0aXZlIERhdGUgdHJlYXRzIHllYXJzIGluIHJhbmdlIFswLCA5OV0gYXNcbiAgICAvLyBhYmJyZXZpYXRpb25zIGZvciAxOXh4LlxuICAgIGlmICh5ZWFyID49IDAgJiYgeWVhciA8IDEwMCkge1xuICAgICAgcmVzdWx0LnNldEZ1bGxZZWFyKHRoaXMuZ2V0WWVhcihyZXN1bHQpIC0gMTkwMCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUGFkcyBhIG51bWJlciB0byBtYWtlIGl0IHR3byBkaWdpdHMuXG4gICAqIEBwYXJhbSBuIFRoZSBudW1iZXIgdG8gcGFkLlxuICAgKiBAcmV0dXJucyBUaGUgcGFkZGVkIG51bWJlci5cbiAgICovXG4gIHByaXZhdGUgXzJkaWdpdChuOiBudW1iZXIpIHtcbiAgICByZXR1cm4gKCcwMCcgKyBuKS5zbGljZSgtMik7XG4gIH1cblxuICAvKipcbiAgICogU3RyaXAgb3V0IHVuaWNvZGUgTFRSIGFuZCBSVEwgY2hhcmFjdGVycy4gRWRnZSBhbmQgSUUgaW5zZXJ0IHRoZXNlIGludG8gZm9ybWF0dGVkIGRhdGVzIHdoaWxlXG4gICAqIG90aGVyIGJyb3dzZXJzIGRvIG5vdC4gV2UgcmVtb3ZlIHRoZW0gdG8gbWFrZSBvdXRwdXQgY29uc2lzdGVudCBhbmQgYmVjYXVzZSB0aGV5IGludGVyZmVyZSB3aXRoXG4gICAqIGRhdGUgcGFyc2luZy5cbiAgICogQHBhcmFtIHN0ciBUaGUgc3RyaW5nIHRvIHN0cmlwIGRpcmVjdGlvbiBjaGFyYWN0ZXJzIGZyb20uXG4gICAqIEByZXR1cm5zIFRoZSBzdHJpcHBlZCBzdHJpbmcuXG4gICAqL1xuICBwcml2YXRlIF9zdHJpcERpcmVjdGlvbmFsaXR5Q2hhcmFjdGVycyhzdHI6IHN0cmluZykge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvW1xcdTIwMGVcXHUyMDBmXS9nLCAnJyk7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiBjb252ZXJ0aW5nIERhdGUgb2JqZWN0IHRvIHN0cmluZywgamF2YXNjcmlwdCBidWlsdC1pbiBmdW5jdGlvbnMgbWF5IHJldHVybiB3cm9uZ1xuICAgKiByZXN1bHRzIGJlY2F1c2UgaXQgYXBwbGllcyBpdHMgaW50ZXJuYWwgRFNUIHJ1bGVzLiBUaGUgRFNUIHJ1bGVzIGFyb3VuZCB0aGUgd29ybGQgY2hhbmdlXG4gICAqIHZlcnkgZnJlcXVlbnRseSwgYW5kIHRoZSBjdXJyZW50IHZhbGlkIHJ1bGUgaXMgbm90IGFsd2F5cyB2YWxpZCBpbiBwcmV2aW91cyB5ZWFycyB0aG91Z2guXG4gICAqIFdlIHdvcmsgYXJvdW5kIHRoaXMgcHJvYmxlbSBidWlsZGluZyBhIG5ldyBEYXRlIG9iamVjdCB3aGljaCBoYXMgaXRzIGludGVybmFsIFVUQ1xuICAgKiByZXByZXNlbnRhdGlvbiB3aXRoIHRoZSBsb2NhbCBkYXRlIGFuZCB0aW1lLlxuICAgKiBAcGFyYW0gZHRmIEludGwuRGF0ZVRpbWVGb3JtYXQgb2JqZWN0LCBjb250YWluZyB0aGUgZGVzaXJlZCBzdHJpbmcgZm9ybWF0LiBJdCBtdXN0IGhhdmVcbiAgICogICAgdGltZVpvbmUgc2V0IHRvICd1dGMnIHRvIHdvcmsgZmluZS5cbiAgICogQHBhcmFtIGRhdGUgRGF0ZSBmcm9tIHdoaWNoIHdlIHdhbnQgdG8gZ2V0IHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gYWNjb3JkaW5nIHRvIGR0ZlxuICAgKiBAcmV0dXJucyBBIERhdGUgb2JqZWN0IHdpdGggaXRzIFVUQyByZXByZXNlbnRhdGlvbiBiYXNlZCBvbiB0aGUgcGFzc2VkIGluIGRhdGUgaW5mb1xuICAgKi9cbiAgcHJpdmF0ZSBfZm9ybWF0KGR0ZjogSW50bC5EYXRlVGltZUZvcm1hdCwgZGF0ZTogRGF0ZSkge1xuICAgIGNvbnN0IGQgPSBuZXcgRGF0ZShEYXRlLlVUQyhcbiAgICAgICAgZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpLCBkYXRlLmdldEhvdXJzKCksXG4gICAgICAgIGRhdGUuZ2V0TWludXRlcygpLCBkYXRlLmdldFNlY29uZHMoKSwgZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSkpO1xuICAgIHJldHVybiBkdGYuZm9ybWF0KGQpO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtNYXREYXRlRm9ybWF0c30gZnJvbSAnLi9kYXRlLWZvcm1hdHMnO1xuXG5cbmV4cG9ydCBjb25zdCBNQVRfTkFUSVZFX0RBVEVfRk9STUFUUzogTWF0RGF0ZUZvcm1hdHMgPSB7XG4gICAgcGFyc2U6IHtcbiAgICAgICAgZGF0ZUlucHV0OiBudWxsLFxuICAgIH0sXG4gICAgZGlzcGxheToge1xuICAgICAgICBkYXRlSW5wdXQ6IHt5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbnVtZXJpYycsIGRheTogJ251bWVyaWMnfSxcbiAgICAgICAgbW9udGhZZWFyTGFiZWw6IHt5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnc2hvcnQnfSxcbiAgICAgICAgZGF0ZUExMXlMYWJlbDoge3llYXI6ICdudW1lcmljJywgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYyd9LFxuICAgICAgICBtb250aFllYXJBMTF5TGFiZWw6IHt5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZyd9LFxuICAgIH1cbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtQbGF0Zm9ybU1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BsYXRmb3JtJztcbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtEYXRlQWRhcHRlcn0gZnJvbSAnLi9kYXRlLWFkYXB0ZXInO1xuaW1wb3J0IHtNQVRfREFURV9GT1JNQVRTfSBmcm9tICcuL2RhdGUtZm9ybWF0cyc7XG5pbXBvcnQge05hdGl2ZURhdGVBZGFwdGVyfSBmcm9tICcuL25hdGl2ZS1kYXRlLWFkYXB0ZXInO1xuaW1wb3J0IHtNQVRfTkFUSVZFX0RBVEVfRk9STUFUU30gZnJvbSAnLi9uYXRpdmUtZGF0ZS1mb3JtYXRzJztcblxuZXhwb3J0ICogZnJvbSAnLi9kYXRlLWFkYXB0ZXInO1xuZXhwb3J0ICogZnJvbSAnLi9kYXRlLWZvcm1hdHMnO1xuZXhwb3J0ICogZnJvbSAnLi9uYXRpdmUtZGF0ZS1hZGFwdGVyJztcbmV4cG9ydCAqIGZyb20gJy4vbmF0aXZlLWRhdGUtZm9ybWF0cyc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbUGxhdGZvcm1Nb2R1bGVdLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICB7cHJvdmlkZTogRGF0ZUFkYXB0ZXIsIHVzZUNsYXNzOiBOYXRpdmVEYXRlQWRhcHRlcn0sXG4gICAgXSxcbn0pXG5leHBvcnQgY2xhc3MgTmF0aXZlRGF0ZU1vZHVsZSB7fVxuXG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW05hdGl2ZURhdGVNb2R1bGVdLFxuICAgIHByb3ZpZGVyczogW3twcm92aWRlOiBNQVRfREFURV9GT1JNQVRTLCB1c2VWYWx1ZTogTUFUX05BVElWRV9EQVRFX0ZPUk1BVFN9XSxcbn0pXG5leHBvcnQgY2xhc3MgU2F0TmF0aXZlRGF0ZU1vZHVsZSB7fVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbi8qKiBAZG9jcy1wcml2YXRlICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWlzc2luZ0RhdGVJbXBsRXJyb3IocHJvdmlkZXI6IHN0cmluZykge1xuICAgIHJldHVybiBFcnJvcihcbiAgICAgICAgYFNhdERhdGVwaWNrZXI6IE5vIHByb3ZpZGVyIGZvdW5kIGZvciAke3Byb3ZpZGVyfS4gWW91IG11c3QgaW1wb3J0IG9uZSBvZiB0aGUgZm9sbG93aW5nIGAgK1xuICAgICAgICBgbW9kdWxlcyBhdCB5b3VyIGFwcGxpY2F0aW9uIHJvb3Q6IFNhdE5hdGl2ZURhdGVNb2R1bGUsIE1hdE1vbWVudERhdGVNb2R1bGUsIG9yIHByb3ZpZGUgYSBgICtcbiAgICAgICAgYGN1c3RvbSBpbXBsZW1lbnRhdGlvbi5gKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge0luamVjdGFibGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtTdWJqZWN0fSBmcm9tICdyeGpzJztcblxuXG4vKiogRGF0ZXBpY2tlciBkYXRhIHRoYXQgcmVxdWlyZXMgaW50ZXJuYXRpb25hbGl6YXRpb24uICovXG5ASW5qZWN0YWJsZSh7cHJvdmlkZWRJbjogJ3Jvb3QnfSlcbmV4cG9ydCBjbGFzcyBTYXREYXRlcGlja2VySW50bCB7XG4gIC8qKlxuICAgKiBTdHJlYW0gdGhhdCBlbWl0cyB3aGVuZXZlciB0aGUgbGFiZWxzIGhlcmUgYXJlIGNoYW5nZWQuIFVzZSB0aGlzIHRvIG5vdGlmeVxuICAgKiBjb21wb25lbnRzIGlmIHRoZSBsYWJlbHMgaGF2ZSBjaGFuZ2VkIGFmdGVyIGluaXRpYWxpemF0aW9uLlxuICAgKi9cbiAgcmVhZG9ubHkgY2hhbmdlczogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgLyoqIEEgbGFiZWwgZm9yIHRoZSBjYWxlbmRhciBwb3B1cCAodXNlZCBieSBzY3JlZW4gcmVhZGVycykuICovXG4gIGNhbGVuZGFyTGFiZWw6IHN0cmluZyA9ICdDYWxlbmRhcic7XG5cbiAgLyoqIEEgbGFiZWwgZm9yIHRoZSBidXR0b24gdXNlZCB0byBvcGVuIHRoZSBjYWxlbmRhciBwb3B1cCAodXNlZCBieSBzY3JlZW4gcmVhZGVycykuICovXG4gIG9wZW5DYWxlbmRhckxhYmVsOiBzdHJpbmcgPSAnT3BlbiBjYWxlbmRhcic7XG5cbiAgLyoqIEEgbGFiZWwgZm9yIHRoZSBwcmV2aW91cyBtb250aCBidXR0b24gKHVzZWQgYnkgc2NyZWVuIHJlYWRlcnMpLiAqL1xuICBwcmV2TW9udGhMYWJlbDogc3RyaW5nID0gJ1ByZXZpb3VzIG1vbnRoJztcblxuICAvKiogQSBsYWJlbCBmb3IgdGhlIG5leHQgbW9udGggYnV0dG9uICh1c2VkIGJ5IHNjcmVlbiByZWFkZXJzKS4gKi9cbiAgbmV4dE1vbnRoTGFiZWw6IHN0cmluZyA9ICdOZXh0IG1vbnRoJztcblxuICAvKiogQSBsYWJlbCBmb3IgdGhlIHByZXZpb3VzIHllYXIgYnV0dG9uICh1c2VkIGJ5IHNjcmVlbiByZWFkZXJzKS4gKi9cbiAgcHJldlllYXJMYWJlbDogc3RyaW5nID0gJ1ByZXZpb3VzIHllYXInO1xuXG4gIC8qKiBBIGxhYmVsIGZvciB0aGUgbmV4dCB5ZWFyIGJ1dHRvbiAodXNlZCBieSBzY3JlZW4gcmVhZGVycykuICovXG4gIG5leHRZZWFyTGFiZWw6IHN0cmluZyA9ICdOZXh0IHllYXInO1xuXG4gIC8qKiBBIGxhYmVsIGZvciB0aGUgcHJldmlvdXMgbXVsdGkteWVhciBidXR0b24gKHVzZWQgYnkgc2NyZWVuIHJlYWRlcnMpLiAqL1xuICBwcmV2TXVsdGlZZWFyTGFiZWw6IHN0cmluZyA9ICdQcmV2aW91cyAyMCB5ZWFycyc7XG5cbiAgLyoqIEEgbGFiZWwgZm9yIHRoZSBuZXh0IG11bHRpLXllYXIgYnV0dG9uICh1c2VkIGJ5IHNjcmVlbiByZWFkZXJzKS4gKi9cbiAgbmV4dE11bHRpWWVhckxhYmVsOiBzdHJpbmcgPSAnTmV4dCAyMCB5ZWFycyc7XG5cbiAgLyoqIEEgbGFiZWwgZm9yIHRoZSAnc3dpdGNoIHRvIG1vbnRoIHZpZXcnIGJ1dHRvbiAodXNlZCBieSBzY3JlZW4gcmVhZGVycykuICovXG4gIHN3aXRjaFRvTW9udGhWaWV3TGFiZWw6IHN0cmluZyA9ICdDaG9vc2UgZGF0ZSc7XG5cbiAgLyoqIEEgbGFiZWwgZm9yIHRoZSAnc3dpdGNoIHRvIHllYXIgdmlldycgYnV0dG9uICh1c2VkIGJ5IHNjcmVlbiByZWFkZXJzKS4gKi9cbiAgc3dpdGNoVG9NdWx0aVllYXJWaWV3TGFiZWw6IHN0cmluZyA9ICdDaG9vc2UgbW9udGggYW5kIHllYXInO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCB7XG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDb21wb25lbnQsXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIE91dHB1dCxcbiAgVmlld0VuY2Fwc3VsYXRpb24sXG4gIE5nWm9uZSxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge3Rha2V9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuLyoqXG4gKiBBbiBpbnRlcm5hbCBjbGFzcyB0aGF0IHJlcHJlc2VudHMgdGhlIGRhdGEgY29ycmVzcG9uZGluZyB0byBhIHNpbmdsZSBjYWxlbmRhciBjZWxsLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgU2F0Q2FsZW5kYXJDZWxsIHtcbiAgY29uc3RydWN0b3IocHVibGljIHZhbHVlOiBudW1iZXIsXG4gICAgICAgICAgICAgIHB1YmxpYyBkaXNwbGF5VmFsdWU6IHN0cmluZyxcbiAgICAgICAgICAgICAgcHVibGljIGFyaWFMYWJlbDogc3RyaW5nLFxuICAgICAgICAgICAgICBwdWJsaWMgZW5hYmxlZDogYm9vbGVhbikge31cbn1cblxuXG4vKipcbiAqIEFuIGludGVybmFsIGNvbXBvbmVudCB1c2VkIHRvIGRpc3BsYXkgY2FsZW5kYXIgZGF0YSBpbiBhIHRhYmxlLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5AQ29tcG9uZW50KHtcbiAgbW9kdWxlSWQ6IG1vZHVsZS5pZCxcbiAgc2VsZWN0b3I6ICdbc2F0LWNhbGVuZGFyLWJvZHldJyxcbiAgdGVtcGxhdGVVcmw6ICdjYWxlbmRhci1ib2R5Lmh0bWwnLFxuICBzdHlsZVVybHM6IFsnY2FsZW5kYXItYm9keS5jc3MnXSxcbiAgaG9zdDoge1xuICAgICdjbGFzcyc6ICdtYXQtY2FsZW5kYXItYm9keScsXG4gICAgJ3JvbGUnOiAnZ3JpZCcsXG4gICAgJ2F0dHIuYXJpYS1yZWFkb25seSc6ICd0cnVlJ1xuICB9LFxuICBleHBvcnRBczogJ21hdENhbGVuZGFyQm9keScsXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxufSlcbmV4cG9ydCBjbGFzcyBTYXRDYWxlbmRhckJvZHkge1xuICAvKiogVGhlIGxhYmVsIGZvciB0aGUgdGFibGUuIChlLmcuIFwiSmFuIDIwMTdcIikuICovXG4gIEBJbnB1dCgpIGxhYmVsOiBzdHJpbmc7XG5cbiAgLyoqIFRoZSBjZWxscyB0byBkaXNwbGF5IGluIHRoZSB0YWJsZS4gKi9cbiAgQElucHV0KCkgcm93czogU2F0Q2FsZW5kYXJDZWxsW11bXTtcblxuICAvKiogVGhlIHZhbHVlIGluIHRoZSB0YWJsZSB0aGF0IGNvcnJlc3BvbmRzIHRvIHRvZGF5LiAqL1xuICBASW5wdXQoKSB0b2RheVZhbHVlOiBudW1iZXI7XG5cbiAgLyoqIFRoZSB2YWx1ZSBpbiB0aGUgdGFibGUgdGhhdCBpcyBjdXJyZW50bHkgc2VsZWN0ZWQuICovXG4gIEBJbnB1dCgpIHNlbGVjdGVkVmFsdWU6IG51bWJlcjtcblxuICAvKiogVGhlIHZhbHVlIGluIHRoZSB0YWJsZSBzaW5jZSByYW5nZSBvZiBkYXRlcyBzdGFydGVkLlxuICAgKiBOdWxsIG1lYW5zIG5vIGludGVydmFsIG9yIGludGVydmFsIGRvZXNuJ3Qgc3RhcnQgaW4gdGhpcyBtb250aFxuICAgKi9cbiAgQElucHV0KCkgYmVnaW46IG51bWJlcnxudWxsO1xuXG4gIC8qKiBUaGUgdmFsdWUgaW4gdGhlIHRhYmxlIHJlcHJlc2VudGluZyBlbmQgb2YgZGF0ZXMgcmFuZ2UuXG4gICAqIE51bGwgbWVhbnMgbm8gaW50ZXJ2YWwgb3IgaW50ZXJ2YWwgZG9lc24ndCBlbmQgaW4gdGhpcyBtb250aFxuICAgKi9cbiAgQElucHV0KCkgZW5kOiBudW1iZXJ8bnVsbDtcblxuICAvKiogV2hldGhlciB0byBtYXJrIGFsbCBkYXRlcyBhcyBzZW1pLXNlbGVjdGVkLiAqL1xuICBASW5wdXQoKSByYW5nZUZ1bGw6IGJvb2xlYW47XG5cbiAgLyoqIFdoZXRoZXIgdG8gdXNlIGRhdGUgcmFuZ2Ugc2VsZWN0aW9uIGJlaGF2aW91ci4qL1xuICBASW5wdXQoKSByYW5nZU1vZGUgPSBmYWxzZTtcblxuICAvKiogVGhlIG1pbmltdW0gbnVtYmVyIG9mIGZyZWUgY2VsbHMgbmVlZGVkIHRvIGZpdCB0aGUgbGFiZWwgaW4gdGhlIGZpcnN0IHJvdy4gKi9cbiAgQElucHV0KCkgbGFiZWxNaW5SZXF1aXJlZENlbGxzOiBudW1iZXI7XG5cbiAgLyoqIFRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgdGFibGUuICovXG4gIEBJbnB1dCgpIG51bUNvbHMgPSA3O1xuXG4gIC8qKiBXaGV0aGVyIHRvIGFsbG93IHNlbGVjdGlvbiBvZiBkaXNhYmxlZCBjZWxscy4gKi9cbiAgQElucHV0KCkgYWxsb3dEaXNhYmxlZFNlbGVjdGlvbiA9IGZhbHNlO1xuXG4gIC8qKiBUaGUgY2VsbCBudW1iZXIgb2YgdGhlIGFjdGl2ZSBjZWxsIGluIHRoZSB0YWJsZS4gKi9cbiAgQElucHV0KCkgYWN0aXZlQ2VsbCA9IDA7XG5cbiAgLyoqXG4gICAqIFRoZSBhc3BlY3QgcmF0aW8gKHdpZHRoIC8gaGVpZ2h0KSB0byB1c2UgZm9yIHRoZSBjZWxscyBpbiB0aGUgdGFibGUuIFRoaXMgYXNwZWN0IHJhdGlvIHdpbGwgYmVcbiAgICogbWFpbnRhaW5lZCBldmVuIGFzIHRoZSB0YWJsZSByZXNpemVzLlxuICAgKi9cbiAgQElucHV0KCkgY2VsbEFzcGVjdFJhdGlvID0gMTtcblxuICAvKiogRW1pdHMgd2hlbiBhIG5ldyB2YWx1ZSBpcyBzZWxlY3RlZC4gKi9cbiAgQE91dHB1dCgpIHJlYWRvbmx5IHNlbGVjdGVkVmFsdWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxudW1iZXI+ID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJpdmF0ZSBfbmdab25lOiBOZ1pvbmUpIHsgfVxuXG4gIF9jZWxsQ2xpY2tlZChjZWxsOiBTYXRDYWxlbmRhckNlbGwpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuYWxsb3dEaXNhYmxlZFNlbGVjdGlvbiAmJiAhY2VsbC5lbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2VsZWN0ZWRWYWx1ZUNoYW5nZS5lbWl0KGNlbGwudmFsdWUpO1xuICB9XG5cbiAgLyoqIFRoZSBudW1iZXIgb2YgYmxhbmsgY2VsbHMgdG8gcHV0IGF0IHRoZSBiZWdpbm5pbmcgZm9yIHRoZSBmaXJzdCByb3cuICovXG4gIGdldCBfZmlyc3RSb3dPZmZzZXQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5yb3dzICYmIHRoaXMucm93cy5sZW5ndGggJiYgdGhpcy5yb3dzWzBdLmxlbmd0aCA/XG4gICAgICAgIHRoaXMubnVtQ29scyAtIHRoaXMucm93c1swXS5sZW5ndGggOiAwO1xuICB9XG5cbiAgX2lzQWN0aXZlQ2VsbChyb3dJbmRleDogbnVtYmVyLCBjb2xJbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgbGV0IGNlbGxOdW1iZXIgPSByb3dJbmRleCAqIHRoaXMubnVtQ29scyArIGNvbEluZGV4O1xuXG4gICAgLy8gQWNjb3VudCBmb3IgdGhlIGZhY3QgdGhhdCB0aGUgZmlyc3Qgcm93IG1heSBub3QgaGF2ZSBhcyBtYW55IGNlbGxzLlxuICAgIGlmIChyb3dJbmRleCkge1xuICAgICAgY2VsbE51bWJlciAtPSB0aGlzLl9maXJzdFJvd09mZnNldDtcbiAgICB9XG5cbiAgICByZXR1cm4gY2VsbE51bWJlciA9PSB0aGlzLmFjdGl2ZUNlbGw7XG4gIH1cblxuICAvKiogV2hlbmV2ZXIgdG8gbWFyayBjZWxsIGFzIHNlbWktc2VsZWN0ZWQgKGluc2lkZSBkYXRlcyBpbnRlcnZhbCkuICovXG4gIF9pc1NlbWlTZWxlY3RlZChkYXRlOiBudW1iZXIpIHtcbiAgICBpZiAoIXRoaXMucmFuZ2VNb2RlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLnJhbmdlRnVsbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKiBEbyBub3QgbWFyayBzdGFydCBhbmQgZW5kIG9mIGludGVydmFsLiAqL1xuICAgIGlmIChkYXRlID09PSB0aGlzLmJlZ2luIHx8IGRhdGUgPT09IHRoaXMuZW5kKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLmJlZ2luICYmICF0aGlzLmVuZCkge1xuICAgICAgcmV0dXJuIGRhdGUgPiB0aGlzLmJlZ2luO1xuICAgIH1cbiAgICBpZiAodGhpcy5lbmQgJiYgIXRoaXMuYmVnaW4pIHtcbiAgICAgIHJldHVybiBkYXRlIDwgdGhpcy5lbmQ7XG4gICAgfVxuICAgIHJldHVybiBkYXRlID4gPG51bWJlcj50aGlzLmJlZ2luICYmIGRhdGUgPCA8bnVtYmVyPnRoaXMuZW5kO1xuICB9XG5cbiAgICAvKiogRm9jdXNlcyB0aGUgYWN0aXZlIGNlbGwgYWZ0ZXIgdGhlIG1pY3JvdGFzayBxdWV1ZSBpcyBlbXB0eS4gKi9cbiAgICBfZm9jdXNBY3RpdmVDZWxsKCkge1xuICAgICAgICB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fbmdab25lLm9uU3RhYmxlLmFzT2JzZXJ2YWJsZSgpLnBpcGUodGFrZSgxKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLm1hdC1jYWxlbmRhci1ib2R5LWFjdGl2ZScpLmZvY3VzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCB7XG4gIERPV05fQVJST1csXG4gIEVORCxcbiAgRU5URVIsXG4gIEhPTUUsXG4gIExFRlRfQVJST1csXG4gIFBBR0VfRE9XTixcbiAgUEFHRV9VUCxcbiAgUklHSFRfQVJST1csXG4gIFVQX0FSUk9XLFxufSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xuaW1wb3J0IHtcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBDb21wb25lbnQsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5qZWN0LFxuICBJbnB1dCxcbiAgT3B0aW9uYWwsXG4gIE91dHB1dCxcbiAgVmlld0VuY2Fwc3VsYXRpb24sXG4gIFZpZXdDaGlsZCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0RhdGVBZGFwdGVyfSBmcm9tICcuLi9kYXRldGltZS9kYXRlLWFkYXB0ZXInO1xuaW1wb3J0IHtNQVRfREFURV9GT1JNQVRTLCBNYXREYXRlRm9ybWF0c30gZnJvbSAnLi4vZGF0ZXRpbWUvZGF0ZS1mb3JtYXRzJztcbmltcG9ydCB7RGlyZWN0aW9uYWxpdHl9IGZyb20gJ0Bhbmd1bGFyL2Nkay9iaWRpJztcbmltcG9ydCB7U2F0Q2FsZW5kYXJCb2R5LCBTYXRDYWxlbmRhckNlbGx9IGZyb20gJy4vY2FsZW5kYXItYm9keSc7XG5pbXBvcnQge2NyZWF0ZU1pc3NpbmdEYXRlSW1wbEVycm9yfSBmcm9tICcuL2RhdGVwaWNrZXItZXJyb3JzJztcblxuXG5jb25zdCBEQVlTX1BFUl9XRUVLID0gNztcblxuXG4vKipcbiAqIEFuIGludGVybmFsIGNvbXBvbmVudCB1c2VkIHRvIGRpc3BsYXkgYSBzaW5nbGUgbW9udGggaW4gdGhlIGRhdGVwaWNrZXIuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbkBDb21wb25lbnQoe1xuICBtb2R1bGVJZDogbW9kdWxlLmlkLFxuICBzZWxlY3RvcjogJ3NhdC1tb250aC12aWV3JyxcbiAgdGVtcGxhdGVVcmw6ICdtb250aC12aWV3Lmh0bWwnLFxuICBleHBvcnRBczogJ21hdE1vbnRoVmlldycsXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIFNhdE1vbnRoVmlldzxEPiBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQge1xuXG4gIC8qKiBDdXJyZW50IHN0YXJ0IG9mIGludGVydmFsLiAqL1xuICBASW5wdXQoKVxuICBnZXQgYmVnaW5EYXRlKCk6IEQgfCBudWxsIHsgcmV0dXJuIHRoaXMuX2JlZ2luRGF0ZTsgfVxuICBzZXQgYmVnaW5EYXRlKHZhbHVlOiBEIHwgbnVsbCkge1xuICAgIHRoaXMuX2JlZ2luRGF0ZSA9IHRoaXMuX2dldFZhbGlkRGF0ZU9yTnVsbCh0aGlzLl9kYXRlQWRhcHRlci5kZXNlcmlhbGl6ZSh2YWx1ZSkpO1xuICAgIHRoaXMudXBkYXRlUmFuZ2VTcGVjaWZpY1ZhbHVlcygpO1xuICB9XG4gIHByaXZhdGUgX2JlZ2luRGF0ZTogRCB8IG51bGw7XG5cbiAgLyoqIEN1cnJlbnQgZW5kIG9mIGludGVydmFsLiAqL1xuICBASW5wdXQoKVxuICBnZXQgZW5kRGF0ZSgpOiBEIHwgbnVsbCB7IHJldHVybiB0aGlzLl9lbmREYXRlOyB9XG4gIHNldCBlbmREYXRlKHZhbHVlOiBEIHwgbnVsbCkge1xuICAgIHRoaXMuX2VuZERhdGUgPSB0aGlzLl9nZXRWYWxpZERhdGVPck51bGwodGhpcy5fZGF0ZUFkYXB0ZXIuZGVzZXJpYWxpemUodmFsdWUpKTtcbiAgICB0aGlzLnVwZGF0ZVJhbmdlU3BlY2lmaWNWYWx1ZXMoKTtcbiAgfVxuICBwcml2YXRlIF9lbmREYXRlOiBEIHwgbnVsbDtcblxuICAvKiogQWxsb3cgc2VsZWN0aW5nIHJhbmdlIG9mIGRhdGVzLiAqL1xuICBASW5wdXQoKSByYW5nZU1vZGUgPSBmYWxzZTtcblxuICAvKiogRmlyc3QgZGF5IG9mIGludGVydmFsLiAqL1xuICBfYmVnaW5EYXRlTnVtYmVyOiBudW1iZXIgfCBudWxsO1xuXG4gIC8qIExhc3QgZGF5IG9mIGludGVydmFsLiAqL1xuICBfZW5kRGF0ZU51bWJlcjogbnVtYmVyIHwgbnVsbDtcblxuICAvKiogV2hlbmV2ZXIgZnVsbCBtb250aCBpcyBpbnNpZGUgZGF0ZXMgaW50ZXJ2YWwuICovXG4gIF9yYW5nZUZ1bGw6IGJvb2xlYW4gfCBudWxsID0gZmFsc2U7XG5cbiAgLyoqIFdoZW5ldmVyIHVzZXIgYWxyZWFkeSBzZWxlY3RlZCBzdGFydCBvZiBkYXRlcyBpbnRlcnZhbC4gKi9cbiAgcHJpdmF0ZSBfYmVnaW5EYXRlU2VsZWN0ZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogVGhlIGRhdGUgdG8gZGlzcGxheSBpbiB0aGlzIG1vbnRoIHZpZXcgKGV2ZXJ5dGhpbmcgb3RoZXIgdGhhbiB0aGUgbW9udGggYW5kIHllYXIgaXMgaWdub3JlZCkuXG4gICAqL1xuICBASW5wdXQoKVxuICBnZXQgYWN0aXZlRGF0ZSgpOiBEIHsgcmV0dXJuIHRoaXMuX2FjdGl2ZURhdGU7IH1cbiAgc2V0IGFjdGl2ZURhdGUodmFsdWU6IEQpIHtcbiAgICBjb25zdCBvbGRBY3RpdmVEYXRlID0gdGhpcy5fYWN0aXZlRGF0ZTtcbiAgICBjb25zdCB2YWxpZERhdGUgPVxuICAgICAgICB0aGlzLl9nZXRWYWxpZERhdGVPck51bGwodGhpcy5fZGF0ZUFkYXB0ZXIuZGVzZXJpYWxpemUodmFsdWUpKSB8fCB0aGlzLl9kYXRlQWRhcHRlci50b2RheSgpO1xuICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0aGlzLl9kYXRlQWRhcHRlci5jbGFtcERhdGUodmFsaWREYXRlLCB0aGlzLm1pbkRhdGUsIHRoaXMubWF4RGF0ZSk7XG4gICAgaWYgKCF0aGlzLl9oYXNTYW1lTW9udGhBbmRZZWFyKG9sZEFjdGl2ZURhdGUsIHRoaXMuX2FjdGl2ZURhdGUpKSB7XG4gICAgICB0aGlzLl9pbml0KCk7XG4gICAgfVxuICB9XG4gIHByaXZhdGUgX2FjdGl2ZURhdGU6IEQ7XG5cbiAgLyoqIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZGF0ZS4gKi9cbiAgQElucHV0KClcbiAgZ2V0IHNlbGVjdGVkKCk6IEQgfCBudWxsIHsgcmV0dXJuIHRoaXMuX3NlbGVjdGVkOyB9XG4gIHNldCBzZWxlY3RlZCh2YWx1ZTogRCB8IG51bGwpIHtcbiAgICB0aGlzLl9zZWxlY3RlZCA9IHRoaXMuX2dldFZhbGlkRGF0ZU9yTnVsbCh0aGlzLl9kYXRlQWRhcHRlci5kZXNlcmlhbGl6ZSh2YWx1ZSkpO1xuICAgIHRoaXMuX3NlbGVjdGVkRGF0ZSA9IHRoaXMuX2dldERhdGVJbkN1cnJlbnRNb250aCh0aGlzLl9zZWxlY3RlZCk7XG4gIH1cbiAgcHJpdmF0ZSBfc2VsZWN0ZWQ6IEQgfCBudWxsO1xuXG4gIC8qKiBUaGUgbWluaW11bSBzZWxlY3RhYmxlIGRhdGUuICovXG4gIEBJbnB1dCgpXG4gIGdldCBtaW5EYXRlKCk6IEQgfCBudWxsIHsgcmV0dXJuIHRoaXMuX21pbkRhdGU7IH1cbiAgc2V0IG1pbkRhdGUodmFsdWU6IEQgfCBudWxsKSB7XG4gICAgdGhpcy5fbWluRGF0ZSA9IHRoaXMuX2dldFZhbGlkRGF0ZU9yTnVsbCh0aGlzLl9kYXRlQWRhcHRlci5kZXNlcmlhbGl6ZSh2YWx1ZSkpO1xuICB9XG4gIHByaXZhdGUgX21pbkRhdGU6IEQgfCBudWxsO1xuXG4gIC8qKiBUaGUgbWF4aW11bSBzZWxlY3RhYmxlIGRhdGUuICovXG4gIEBJbnB1dCgpXG4gIGdldCBtYXhEYXRlKCk6IEQgfCBudWxsIHsgcmV0dXJuIHRoaXMuX21heERhdGU7IH1cbiAgc2V0IG1heERhdGUodmFsdWU6IEQgfCBudWxsKSB7XG4gICAgdGhpcy5fbWF4RGF0ZSA9IHRoaXMuX2dldFZhbGlkRGF0ZU9yTnVsbCh0aGlzLl9kYXRlQWRhcHRlci5kZXNlcmlhbGl6ZSh2YWx1ZSkpO1xuICB9XG4gIHByaXZhdGUgX21heERhdGU6IEQgfCBudWxsO1xuXG4gIC8qKiBBIGZ1bmN0aW9uIHVzZWQgdG8gZmlsdGVyIHdoaWNoIGRhdGVzIGFyZSBzZWxlY3RhYmxlLiAqL1xuICBASW5wdXQoKSBkYXRlRmlsdGVyOiAoZGF0ZTogRCkgPT4gYm9vbGVhbjtcblxuICAvKiogRW1pdHMgd2hlbiBhIG5ldyBkYXRlIGlzIHNlbGVjdGVkLiAqL1xuICBAT3V0cHV0KCkgcmVhZG9ubHkgc2VsZWN0ZWRDaGFuZ2U6IEV2ZW50RW1pdHRlcjxEIHwgbnVsbD4gPSBuZXcgRXZlbnRFbWl0dGVyPEQgfCBudWxsPigpO1xuXG4gIC8qKiBFbWl0cyB3aGVuIGFueSBkYXRlIGlzIHNlbGVjdGVkLiAqL1xuICBAT3V0cHV0KCkgcmVhZG9ubHkgX3VzZXJTZWxlY3Rpb246IEV2ZW50RW1pdHRlcjx2b2lkPiA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAvKiogRW1pdHMgd2hlbiBhbnkgZGF0ZSBpcyBhY3RpdmF0ZWQuICovXG4gIEBPdXRwdXQoKSByZWFkb25seSBhY3RpdmVEYXRlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8RD4gPSBuZXcgRXZlbnRFbWl0dGVyPEQ+KCk7XG5cbiAgLyoqIFRoZSBib2R5IG9mIGNhbGVuZGFyIHRhYmxlICovXG4gIEBWaWV3Q2hpbGQoU2F0Q2FsZW5kYXJCb2R5KSBfbWF0Q2FsZW5kYXJCb2R5OiBTYXRDYWxlbmRhckJvZHk7XG5cbiAgLyoqIFRoZSBsYWJlbCBmb3IgdGhpcyBtb250aCAoZS5nLiBcIkphbnVhcnkgMjAxN1wiKS4gKi9cbiAgX21vbnRoTGFiZWw6IHN0cmluZztcblxuICAvKiogR3JpZCBvZiBjYWxlbmRhciBjZWxscyByZXByZXNlbnRpbmcgdGhlIGRhdGVzIG9mIHRoZSBtb250aC4gKi9cbiAgX3dlZWtzOiBTYXRDYWxlbmRhckNlbGxbXVtdO1xuXG4gIC8qKiBUaGUgbnVtYmVyIG9mIGJsYW5rIGNlbGxzIGluIHRoZSBmaXJzdCByb3cgYmVmb3JlIHRoZSAxc3Qgb2YgdGhlIG1vbnRoLiAqL1xuICBfZmlyc3RXZWVrT2Zmc2V0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBkYXRlIG9mIHRoZSBtb250aCB0aGF0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgRGF0ZSBmYWxscyBvbi5cbiAgICogTnVsbCBpZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIERhdGUgaXMgaW4gYW5vdGhlciBtb250aC5cbiAgICovXG4gIF9zZWxlY3RlZERhdGU6IG51bWJlciB8IG51bGw7XG5cbiAgLyoqIFRoZSBkYXRlIG9mIHRoZSBtb250aCB0aGF0IHRvZGF5IGZhbGxzIG9uLiBOdWxsIGlmIHRvZGF5IGlzIGluIGFub3RoZXIgbW9udGguICovXG4gIF90b2RheURhdGU6IG51bWJlciB8IG51bGw7XG5cbiAgLyoqIFRoZSBuYW1lcyBvZiB0aGUgd2Vla2RheXMuICovXG4gIF93ZWVrZGF5czoge2xvbmc6IHN0cmluZywgbmFycm93OiBzdHJpbmd9W107XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICAgICAgICBAT3B0aW9uYWwoKSBASW5qZWN0KE1BVF9EQVRFX0ZPUk1BVFMpIHByaXZhdGUgX2RhdGVGb3JtYXRzOiBNYXREYXRlRm9ybWF0cyxcbiAgICAgICAgICAgICAgQE9wdGlvbmFsKCkgcHVibGljIF9kYXRlQWRhcHRlcjogRGF0ZUFkYXB0ZXI8RD4sXG4gICAgICAgICAgICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX2Rpcj86IERpcmVjdGlvbmFsaXR5KSB7XG4gICAgaWYgKCF0aGlzLl9kYXRlQWRhcHRlcikge1xuICAgICAgdGhyb3cgY3JlYXRlTWlzc2luZ0RhdGVJbXBsRXJyb3IoJ0RhdGVBZGFwdGVyJyk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fZGF0ZUZvcm1hdHMpIHtcbiAgICAgIHRocm93IGNyZWF0ZU1pc3NpbmdEYXRlSW1wbEVycm9yKCdNQVRfREFURV9GT1JNQVRTJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3REYXlPZldlZWsgPSB0aGlzLl9kYXRlQWRhcHRlci5nZXRGaXJzdERheU9mV2VlaygpO1xuICAgIGNvbnN0IG5hcnJvd1dlZWtkYXlzID0gdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0RGF5T2ZXZWVrTmFtZXMoJ25hcnJvdycpO1xuICAgIGNvbnN0IGxvbmdXZWVrZGF5cyA9IHRoaXMuX2RhdGVBZGFwdGVyLmdldERheU9mV2Vla05hbWVzKCdsb25nJyk7XG5cbiAgICAvLyBSb3RhdGUgdGhlIGxhYmVscyBmb3IgZGF5cyBvZiB0aGUgd2VlayBiYXNlZCBvbiB0aGUgY29uZmlndXJlZCBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgbGV0IHdlZWtkYXlzID0gbG9uZ1dlZWtkYXlzLm1hcCgobG9uZywgaSkgPT4ge1xuICAgICAgcmV0dXJuIHtsb25nLCBuYXJyb3c6IG5hcnJvd1dlZWtkYXlzW2ldfTtcbiAgICB9KTtcbiAgICB0aGlzLl93ZWVrZGF5cyA9IHdlZWtkYXlzLnNsaWNlKGZpcnN0RGF5T2ZXZWVrKS5jb25jYXQod2Vla2RheXMuc2xpY2UoMCwgZmlyc3REYXlPZldlZWspKTtcblxuICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0aGlzLl9kYXRlQWRhcHRlci50b2RheSgpO1xuICB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIHRoaXMuX2luaXQoKTtcbiAgfVxuXG4gIC8qKiBIYW5kbGVzIHdoZW4gYSBuZXcgZGF0ZSBpcyBzZWxlY3RlZC4gKi9cbiAgX2RhdGVTZWxlY3RlZChkYXRlOiBudW1iZXIpIHtcblxuICAgIGlmICh0aGlzLnJhbmdlTW9kZSkge1xuXG4gICAgICBjb25zdCBzZWxlY3RlZFllYXIgPSB0aGlzLl9kYXRlQWRhcHRlci5nZXRZZWFyKHRoaXMuYWN0aXZlRGF0ZSk7XG4gICAgICBjb25zdCBzZWxlY3RlZE1vbnRoID0gdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0TW9udGgodGhpcy5hY3RpdmVEYXRlKTtcbiAgICAgIGNvbnN0IHNlbGVjdGVkRGF0ZSA9IHRoaXMuX2RhdGVBZGFwdGVyLmNyZWF0ZURhdGUoc2VsZWN0ZWRZZWFyLCBzZWxlY3RlZE1vbnRoLCBkYXRlKTtcbiAgICAgIGlmICghdGhpcy5fYmVnaW5EYXRlU2VsZWN0ZWQpIHsgLy8gQXQgZmlyc3QgY2xpY2sgZW1pdCB0aGUgc2FtZSBzdGFydCBhbmQgZW5kIG9mIGludGVydmFsXG4gICAgICAgIHRoaXMuX2JlZ2luRGF0ZVNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZENoYW5nZS5lbWl0KHNlbGVjdGVkRGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9iZWdpbkRhdGVTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ2hhbmdlLmVtaXQoc2VsZWN0ZWREYXRlKTtcbiAgICAgICAgdGhpcy5fdXNlclNlbGVjdGlvbi5lbWl0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zZWxlY3RlZERhdGUgIT0gZGF0ZSkge1xuXG4gICAgICBjb25zdCBzZWxlY3RlZFllYXIgPSB0aGlzLl9kYXRlQWRhcHRlci5nZXRZZWFyKHRoaXMuYWN0aXZlRGF0ZSk7XG4gICAgICBjb25zdCBzZWxlY3RlZE1vbnRoID0gdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0TW9udGgodGhpcy5hY3RpdmVEYXRlKTtcbiAgICAgIGNvbnN0IHNlbGVjdGVkRGF0ZSA9IHRoaXMuX2RhdGVBZGFwdGVyLmNyZWF0ZURhdGUoc2VsZWN0ZWRZZWFyLCBzZWxlY3RlZE1vbnRoLCBkYXRlKTtcblxuICAgICAgdGhpcy5zZWxlY3RlZENoYW5nZS5lbWl0KHNlbGVjdGVkRGF0ZSk7XG4gICAgICB0aGlzLl91c2VyU2VsZWN0aW9uLmVtaXQoKTtcbiAgICB9XG4gIH1cblxuICAvKiogSGFuZGxlcyBrZXlkb3duIGV2ZW50cyBvbiB0aGUgY2FsZW5kYXIgYm9keSB3aGVuIGNhbGVuZGFyIGlzIGluIG1vbnRoIHZpZXcuICovXG4gIF9oYW5kbGVDYWxlbmRhckJvZHlLZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgLy8gVE9ETyhtbWFsZXJiYSk6IFdlIGN1cnJlbnRseSBhbGxvdyBrZXlib2FyZCBuYXZpZ2F0aW9uIHRvIGRpc2FibGVkIGRhdGVzLCBidXQganVzdCBwcmV2ZW50XG4gICAgLy8gZGlzYWJsZWQgb25lcyBmcm9tIGJlaW5nIHNlbGVjdGVkLiBUaGlzIG1heSBub3QgYmUgaWRlYWwsIHdlIHNob3VsZCBsb29rIGludG8gd2hldGhlclxuICAgIC8vIG5hdmlnYXRpb24gc2hvdWxkIHNraXAgb3ZlciBkaXNhYmxlZCBkYXRlcywgYW5kIGlmIHNvLCBob3cgdG8gaW1wbGVtZW50IHRoYXQgZWZmaWNpZW50bHkuXG5cbiAgICBjb25zdCBvbGRBY3RpdmVEYXRlID0gdGhpcy5fYWN0aXZlRGF0ZTtcbiAgICBjb25zdCBpc1J0bCA9IHRoaXMuX2lzUnRsKCk7XG5cbiAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgIGNhc2UgTEVGVF9BUlJPVzpcbiAgICAgICAgdGhpcy5hY3RpdmVEYXRlID0gdGhpcy5fZGF0ZUFkYXB0ZXIuYWRkQ2FsZW5kYXJEYXlzKHRoaXMuX2FjdGl2ZURhdGUsIGlzUnRsID8gMSA6IC0xKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFJJR0hUX0FSUk9XOlxuICAgICAgICB0aGlzLmFjdGl2ZURhdGUgPSB0aGlzLl9kYXRlQWRhcHRlci5hZGRDYWxlbmRhckRheXModGhpcy5fYWN0aXZlRGF0ZSwgaXNSdGwgPyAtMSA6IDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVVBfQVJST1c6XG4gICAgICAgIHRoaXMuYWN0aXZlRGF0ZSA9IHRoaXMuX2RhdGVBZGFwdGVyLmFkZENhbGVuZGFyRGF5cyh0aGlzLl9hY3RpdmVEYXRlLCAtNyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBET1dOX0FSUk9XOlxuICAgICAgICB0aGlzLmFjdGl2ZURhdGUgPSB0aGlzLl9kYXRlQWRhcHRlci5hZGRDYWxlbmRhckRheXModGhpcy5fYWN0aXZlRGF0ZSwgNyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIT01FOlxuICAgICAgICB0aGlzLmFjdGl2ZURhdGUgPSB0aGlzLl9kYXRlQWRhcHRlci5hZGRDYWxlbmRhckRheXModGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgICAgICAgIDEgLSB0aGlzLl9kYXRlQWRhcHRlci5nZXREYXRlKHRoaXMuX2FjdGl2ZURhdGUpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVORDpcbiAgICAgICAgdGhpcy5hY3RpdmVEYXRlID0gdGhpcy5fZGF0ZUFkYXB0ZXIuYWRkQ2FsZW5kYXJEYXlzKHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICAgICAgICAodGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0TnVtRGF5c0luTW9udGgodGhpcy5fYWN0aXZlRGF0ZSkgLVxuICAgICAgICAgICAgICB0aGlzLl9kYXRlQWRhcHRlci5nZXREYXRlKHRoaXMuX2FjdGl2ZURhdGUpKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQQUdFX1VQOlxuICAgICAgICB0aGlzLmFjdGl2ZURhdGUgPSBldmVudC5hbHRLZXkgP1xuICAgICAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIuYWRkQ2FsZW5kYXJZZWFycyh0aGlzLl9hY3RpdmVEYXRlLCAtMSkgOlxuICAgICAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIuYWRkQ2FsZW5kYXJNb250aHModGhpcy5fYWN0aXZlRGF0ZSwgLTEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUEFHRV9ET1dOOlxuICAgICAgICB0aGlzLmFjdGl2ZURhdGUgPSBldmVudC5hbHRLZXkgP1xuICAgICAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIuYWRkQ2FsZW5kYXJZZWFycyh0aGlzLl9hY3RpdmVEYXRlLCAxKSA6XG4gICAgICAgICAgICB0aGlzLl9kYXRlQWRhcHRlci5hZGRDYWxlbmRhck1vbnRocyh0aGlzLl9hY3RpdmVEYXRlLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVOVEVSOlxuICAgICAgICBpZiAoIXRoaXMuZGF0ZUZpbHRlciB8fCB0aGlzLmRhdGVGaWx0ZXIodGhpcy5fYWN0aXZlRGF0ZSkpIHtcbiAgICAgICAgICB0aGlzLl9kYXRlU2VsZWN0ZWQodGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0RGF0ZSh0aGlzLl9hY3RpdmVEYXRlKSk7XG4gICAgICAgICAgdGhpcy5fdXNlclNlbGVjdGlvbi5lbWl0KCk7XG4gICAgICAgICAgLy8gUHJldmVudCB1bmV4cGVjdGVkIGRlZmF1bHQgYWN0aW9ucyBzdWNoIGFzIGZvcm0gc3VibWlzc2lvbi5cbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIERvbid0IHByZXZlbnQgZGVmYXVsdCBvciBmb2N1cyBhY3RpdmUgY2VsbCBvbiBrZXlzIHRoYXQgd2UgZG9uJ3QgZXhwbGljaXRseSBoYW5kbGUuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGF0ZUFkYXB0ZXIuY29tcGFyZURhdGUob2xkQWN0aXZlRGF0ZSwgdGhpcy5hY3RpdmVEYXRlKSkge1xuICAgICAgdGhpcy5hY3RpdmVEYXRlQ2hhbmdlLmVtaXQodGhpcy5hY3RpdmVEYXRlKTtcbiAgICB9XG5cbiAgICB0aGlzLl9mb2N1c0FjdGl2ZUNlbGwoKTtcbiAgICAvLyBQcmV2ZW50IHVuZXhwZWN0ZWQgZGVmYXVsdCBhY3Rpb25zIHN1Y2ggYXMgZm9ybSBzdWJtaXNzaW9uLlxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICAvKiogSW5pdGlhbGl6ZXMgdGhpcyBtb250aCB2aWV3LiAqL1xuICBfaW5pdCgpIHtcbiAgICB0aGlzLnVwZGF0ZVJhbmdlU3BlY2lmaWNWYWx1ZXMoKTtcbiAgICB0aGlzLl9zZWxlY3RlZERhdGUgPSB0aGlzLl9nZXREYXRlSW5DdXJyZW50TW9udGgodGhpcy5zZWxlY3RlZCk7XG4gICAgdGhpcy5fdG9kYXlEYXRlID0gdGhpcy5fZ2V0RGF0ZUluQ3VycmVudE1vbnRoKHRoaXMuX2RhdGVBZGFwdGVyLnRvZGF5KCkpO1xuICAgIHRoaXMuX21vbnRoTGFiZWwgPVxuICAgICAgICB0aGlzLl9kYXRlQWRhcHRlci5nZXRNb250aE5hbWVzKCdzaG9ydCcpW3RoaXMuX2RhdGVBZGFwdGVyLmdldE1vbnRoKHRoaXMuYWN0aXZlRGF0ZSldXG4gICAgICAgICAgICAudG9Mb2NhbGVVcHBlckNhc2UoKTtcblxuICAgIGxldCBmaXJzdE9mTW9udGggPSB0aGlzLl9kYXRlQWRhcHRlci5jcmVhdGVEYXRlKHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXIodGhpcy5hY3RpdmVEYXRlKSxcbiAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0TW9udGgodGhpcy5hY3RpdmVEYXRlKSwgMSk7XG4gICAgdGhpcy5fZmlyc3RXZWVrT2Zmc2V0ID1cbiAgICAgICAgKERBWVNfUEVSX1dFRUsgKyB0aGlzLl9kYXRlQWRhcHRlci5nZXREYXlPZldlZWsoZmlyc3RPZk1vbnRoKSAtXG4gICAgICAgICB0aGlzLl9kYXRlQWRhcHRlci5nZXRGaXJzdERheU9mV2VlaygpKSAlIERBWVNfUEVSX1dFRUs7XG5cbiAgICB0aGlzLl9jcmVhdGVXZWVrQ2VsbHMoKTtcbiAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuXG4gIC8qKiBGb2N1c2VzIHRoZSBhY3RpdmUgY2VsbCBhZnRlciB0aGUgbWljcm90YXNrIHF1ZXVlIGlzIGVtcHR5LiAqL1xuICBfZm9jdXNBY3RpdmVDZWxsKCkge1xuICAgIHRoaXMuX21hdENhbGVuZGFyQm9keS5fZm9jdXNBY3RpdmVDZWxsKCk7XG4gIH1cblxuICAvKiogQ3JlYXRlcyBTYXRDYWxlbmRhckNlbGxzIGZvciB0aGUgZGF0ZXMgaW4gdGhpcyBtb250aC4gKi9cbiAgcHJpdmF0ZSBfY3JlYXRlV2Vla0NlbGxzKCkge1xuICAgIGNvbnN0IGRheXNJbk1vbnRoID0gdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0TnVtRGF5c0luTW9udGgodGhpcy5hY3RpdmVEYXRlKTtcbiAgICBjb25zdCBkYXRlTmFtZXMgPSB0aGlzLl9kYXRlQWRhcHRlci5nZXREYXRlTmFtZXMoKTtcbiAgICB0aGlzLl93ZWVrcyA9IFtbXV07XG4gICAgZm9yIChsZXQgaSA9IDAsIGNlbGwgPSB0aGlzLl9maXJzdFdlZWtPZmZzZXQ7IGkgPCBkYXlzSW5Nb250aDsgaSsrLCBjZWxsKyspIHtcbiAgICAgIGlmIChjZWxsID09IERBWVNfUEVSX1dFRUspIHtcbiAgICAgICAgdGhpcy5fd2Vla3MucHVzaChbXSk7XG4gICAgICAgIGNlbGwgPSAwO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0ZSA9IHRoaXMuX2RhdGVBZGFwdGVyLmNyZWF0ZURhdGUoXG4gICAgICAgICAgICB0aGlzLl9kYXRlQWRhcHRlci5nZXRZZWFyKHRoaXMuYWN0aXZlRGF0ZSksXG4gICAgICAgICAgICB0aGlzLl9kYXRlQWRhcHRlci5nZXRNb250aCh0aGlzLmFjdGl2ZURhdGUpLCBpICsgMSk7XG4gICAgICBjb25zdCBlbmFibGVkID0gdGhpcy5fc2hvdWxkRW5hYmxlRGF0ZShkYXRlKTtcbiAgICAgIGNvbnN0IGFyaWFMYWJlbCA9IHRoaXMuX2RhdGVBZGFwdGVyLmZvcm1hdChkYXRlLCB0aGlzLl9kYXRlRm9ybWF0cy5kaXNwbGF5LmRhdGVBMTF5TGFiZWwpO1xuICAgICAgdGhpcy5fd2Vla3NbdGhpcy5fd2Vla3MubGVuZ3RoIC0gMV1cbiAgICAgICAgICAucHVzaChuZXcgU2F0Q2FsZW5kYXJDZWxsKGkgKyAxLCBkYXRlTmFtZXNbaV0sIGFyaWFMYWJlbCwgZW5hYmxlZCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBEYXRlIGZpbHRlciBmb3IgdGhlIG1vbnRoICovXG4gIHByaXZhdGUgX3Nob3VsZEVuYWJsZURhdGUoZGF0ZTogRCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIWRhdGUgJiZcbiAgICAgICAgKCF0aGlzLmRhdGVGaWx0ZXIgfHwgdGhpcy5kYXRlRmlsdGVyKGRhdGUpKSAmJlxuICAgICAgICAoIXRoaXMubWluRGF0ZSB8fCB0aGlzLl9kYXRlQWRhcHRlci5jb21wYXJlRGF0ZShkYXRlLCB0aGlzLm1pbkRhdGUpID49IDApICYmXG4gICAgICAgICghdGhpcy5tYXhEYXRlIHx8IHRoaXMuX2RhdGVBZGFwdGVyLmNvbXBhcmVEYXRlKGRhdGUsIHRoaXMubWF4RGF0ZSkgPD0gMCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgZGF0ZSBpbiB0aGlzIG1vbnRoIHRoYXQgdGhlIGdpdmVuIERhdGUgZmFsbHMgb24uXG4gICAqIFJldHVybnMgbnVsbCBpZiB0aGUgZ2l2ZW4gRGF0ZSBpcyBpbiBhbm90aGVyIG1vbnRoLlxuICAgKi9cbiAgcHJpdmF0ZSBfZ2V0RGF0ZUluQ3VycmVudE1vbnRoKGRhdGU6IEQgfCBudWxsKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgcmV0dXJuIGRhdGUgJiYgdGhpcy5faGFzU2FtZU1vbnRoQW5kWWVhcihkYXRlLCB0aGlzLmFjdGl2ZURhdGUpID9cbiAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0RGF0ZShkYXRlKSA6IG51bGw7XG4gIH1cblxuICAvKiogQ2hlY2tzIHdoZXRoZXIgdGhlIDIgZGF0ZXMgYXJlIG5vbi1udWxsIGFuZCBmYWxsIHdpdGhpbiB0aGUgc2FtZSBtb250aCBvZiB0aGUgc2FtZSB5ZWFyLiAqL1xuICBwcml2YXRlIF9oYXNTYW1lTW9udGhBbmRZZWFyKGQxOiBEIHwgbnVsbCwgZDI6IEQgfCBudWxsKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhKGQxICYmIGQyICYmIHRoaXMuX2RhdGVBZGFwdGVyLmdldE1vbnRoKGQxKSA9PSB0aGlzLl9kYXRlQWRhcHRlci5nZXRNb250aChkMikgJiZcbiAgICAgICAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhcihkMSkgPT0gdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhcihkMikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBvYmogVGhlIG9iamVjdCB0byBjaGVjay5cbiAgICogQHJldHVybnMgVGhlIGdpdmVuIG9iamVjdCBpZiBpdCBpcyBib3RoIGEgZGF0ZSBpbnN0YW5jZSBhbmQgdmFsaWQsIG90aGVyd2lzZSBudWxsLlxuICAgKi9cbiAgcHJpdmF0ZSBfZ2V0VmFsaWREYXRlT3JOdWxsKG9iajogYW55KTogRCB8IG51bGwge1xuICAgIHJldHVybiAodGhpcy5fZGF0ZUFkYXB0ZXIuaXNEYXRlSW5zdGFuY2Uob2JqKSAmJiB0aGlzLl9kYXRlQWRhcHRlci5pc1ZhbGlkKG9iaikpID8gb2JqIDogbnVsbDtcbiAgfVxuXG4gICAgLyoqIERldGVybWluZXMgd2hldGhlciB0aGUgdXNlciBoYXMgdGhlIFJUTCBsYXlvdXQgZGlyZWN0aW9uLiAqL1xuICAgIHByaXZhdGUgX2lzUnRsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlyICYmIHRoaXMuX2Rpci52YWx1ZSA9PT0gJ3J0bCc7XG4gICAgfVxuICAvKiogVXBkYXRlcyByYW5nZSBmdWxsIHBhcmFtZXRlciBvbiBlYWNoIGJlZ2luIG9yIGVuZCBvZiBpbnRlcnZhbCB1cGRhdGUuXG4gICAqIE5lY2Vzc2FyeSB0byBkaXNwbGF5IGNhbGVuZGFyLWJvZHkgY29ycmVjdGx5XG4gICAqL1xuICBwcml2YXRlIHVwZGF0ZVJhbmdlU3BlY2lmaWNWYWx1ZXMoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMucmFuZ2VNb2RlKSB7XG4gICAgICB0aGlzLl9iZWdpbkRhdGVOdW1iZXIgPSB0aGlzLl9nZXREYXRlSW5DdXJyZW50TW9udGgodGhpcy5fYmVnaW5EYXRlKTtcbiAgICAgIHRoaXMuX2VuZERhdGVOdW1iZXIgPSB0aGlzLl9nZXREYXRlSW5DdXJyZW50TW9udGgodGhpcy5fZW5kRGF0ZSk7XG4gICAgICB0aGlzLl9yYW5nZUZ1bGwgPSB0aGlzLmJlZ2luRGF0ZSAmJiB0aGlzLmVuZERhdGUgJiYgIXRoaXMuX2JlZ2luRGF0ZU51bWJlciAmJlxuICAgICAgICAhdGhpcy5fZW5kRGF0ZU51bWJlciAmJlxuICAgICAgICB0aGlzLl9kYXRlQWRhcHRlci5jb21wYXJlRGF0ZSh0aGlzLmJlZ2luRGF0ZSwgdGhpcy5hY3RpdmVEYXRlKSA8PSAwICYmXG4gICAgICAgIHRoaXMuX2RhdGVBZGFwdGVyLmNvbXBhcmVEYXRlKHRoaXMuYWN0aXZlRGF0ZSwgdGhpcy5lbmREYXRlKSA8PSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9iZWdpbkRhdGVOdW1iZXIgPSB0aGlzLl9lbmREYXRlTnVtYmVyID0gbnVsbDtcbiAgICAgIHRoaXMuX3JhbmdlRnVsbCA9IGZhbHNlO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCB7XG4gIERPV05fQVJST1csXG4gIEVORCxcbiAgRU5URVIsXG4gIEhPTUUsXG4gIExFRlRfQVJST1csXG4gIFBBR0VfRE9XTixcbiAgUEFHRV9VUCxcbiAgUklHSFRfQVJST1csXG4gIFVQX0FSUk9XLFxufSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xuaW1wb3J0IHtcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBDb21wb25lbnQsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIE9wdGlvbmFsLFxuICBPdXRwdXQsXG4gIFZpZXdDaGlsZCxcbiAgVmlld0VuY2Fwc3VsYXRpb24sXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtEaXJlY3Rpb25hbGl0eX0gZnJvbSAnQGFuZ3VsYXIvY2RrL2JpZGknO1xuaW1wb3J0IHtTYXRDYWxlbmRhckJvZHksIFNhdENhbGVuZGFyQ2VsbH0gZnJvbSAnLi9jYWxlbmRhci1ib2R5JztcbmltcG9ydCB7Y3JlYXRlTWlzc2luZ0RhdGVJbXBsRXJyb3J9IGZyb20gJy4vZGF0ZXBpY2tlci1lcnJvcnMnO1xuaW1wb3J0IHtEYXRlQWRhcHRlcn0gZnJvbSAnLi4vZGF0ZXRpbWUvZGF0ZS1hZGFwdGVyJztcblxuZXhwb3J0IGNvbnN0IHllYXJzUGVyUGFnZSA9IDI0O1xuXG5leHBvcnQgY29uc3QgeWVhcnNQZXJSb3cgPSA0O1xuXG5cbi8qKlxuICogQW4gaW50ZXJuYWwgY29tcG9uZW50IHVzZWQgdG8gZGlzcGxheSBhIHllYXIgc2VsZWN0b3IgaW4gdGhlIGRhdGVwaWNrZXIuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbkBDb21wb25lbnQoe1xuICBtb2R1bGVJZDogbW9kdWxlLmlkLFxuICBzZWxlY3RvcjogJ3NhdC1tdWx0aS15ZWFyLXZpZXcnLFxuICB0ZW1wbGF0ZVVybDogJ211bHRpLXllYXItdmlldy5odG1sJyxcbiAgZXhwb3J0QXM6ICdtYXRNdWx0aVllYXJWaWV3JyxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgU2F0TXVsdGlZZWFyVmlldzxEPiBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQge1xuICAvKiogVGhlIGRhdGUgdG8gZGlzcGxheSBpbiB0aGlzIG11bHRpLXllYXIgdmlldyAoZXZlcnl0aGluZyBvdGhlciB0aGFuIHRoZSB5ZWFyIGlzIGlnbm9yZWQpLiAqL1xuICBASW5wdXQoKVxuICBnZXQgYWN0aXZlRGF0ZSgpOiBEIHsgcmV0dXJuIHRoaXMuX2FjdGl2ZURhdGU7IH1cbiAgc2V0IGFjdGl2ZURhdGUodmFsdWU6IEQpIHtcbiAgICBsZXQgb2xkQWN0aXZlRGF0ZSA9IHRoaXMuX2FjdGl2ZURhdGU7XG4gICAgY29uc3QgdmFsaWREYXRlID1cbiAgICAgICAgdGhpcy5fZ2V0VmFsaWREYXRlT3JOdWxsKHRoaXMuX2RhdGVBZGFwdGVyLmRlc2VyaWFsaXplKHZhbHVlKSkgfHwgdGhpcy5fZGF0ZUFkYXB0ZXIudG9kYXkoKTtcbiAgICB0aGlzLl9hY3RpdmVEYXRlID0gdGhpcy5fZGF0ZUFkYXB0ZXIuY2xhbXBEYXRlKHZhbGlkRGF0ZSwgdGhpcy5taW5EYXRlLCB0aGlzLm1heERhdGUpO1xuICAgIGlmIChNYXRoLmZsb29yKHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXIob2xkQWN0aXZlRGF0ZSkgLyB5ZWFyc1BlclBhZ2UpICE9XG4gICAgICAgIE1hdGguZmxvb3IodGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhcih0aGlzLl9hY3RpdmVEYXRlKSAvIHllYXJzUGVyUGFnZSkpIHtcbiAgICAgIHRoaXMuX2luaXQoKTtcbiAgICB9XG4gIH1cbiAgcHJpdmF0ZSBfYWN0aXZlRGF0ZTogRDtcblxuICAvKiogVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBkYXRlLiAqL1xuICBASW5wdXQoKVxuICBnZXQgc2VsZWN0ZWQoKTogRCB8IG51bGwgeyByZXR1cm4gdGhpcy5fc2VsZWN0ZWQ7IH1cbiAgc2V0IHNlbGVjdGVkKHZhbHVlOiBEIHwgbnVsbCkge1xuICAgIHRoaXMuX3NlbGVjdGVkID0gdGhpcy5fZ2V0VmFsaWREYXRlT3JOdWxsKHRoaXMuX2RhdGVBZGFwdGVyLmRlc2VyaWFsaXplKHZhbHVlKSk7XG4gICAgdGhpcy5fc2VsZWN0ZWRZZWFyID0gdGhpcy5fc2VsZWN0ZWQgJiYgdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhcih0aGlzLl9zZWxlY3RlZCk7XG4gIH1cbiAgcHJpdmF0ZSBfc2VsZWN0ZWQ6IEQgfCBudWxsO1xuXG4gIC8qKiBUaGUgbWluaW11bSBzZWxlY3RhYmxlIGRhdGUuICovXG4gIEBJbnB1dCgpXG4gIGdldCBtaW5EYXRlKCk6IEQgfCBudWxsIHsgcmV0dXJuIHRoaXMuX21pbkRhdGU7IH1cbiAgc2V0IG1pbkRhdGUodmFsdWU6IEQgfCBudWxsKSB7XG4gICAgdGhpcy5fbWluRGF0ZSA9IHRoaXMuX2dldFZhbGlkRGF0ZU9yTnVsbCh0aGlzLl9kYXRlQWRhcHRlci5kZXNlcmlhbGl6ZSh2YWx1ZSkpO1xuICB9XG4gIHByaXZhdGUgX21pbkRhdGU6IEQgfCBudWxsO1xuXG4gIC8qKiBUaGUgbWF4aW11bSBzZWxlY3RhYmxlIGRhdGUuICovXG4gIEBJbnB1dCgpXG4gIGdldCBtYXhEYXRlKCk6IEQgfCBudWxsIHsgcmV0dXJuIHRoaXMuX21heERhdGU7IH1cbiAgc2V0IG1heERhdGUodmFsdWU6IEQgfCBudWxsKSB7XG4gICAgdGhpcy5fbWF4RGF0ZSA9IHRoaXMuX2dldFZhbGlkRGF0ZU9yTnVsbCh0aGlzLl9kYXRlQWRhcHRlci5kZXNlcmlhbGl6ZSh2YWx1ZSkpO1xuICB9XG4gIHByaXZhdGUgX21heERhdGU6IEQgfCBudWxsO1xuXG4gIC8qKiBBIGZ1bmN0aW9uIHVzZWQgdG8gZmlsdGVyIHdoaWNoIGRhdGVzIGFyZSBzZWxlY3RhYmxlLiAqL1xuICBASW5wdXQoKSBkYXRlRmlsdGVyOiAoZGF0ZTogRCkgPT4gYm9vbGVhbjtcblxuICAvKiogRW1pdHMgd2hlbiBhIG5ldyB5ZWFyIGlzIHNlbGVjdGVkLiAqL1xuICBAT3V0cHV0KCkgcmVhZG9ubHkgc2VsZWN0ZWRDaGFuZ2U6IEV2ZW50RW1pdHRlcjxEPiA9IG5ldyBFdmVudEVtaXR0ZXI8RD4oKTtcblxuICAvKiogRW1pdHMgdGhlIHNlbGVjdGVkIHllYXIuIFRoaXMgZG9lc24ndCBpbXBseSBhIGNoYW5nZSBvbiB0aGUgc2VsZWN0ZWQgZGF0ZSAqL1xuICBAT3V0cHV0KCkgcmVhZG9ubHkgeWVhclNlbGVjdGVkOiBFdmVudEVtaXR0ZXI8RD4gPSBuZXcgRXZlbnRFbWl0dGVyPEQ+KCk7XG5cbiAgLyoqIEVtaXRzIHdoZW4gYW55IGRhdGUgaXMgYWN0aXZhdGVkLiAqL1xuICBAT3V0cHV0KCkgcmVhZG9ubHkgYWN0aXZlRGF0ZUNoYW5nZTogRXZlbnRFbWl0dGVyPEQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxEPigpO1xuXG4gIC8qKiBUaGUgYm9keSBvZiBjYWxlbmRhciB0YWJsZSAqL1xuICBAVmlld0NoaWxkKFNhdENhbGVuZGFyQm9keSkgX21hdENhbGVuZGFyQm9keTogU2F0Q2FsZW5kYXJCb2R5O1xuXG4gIC8qKiBHcmlkIG9mIGNhbGVuZGFyIGNlbGxzIHJlcHJlc2VudGluZyB0aGUgY3VycmVudGx5IGRpc3BsYXllZCB5ZWFycy4gKi9cbiAgX3llYXJzOiBTYXRDYWxlbmRhckNlbGxbXVtdO1xuXG4gIC8qKiBUaGUgeWVhciB0aGF0IHRvZGF5IGZhbGxzIG9uLiAqL1xuICBfdG9kYXlZZWFyOiBudW1iZXI7XG5cbiAgLyoqIFRoZSB5ZWFyIG9mIHRoZSBzZWxlY3RlZCBkYXRlLiBOdWxsIGlmIHRoZSBzZWxlY3RlZCBkYXRlIGlzIG51bGwuICovXG4gIF9zZWxlY3RlZFllYXI6IG51bWJlciB8IG51bGw7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICAgICAgICBAT3B0aW9uYWwoKSBwdWJsaWMgX2RhdGVBZGFwdGVyOiBEYXRlQWRhcHRlcjxEPixcbiAgICAgICAgICAgICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBfZGlyPzogRGlyZWN0aW9uYWxpdHkpIHtcbiAgICBpZiAoIXRoaXMuX2RhdGVBZGFwdGVyKSB7XG4gICAgICB0aHJvdyBjcmVhdGVNaXNzaW5nRGF0ZUltcGxFcnJvcignRGF0ZUFkYXB0ZXInKTtcbiAgICB9XG5cbiAgICB0aGlzLl9hY3RpdmVEYXRlID0gdGhpcy5fZGF0ZUFkYXB0ZXIudG9kYXkoKTtcbiAgfVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICB0aGlzLl9pbml0KCk7XG4gIH1cblxuICAvKiogSW5pdGlhbGl6ZXMgdGhpcyBtdWx0aS15ZWFyIHZpZXcuICovXG4gIF9pbml0KCkge1xuICAgIHRoaXMuX3RvZGF5WWVhciA9IHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXIodGhpcy5fZGF0ZUFkYXB0ZXIudG9kYXkoKSk7XG4gICAgbGV0IGFjdGl2ZVllYXIgPSB0aGlzLl9kYXRlQWRhcHRlci5nZXRZZWFyKHRoaXMuX2FjdGl2ZURhdGUpO1xuICAgIGxldCBhY3RpdmVPZmZzZXQgPSBhY3RpdmVZZWFyICUgeWVhcnNQZXJQYWdlO1xuICAgIHRoaXMuX3llYXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIHJvdzogbnVtYmVyW10gPSBbXTsgaSA8IHllYXJzUGVyUGFnZTsgaSsrKSB7XG4gICAgICByb3cucHVzaChhY3RpdmVZZWFyIC0gYWN0aXZlT2Zmc2V0ICsgaSk7XG4gICAgICBpZiAocm93Lmxlbmd0aCA9PSB5ZWFyc1BlclJvdykge1xuICAgICAgICB0aGlzLl95ZWFycy5wdXNoKHJvdy5tYXAoeWVhciA9PiB0aGlzLl9jcmVhdGVDZWxsRm9yWWVhcih5ZWFyKSkpO1xuICAgICAgICByb3cgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gIH1cblxuICAvKiogSGFuZGxlcyB3aGVuIGEgbmV3IHllYXIgaXMgc2VsZWN0ZWQuICovXG4gIF95ZWFyU2VsZWN0ZWQoeWVhcjogbnVtYmVyKSB7XG4gICAgdGhpcy55ZWFyU2VsZWN0ZWQuZW1pdCh0aGlzLl9kYXRlQWRhcHRlci5jcmVhdGVEYXRlKHllYXIsIDAsIDEpKTtcbiAgICBsZXQgbW9udGggPSB0aGlzLl9kYXRlQWRhcHRlci5nZXRNb250aCh0aGlzLmFjdGl2ZURhdGUpO1xuICAgIGxldCBkYXlzSW5Nb250aCA9XG4gICAgICAgIHRoaXMuX2RhdGVBZGFwdGVyLmdldE51bURheXNJbk1vbnRoKHRoaXMuX2RhdGVBZGFwdGVyLmNyZWF0ZURhdGUoeWVhciwgbW9udGgsIDEpKTtcbiAgICB0aGlzLnNlbGVjdGVkQ2hhbmdlLmVtaXQodGhpcy5fZGF0ZUFkYXB0ZXIuY3JlYXRlRGF0ZSh5ZWFyLCBtb250aCxcbiAgICAgICAgTWF0aC5taW4odGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0RGF0ZSh0aGlzLmFjdGl2ZURhdGUpLCBkYXlzSW5Nb250aCkpKTtcbiAgfVxuXG4gIC8qKiBIYW5kbGVzIGtleWRvd24gZXZlbnRzIG9uIHRoZSBjYWxlbmRhciBib2R5IHdoZW4gY2FsZW5kYXIgaXMgaW4gbXVsdGkteWVhciB2aWV3LiAqL1xuICBfaGFuZGxlQ2FsZW5kYXJCb2R5S2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgIC8vIFRPRE8obW1hbGVyYmEpOiBXZSBjdXJyZW50bHkgYWxsb3cga2V5Ym9hcmQgbmF2aWdhdGlvbiB0byBkaXNhYmxlZCBkYXRlcywgYnV0IGp1c3QgcHJldmVudFxuICAgIC8vIGRpc2FibGVkIG9uZXMgZnJvbSBiZWluZyBzZWxlY3RlZC4gVGhpcyBtYXkgbm90IGJlIGlkZWFsLCB3ZSBzaG91bGQgbG9vayBpbnRvIHdoZXRoZXJcbiAgICAvLyBuYXZpZ2F0aW9uIHNob3VsZCBza2lwIG92ZXIgZGlzYWJsZWQgZGF0ZXMsIGFuZCBpZiBzbywgaG93IHRvIGltcGxlbWVudCB0aGF0IGVmZmljaWVudGx5LlxuXG4gICAgY29uc3Qgb2xkQWN0aXZlRGF0ZSA9IHRoaXMuX2FjdGl2ZURhdGU7XG4gICAgY29uc3QgaXNSdGwgPSB0aGlzLl9pc1J0bCgpO1xuXG4gICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICBjYXNlIExFRlRfQVJST1c6XG4gICAgICAgIHRoaXMuYWN0aXZlRGF0ZSA9IHRoaXMuX2RhdGVBZGFwdGVyLmFkZENhbGVuZGFyWWVhcnModGhpcy5fYWN0aXZlRGF0ZSwgaXNSdGwgPyAxIDogLTEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUklHSFRfQVJST1c6XG4gICAgICAgIHRoaXMuYWN0aXZlRGF0ZSA9IHRoaXMuX2RhdGVBZGFwdGVyLmFkZENhbGVuZGFyWWVhcnModGhpcy5fYWN0aXZlRGF0ZSwgaXNSdGwgPyAtMSA6IDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVVBfQVJST1c6XG4gICAgICAgIHRoaXMuYWN0aXZlRGF0ZSA9IHRoaXMuX2RhdGVBZGFwdGVyLmFkZENhbGVuZGFyWWVhcnModGhpcy5fYWN0aXZlRGF0ZSwgLXllYXJzUGVyUm93KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERPV05fQVJST1c6XG4gICAgICAgIHRoaXMuYWN0aXZlRGF0ZSA9IHRoaXMuX2RhdGVBZGFwdGVyLmFkZENhbGVuZGFyWWVhcnModGhpcy5fYWN0aXZlRGF0ZSwgeWVhcnNQZXJSb3cpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSE9NRTpcbiAgICAgICAgdGhpcy5hY3RpdmVEYXRlID0gdGhpcy5fZGF0ZUFkYXB0ZXIuYWRkQ2FsZW5kYXJZZWFycyh0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgICAgICAgLXRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXIodGhpcy5fYWN0aXZlRGF0ZSkgJSB5ZWFyc1BlclBhZ2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRU5EOlxuICAgICAgICB0aGlzLmFjdGl2ZURhdGUgPSB0aGlzLl9kYXRlQWRhcHRlci5hZGRDYWxlbmRhclllYXJzKHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICAgICAgICB5ZWFyc1BlclBhZ2UgLSB0aGlzLl9kYXRlQWRhcHRlci5nZXRZZWFyKHRoaXMuX2FjdGl2ZURhdGUpICUgeWVhcnNQZXJQYWdlIC0gMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQQUdFX1VQOlxuICAgICAgICB0aGlzLmFjdGl2ZURhdGUgPVxuICAgICAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIuYWRkQ2FsZW5kYXJZZWFycyhcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVEYXRlLCBldmVudC5hbHRLZXkgPyAteWVhcnNQZXJQYWdlICogMTAgOiAteWVhcnNQZXJQYWdlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBBR0VfRE9XTjpcbiAgICAgICAgdGhpcy5hY3RpdmVEYXRlID1cbiAgICAgICAgICAgIHRoaXMuX2RhdGVBZGFwdGVyLmFkZENhbGVuZGFyWWVhcnMoXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSwgZXZlbnQuYWx0S2V5ID8geWVhcnNQZXJQYWdlICogMTAgOiB5ZWFyc1BlclBhZ2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRU5URVI6XG4gICAgICAgIHRoaXMuX3llYXJTZWxlY3RlZCh0aGlzLl9kYXRlQWRhcHRlci5nZXRZZWFyKHRoaXMuX2FjdGl2ZURhdGUpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBEb24ndCBwcmV2ZW50IGRlZmF1bHQgb3IgZm9jdXMgYWN0aXZlIGNlbGwgb24ga2V5cyB0aGF0IHdlIGRvbid0IGV4cGxpY2l0bHkgaGFuZGxlLlxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RhdGVBZGFwdGVyLmNvbXBhcmVEYXRlKG9sZEFjdGl2ZURhdGUsIHRoaXMuYWN0aXZlRGF0ZSkpIHtcbiAgICAgIHRoaXMuYWN0aXZlRGF0ZUNoYW5nZS5lbWl0KHRoaXMuYWN0aXZlRGF0ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZm9jdXNBY3RpdmVDZWxsKCk7XG4gICAgLy8gUHJldmVudCB1bmV4cGVjdGVkIGRlZmF1bHQgYWN0aW9ucyBzdWNoIGFzIGZvcm0gc3VibWlzc2lvbi5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbiAgX2dldEFjdGl2ZUNlbGwoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhcih0aGlzLmFjdGl2ZURhdGUpICUgeWVhcnNQZXJQYWdlO1xuICB9XG5cbiAgLyoqIEZvY3VzZXMgdGhlIGFjdGl2ZSBjZWxsIGFmdGVyIHRoZSBtaWNyb3Rhc2sgcXVldWUgaXMgZW1wdHkuICovXG4gIF9mb2N1c0FjdGl2ZUNlbGwoKSB7XG4gICAgdGhpcy5fbWF0Q2FsZW5kYXJCb2R5Ll9mb2N1c0FjdGl2ZUNlbGwoKTtcbiAgfVxuXG4gIC8qKiBDcmVhdGVzIGFuIFNhdENhbGVuZGFyQ2VsbCBmb3IgdGhlIGdpdmVuIHllYXIuICovXG4gIHByaXZhdGUgX2NyZWF0ZUNlbGxGb3JZZWFyKHllYXI6IG51bWJlcikge1xuICAgIGxldCB5ZWFyTmFtZSA9IHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXJOYW1lKHRoaXMuX2RhdGVBZGFwdGVyLmNyZWF0ZURhdGUoeWVhciwgMCwgMSkpO1xuICAgIHJldHVybiBuZXcgU2F0Q2FsZW5kYXJDZWxsKHllYXIsIHllYXJOYW1lLCB5ZWFyTmFtZSwgdGhpcy5fc2hvdWxkRW5hYmxlWWVhcih5ZWFyKSk7XG4gIH1cblxuICAvKiogV2hldGhlciB0aGUgZ2l2ZW4geWVhciBpcyBlbmFibGVkLiAqL1xuICBwcml2YXRlIF9zaG91bGRFbmFibGVZZWFyKHllYXI6IG51bWJlcikge1xuICAgIC8vIGRpc2FibGUgaWYgdGhlIHllYXIgaXMgZ3JlYXRlciB0aGFuIG1heERhdGUgbG93ZXIgdGhhbiBtaW5EYXRlXG4gICAgaWYgKHllYXIgPT09IHVuZGVmaW5lZCB8fCB5ZWFyID09PSBudWxsIHx8XG4gICAgICAgICh0aGlzLm1heERhdGUgJiYgeWVhciA+IHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXIodGhpcy5tYXhEYXRlKSkgfHxcbiAgICAgICAgKHRoaXMubWluRGF0ZSAmJiB5ZWFyIDwgdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhcih0aGlzLm1pbkRhdGUpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGVuYWJsZSBpZiBpdCByZWFjaGVzIGhlcmUgYW5kIHRoZXJlJ3Mgbm8gZmlsdGVyIGRlZmluZWRcbiAgICBpZiAoIXRoaXMuZGF0ZUZpbHRlcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3RPZlllYXIgPSB0aGlzLl9kYXRlQWRhcHRlci5jcmVhdGVEYXRlKHllYXIsIDAsIDEpO1xuXG4gICAgLy8gSWYgYW55IGRhdGUgaW4gdGhlIHllYXIgaXMgZW5hYmxlZCBjb3VudCB0aGUgeWVhciBhcyBlbmFibGVkLlxuICAgIGZvciAobGV0IGRhdGUgPSBmaXJzdE9mWWVhcjsgdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhcihkYXRlKSA9PSB5ZWFyO1xuICAgICAgZGF0ZSA9IHRoaXMuX2RhdGVBZGFwdGVyLmFkZENhbGVuZGFyRGF5cyhkYXRlLCAxKSkge1xuICAgICAgaWYgKHRoaXMuZGF0ZUZpbHRlcihkYXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIG9iaiBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyBUaGUgZ2l2ZW4gb2JqZWN0IGlmIGl0IGlzIGJvdGggYSBkYXRlIGluc3RhbmNlIGFuZCB2YWxpZCwgb3RoZXJ3aXNlIG51bGwuXG4gICAqL1xuICBwcml2YXRlIF9nZXRWYWxpZERhdGVPck51bGwob2JqOiBhbnkpOiBEIHwgbnVsbCB7XG4gICAgcmV0dXJuICh0aGlzLl9kYXRlQWRhcHRlci5pc0RhdGVJbnN0YW5jZShvYmopICYmIHRoaXMuX2RhdGVBZGFwdGVyLmlzVmFsaWQob2JqKSkgPyBvYmogOiBudWxsO1xuICB9XG5cbiAgLyoqIERldGVybWluZXMgd2hldGhlciB0aGUgdXNlciBoYXMgdGhlIFJUTCBsYXlvdXQgZGlyZWN0aW9uLiAqL1xuICBwcml2YXRlIF9pc1J0bCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlyICYmIHRoaXMuX2Rpci52YWx1ZSA9PT0gJ3J0bCc7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge1xuICAgIERPV05fQVJST1csXG4gICAgRU5ELFxuICAgIEVOVEVSLFxuICAgIEhPTUUsXG4gICAgTEVGVF9BUlJPVyxcbiAgICBQQUdFX0RPV04sXG4gICAgUEFHRV9VUCxcbiAgICBSSUdIVF9BUlJPVyxcbiAgICBVUF9BUlJPVyxcbn0gZnJvbSAnQGFuZ3VsYXIvY2RrL2tleWNvZGVzJztcbmltcG9ydCB7XG4gICAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBDb21wb25lbnQsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBPcHRpb25hbCxcbiAgICBPdXRwdXQsXG4gICAgVmlld0NoaWxkLFxuICAgIFZpZXdFbmNhcHN1bGF0aW9uLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RGlyZWN0aW9uYWxpdHl9IGZyb20gJ0Bhbmd1bGFyL2Nkay9iaWRpJztcbmltcG9ydCB7U2F0Q2FsZW5kYXJCb2R5LCBTYXRDYWxlbmRhckNlbGx9IGZyb20gJy4vY2FsZW5kYXItYm9keSc7XG5pbXBvcnQge2NyZWF0ZU1pc3NpbmdEYXRlSW1wbEVycm9yfSBmcm9tICcuL2RhdGVwaWNrZXItZXJyb3JzJztcbmltcG9ydCB7RGF0ZUFkYXB0ZXJ9IGZyb20gJy4uL2RhdGV0aW1lL2RhdGUtYWRhcHRlcic7XG5pbXBvcnQge01BVF9EQVRFX0ZPUk1BVFMsIE1hdERhdGVGb3JtYXRzfSBmcm9tICcuLi9kYXRldGltZS9kYXRlLWZvcm1hdHMnO1xuXG4vKipcbiAqIEFuIGludGVybmFsIGNvbXBvbmVudCB1c2VkIHRvIGRpc3BsYXkgYSBzaW5nbGUgeWVhciBpbiB0aGUgZGF0ZXBpY2tlci5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xuQENvbXBvbmVudCh7XG4gIG1vZHVsZUlkOiBtb2R1bGUuaWQsXG4gIHNlbGVjdG9yOiAnc2F0LXllYXItdmlldycsXG4gIHRlbXBsYXRlVXJsOiAneWVhci12aWV3Lmh0bWwnLFxuICBleHBvcnRBczogJ21hdFllYXJWaWV3JyxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgU2F0WWVhclZpZXc8RD4gaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0IHtcbiAgLyoqIFRoZSBkYXRlIHRvIGRpc3BsYXkgaW4gdGhpcyB5ZWFyIHZpZXcgKGV2ZXJ5dGhpbmcgb3RoZXIgdGhhbiB0aGUgeWVhciBpcyBpZ25vcmVkKS4gKi9cbiAgQElucHV0KClcbiAgZ2V0IGFjdGl2ZURhdGUoKTogRCB7IHJldHVybiB0aGlzLl9hY3RpdmVEYXRlOyB9XG4gIHNldCBhY3RpdmVEYXRlKHZhbHVlOiBEKSB7XG4gICAgbGV0IG9sZEFjdGl2ZURhdGUgPSB0aGlzLl9hY3RpdmVEYXRlO1xuICAgIGNvbnN0IHZhbGlkRGF0ZSA9XG4gICAgICAgIHRoaXMuX2dldFZhbGlkRGF0ZU9yTnVsbCh0aGlzLl9kYXRlQWRhcHRlci5kZXNlcmlhbGl6ZSh2YWx1ZSkpIHx8IHRoaXMuX2RhdGVBZGFwdGVyLnRvZGF5KCk7XG4gICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHRoaXMuX2RhdGVBZGFwdGVyLmNsYW1wRGF0ZSh2YWxpZERhdGUsIHRoaXMubWluRGF0ZSwgdGhpcy5tYXhEYXRlKTtcbiAgICBpZiAodGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhcihvbGRBY3RpdmVEYXRlKSAhPT0gdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhcih0aGlzLl9hY3RpdmVEYXRlKSkge1xuICAgICAgdGhpcy5faW5pdCgpO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIF9hY3RpdmVEYXRlOiBEO1xuXG4gIC8qKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGRhdGUuICovXG4gIEBJbnB1dCgpXG4gIGdldCBzZWxlY3RlZCgpOiBEIHwgbnVsbCB7IHJldHVybiB0aGlzLl9zZWxlY3RlZDsgfVxuICBzZXQgc2VsZWN0ZWQodmFsdWU6IEQgfCBudWxsKSB7XG4gICAgdGhpcy5fc2VsZWN0ZWQgPSB0aGlzLl9nZXRWYWxpZERhdGVPck51bGwodGhpcy5fZGF0ZUFkYXB0ZXIuZGVzZXJpYWxpemUodmFsdWUpKTtcbiAgICB0aGlzLl9zZWxlY3RlZE1vbnRoID0gdGhpcy5fZ2V0TW9udGhJbkN1cnJlbnRZZWFyKHRoaXMuX3NlbGVjdGVkKTtcbiAgfVxuICBwcml2YXRlIF9zZWxlY3RlZDogRCB8IG51bGw7XG5cbiAgLyoqIFRoZSBtaW5pbXVtIHNlbGVjdGFibGUgZGF0ZS4gKi9cbiAgQElucHV0KClcbiAgZ2V0IG1pbkRhdGUoKTogRCB8IG51bGwgeyByZXR1cm4gdGhpcy5fbWluRGF0ZTsgfVxuICBzZXQgbWluRGF0ZSh2YWx1ZTogRCB8IG51bGwpIHtcbiAgICB0aGlzLl9taW5EYXRlID0gdGhpcy5fZ2V0VmFsaWREYXRlT3JOdWxsKHRoaXMuX2RhdGVBZGFwdGVyLmRlc2VyaWFsaXplKHZhbHVlKSk7XG4gIH1cbiAgcHJpdmF0ZSBfbWluRGF0ZTogRCB8IG51bGw7XG5cbiAgLyoqIFRoZSBtYXhpbXVtIHNlbGVjdGFibGUgZGF0ZS4gKi9cbiAgQElucHV0KClcbiAgZ2V0IG1heERhdGUoKTogRCB8IG51bGwgeyByZXR1cm4gdGhpcy5fbWF4RGF0ZTsgfVxuICBzZXQgbWF4RGF0ZSh2YWx1ZTogRCB8IG51bGwpIHtcbiAgICB0aGlzLl9tYXhEYXRlID0gdGhpcy5fZ2V0VmFsaWREYXRlT3JOdWxsKHRoaXMuX2RhdGVBZGFwdGVyLmRlc2VyaWFsaXplKHZhbHVlKSk7XG4gIH1cbiAgcHJpdmF0ZSBfbWF4RGF0ZTogRCB8IG51bGw7XG5cbiAgLyoqIEEgZnVuY3Rpb24gdXNlZCB0byBmaWx0ZXIgd2hpY2ggZGF0ZXMgYXJlIHNlbGVjdGFibGUuICovXG4gIEBJbnB1dCgpIGRhdGVGaWx0ZXI6IChkYXRlOiBEKSA9PiBib29sZWFuO1xuXG4gIC8qKiBFbWl0cyB3aGVuIGEgbmV3IG1vbnRoIGlzIHNlbGVjdGVkLiAqL1xuICBAT3V0cHV0KCkgcmVhZG9ubHkgc2VsZWN0ZWRDaGFuZ2U6IEV2ZW50RW1pdHRlcjxEPiA9IG5ldyBFdmVudEVtaXR0ZXI8RD4oKTtcblxuICAvKiogRW1pdHMgdGhlIHNlbGVjdGVkIG1vbnRoLiBUaGlzIGRvZXNuJ3QgaW1wbHkgYSBjaGFuZ2Ugb24gdGhlIHNlbGVjdGVkIGRhdGUgKi9cbiAgQE91dHB1dCgpIHJlYWRvbmx5IG1vbnRoU2VsZWN0ZWQ6IEV2ZW50RW1pdHRlcjxEPiA9IG5ldyBFdmVudEVtaXR0ZXI8RD4oKTtcblxuICAvKiogRW1pdHMgd2hlbiBhbnkgZGF0ZSBpcyBhY3RpdmF0ZWQuICovXG4gIEBPdXRwdXQoKSByZWFkb25seSBhY3RpdmVEYXRlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8RD4gPSBuZXcgRXZlbnRFbWl0dGVyPEQ+KCk7XG5cbiAgLyoqIFRoZSBib2R5IG9mIGNhbGVuZGFyIHRhYmxlICovXG4gIEBWaWV3Q2hpbGQoU2F0Q2FsZW5kYXJCb2R5KSBfbWF0Q2FsZW5kYXJCb2R5OiBTYXRDYWxlbmRhckJvZHk7XG5cbiAgLyoqIEdyaWQgb2YgY2FsZW5kYXIgY2VsbHMgcmVwcmVzZW50aW5nIHRoZSBtb250aHMgb2YgdGhlIHllYXIuICovXG4gIF9tb250aHM6IFNhdENhbGVuZGFyQ2VsbFtdW107XG5cbiAgLyoqIFRoZSBsYWJlbCBmb3IgdGhpcyB5ZWFyIChlLmcuIFwiMjAxN1wiKS4gKi9cbiAgX3llYXJMYWJlbDogc3RyaW5nO1xuXG4gIC8qKiBUaGUgbW9udGggaW4gdGhpcyB5ZWFyIHRoYXQgdG9kYXkgZmFsbHMgb24uIE51bGwgaWYgdG9kYXkgaXMgaW4gYSBkaWZmZXJlbnQgeWVhci4gKi9cbiAgX3RvZGF5TW9udGg6IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBtb250aCBpbiB0aGlzIHllYXIgdGhhdCB0aGUgc2VsZWN0ZWQgRGF0ZSBmYWxscyBvbi5cbiAgICogTnVsbCBpZiB0aGUgc2VsZWN0ZWQgRGF0ZSBpcyBpbiBhIGRpZmZlcmVudCB5ZWFyLlxuICAgKi9cbiAgX3NlbGVjdGVkTW9udGg6IG51bWJlciB8IG51bGw7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICAgICAgICBAT3B0aW9uYWwoKSBASW5qZWN0KE1BVF9EQVRFX0ZPUk1BVFMpIHByaXZhdGUgX2RhdGVGb3JtYXRzOiBNYXREYXRlRm9ybWF0cyxcbiAgICAgICAgICAgICAgQE9wdGlvbmFsKCkgcHVibGljIF9kYXRlQWRhcHRlcjogRGF0ZUFkYXB0ZXI8RD4sXG4gICAgICAgICAgICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX2Rpcj86IERpcmVjdGlvbmFsaXR5KSB7XG4gICAgaWYgKCF0aGlzLl9kYXRlQWRhcHRlcikge1xuICAgICAgdGhyb3cgY3JlYXRlTWlzc2luZ0RhdGVJbXBsRXJyb3IoJ0RhdGVBZGFwdGVyJyk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fZGF0ZUZvcm1hdHMpIHtcbiAgICAgIHRocm93IGNyZWF0ZU1pc3NpbmdEYXRlSW1wbEVycm9yKCdNQVRfREFURV9GT1JNQVRTJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHRoaXMuX2RhdGVBZGFwdGVyLnRvZGF5KCk7XG4gIH1cblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgdGhpcy5faW5pdCgpO1xuICB9XG5cbiAgLyoqIEhhbmRsZXMgd2hlbiBhIG5ldyBtb250aCBpcyBzZWxlY3RlZC4gKi9cbiAgX21vbnRoU2VsZWN0ZWQobW9udGg6IG51bWJlcikge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWREYXRlID1cbiAgICAgICAgICB0aGlzLl9kYXRlQWRhcHRlci5jcmVhdGVEYXRlKHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXIodGhpcy5hY3RpdmVEYXRlKSwgbW9udGgsIDEpO1xuXG4gICAgdGhpcy5tb250aFNlbGVjdGVkLmVtaXQobm9ybWFsaXplZERhdGUpO1xuXG4gICAgY29uc3QgZGF5c0luTW9udGggPSB0aGlzLl9kYXRlQWRhcHRlci5nZXROdW1EYXlzSW5Nb250aChub3JtYWxpemVkRGF0ZSk7XG5cbiAgICB0aGlzLnNlbGVjdGVkQ2hhbmdlLmVtaXQodGhpcy5fZGF0ZUFkYXB0ZXIuY3JlYXRlRGF0ZShcbiAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhcih0aGlzLmFjdGl2ZURhdGUpLCBtb250aCxcbiAgICAgICAgTWF0aC5taW4odGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0RGF0ZSh0aGlzLmFjdGl2ZURhdGUpLCBkYXlzSW5Nb250aCkpKTtcbiAgfVxuXG4gIC8qKiBIYW5kbGVzIGtleWRvd24gZXZlbnRzIG9uIHRoZSBjYWxlbmRhciBib2R5IHdoZW4gY2FsZW5kYXIgaXMgaW4geWVhciB2aWV3LiAqL1xuICBfaGFuZGxlQ2FsZW5kYXJCb2R5S2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgIC8vIFRPRE8obW1hbGVyYmEpOiBXZSBjdXJyZW50bHkgYWxsb3cga2V5Ym9hcmQgbmF2aWdhdGlvbiB0byBkaXNhYmxlZCBkYXRlcywgYnV0IGp1c3QgcHJldmVudFxuICAgIC8vIGRpc2FibGVkIG9uZXMgZnJvbSBiZWluZyBzZWxlY3RlZC4gVGhpcyBtYXkgbm90IGJlIGlkZWFsLCB3ZSBzaG91bGQgbG9vayBpbnRvIHdoZXRoZXJcbiAgICAvLyBuYXZpZ2F0aW9uIHNob3VsZCBza2lwIG92ZXIgZGlzYWJsZWQgZGF0ZXMsIGFuZCBpZiBzbywgaG93IHRvIGltcGxlbWVudCB0aGF0IGVmZmljaWVudGx5LlxuXG4gICAgY29uc3Qgb2xkQWN0aXZlRGF0ZSA9IHRoaXMuX2FjdGl2ZURhdGU7XG4gICAgY29uc3QgaXNSdGwgPSB0aGlzLl9pc1J0bCgpO1xuXG4gICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICBjYXNlIExFRlRfQVJST1c6XG4gICAgICAgIHRoaXMuYWN0aXZlRGF0ZSA9IHRoaXMuX2RhdGVBZGFwdGVyLmFkZENhbGVuZGFyTW9udGhzKHRoaXMuX2FjdGl2ZURhdGUsIGlzUnRsID8gMSA6IC0xKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFJJR0hUX0FSUk9XOlxuICAgICAgICB0aGlzLmFjdGl2ZURhdGUgPSB0aGlzLl9kYXRlQWRhcHRlci5hZGRDYWxlbmRhck1vbnRocyh0aGlzLl9hY3RpdmVEYXRlLCBpc1J0bCA/IC0xIDogMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBVUF9BUlJPVzpcbiAgICAgICAgdGhpcy5hY3RpdmVEYXRlID0gdGhpcy5fZGF0ZUFkYXB0ZXIuYWRkQ2FsZW5kYXJNb250aHModGhpcy5fYWN0aXZlRGF0ZSwgLTQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRE9XTl9BUlJPVzpcbiAgICAgICAgdGhpcy5hY3RpdmVEYXRlID0gdGhpcy5fZGF0ZUFkYXB0ZXIuYWRkQ2FsZW5kYXJNb250aHModGhpcy5fYWN0aXZlRGF0ZSwgNCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIT01FOlxuICAgICAgICB0aGlzLmFjdGl2ZURhdGUgPSB0aGlzLl9kYXRlQWRhcHRlci5hZGRDYWxlbmRhck1vbnRocyh0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgICAgICAgLXRoaXMuX2RhdGVBZGFwdGVyLmdldE1vbnRoKHRoaXMuX2FjdGl2ZURhdGUpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVORDpcbiAgICAgICAgdGhpcy5hY3RpdmVEYXRlID0gdGhpcy5fZGF0ZUFkYXB0ZXIuYWRkQ2FsZW5kYXJNb250aHModGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgICAgICAgIDExIC0gdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0TW9udGgodGhpcy5fYWN0aXZlRGF0ZSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUEFHRV9VUDpcbiAgICAgICAgdGhpcy5hY3RpdmVEYXRlID1cbiAgICAgICAgICAgIHRoaXMuX2RhdGVBZGFwdGVyLmFkZENhbGVuZGFyWWVhcnModGhpcy5fYWN0aXZlRGF0ZSwgZXZlbnQuYWx0S2V5ID8gLTEwIDogLTEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUEFHRV9ET1dOOlxuICAgICAgICB0aGlzLmFjdGl2ZURhdGUgPVxuICAgICAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIuYWRkQ2FsZW5kYXJZZWFycyh0aGlzLl9hY3RpdmVEYXRlLCBldmVudC5hbHRLZXkgPyAxMCA6IDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRU5URVI6XG4gICAgICAgIHRoaXMuX21vbnRoU2VsZWN0ZWQodGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0TW9udGgodGhpcy5fYWN0aXZlRGF0ZSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIERvbid0IHByZXZlbnQgZGVmYXVsdCBvciBmb2N1cyBhY3RpdmUgY2VsbCBvbiBrZXlzIHRoYXQgd2UgZG9uJ3QgZXhwbGljaXRseSBoYW5kbGUuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGF0ZUFkYXB0ZXIuY29tcGFyZURhdGUob2xkQWN0aXZlRGF0ZSwgdGhpcy5hY3RpdmVEYXRlKSkge1xuICAgICAgdGhpcy5hY3RpdmVEYXRlQ2hhbmdlLmVtaXQodGhpcy5hY3RpdmVEYXRlKTtcbiAgICB9XG5cbiAgICB0aGlzLl9mb2N1c0FjdGl2ZUNlbGwoKTtcbiAgICAvLyBQcmV2ZW50IHVuZXhwZWN0ZWQgZGVmYXVsdCBhY3Rpb25zIHN1Y2ggYXMgZm9ybSBzdWJtaXNzaW9uLlxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICAvKiogSW5pdGlhbGl6ZXMgdGhpcyB5ZWFyIHZpZXcuICovXG4gIF9pbml0KCkge1xuICAgIHRoaXMuX3NlbGVjdGVkTW9udGggPSB0aGlzLl9nZXRNb250aEluQ3VycmVudFllYXIodGhpcy5zZWxlY3RlZCk7XG4gICAgdGhpcy5fdG9kYXlNb250aCA9IHRoaXMuX2dldE1vbnRoSW5DdXJyZW50WWVhcih0aGlzLl9kYXRlQWRhcHRlci50b2RheSgpKTtcbiAgICB0aGlzLl95ZWFyTGFiZWwgPSB0aGlzLl9kYXRlQWRhcHRlci5nZXRZZWFyTmFtZSh0aGlzLmFjdGl2ZURhdGUpO1xuXG4gICAgbGV0IG1vbnRoTmFtZXMgPSB0aGlzLl9kYXRlQWRhcHRlci5nZXRNb250aE5hbWVzKCdzaG9ydCcpO1xuICAgIC8vIEZpcnN0IHJvdyBvZiBtb250aHMgb25seSBjb250YWlucyA1IGVsZW1lbnRzIHNvIHdlIGNhbiBmaXQgdGhlIHllYXIgbGFiZWwgb24gdGhlIHNhbWUgcm93LlxuICAgIHRoaXMuX21vbnRocyA9IFtbMCwgMSwgMiwgM10sIFs0LCA1LCA2LCA3XSwgWzgsIDksIDEwLCAxMV1dLm1hcChyb3cgPT4gcm93Lm1hcChcbiAgICAgICAgbW9udGggPT4gdGhpcy5fY3JlYXRlQ2VsbEZvck1vbnRoKG1vbnRoLCBtb250aE5hbWVzW21vbnRoXSkpKTtcbiAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuXG4gIC8qKiBGb2N1c2VzIHRoZSBhY3RpdmUgY2VsbCBhZnRlciB0aGUgbWljcm90YXNrIHF1ZXVlIGlzIGVtcHR5LiAqL1xuICBfZm9jdXNBY3RpdmVDZWxsKCkge1xuICAgIHRoaXMuX21hdENhbGVuZGFyQm9keS5fZm9jdXNBY3RpdmVDZWxsKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbW9udGggaW4gdGhpcyB5ZWFyIHRoYXQgdGhlIGdpdmVuIERhdGUgZmFsbHMgb24uXG4gICAqIFJldHVybnMgbnVsbCBpZiB0aGUgZ2l2ZW4gRGF0ZSBpcyBpbiBhbm90aGVyIHllYXIuXG4gICAqL1xuICBwcml2YXRlIF9nZXRNb250aEluQ3VycmVudFllYXIoZGF0ZTogRCB8IG51bGwpIHtcbiAgICByZXR1cm4gZGF0ZSAmJiB0aGlzLl9kYXRlQWRhcHRlci5nZXRZZWFyKGRhdGUpID09IHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXIodGhpcy5hY3RpdmVEYXRlKSA/XG4gICAgICAgIHRoaXMuX2RhdGVBZGFwdGVyLmdldE1vbnRoKGRhdGUpIDogbnVsbDtcbiAgfVxuXG4gIC8qKiBDcmVhdGVzIGFuIFNhdENhbGVuZGFyQ2VsbCBmb3IgdGhlIGdpdmVuIG1vbnRoLiAqL1xuICBwcml2YXRlIF9jcmVhdGVDZWxsRm9yTW9udGgobW9udGg6IG51bWJlciwgbW9udGhOYW1lOiBzdHJpbmcpIHtcbiAgICBsZXQgYXJpYUxhYmVsID0gdGhpcy5fZGF0ZUFkYXB0ZXIuZm9ybWF0KFxuICAgICAgICB0aGlzLl9kYXRlQWRhcHRlci5jcmVhdGVEYXRlKHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXIodGhpcy5hY3RpdmVEYXRlKSwgbW9udGgsIDEpLFxuICAgICAgICB0aGlzLl9kYXRlRm9ybWF0cy5kaXNwbGF5Lm1vbnRoWWVhckExMXlMYWJlbCk7XG4gICAgcmV0dXJuIG5ldyBTYXRDYWxlbmRhckNlbGwoXG4gICAgICAgIG1vbnRoLCBtb250aE5hbWUudG9Mb2NhbGVVcHBlckNhc2UoKSwgYXJpYUxhYmVsLCB0aGlzLl9zaG91bGRFbmFibGVNb250aChtb250aCkpO1xuICB9XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGdpdmVuIG1vbnRoIGlzIGVuYWJsZWQuICovXG4gIHByaXZhdGUgX3Nob3VsZEVuYWJsZU1vbnRoKG1vbnRoOiBudW1iZXIpIHtcblxuICAgIGNvbnN0IGFjdGl2ZVllYXIgPSB0aGlzLl9kYXRlQWRhcHRlci5nZXRZZWFyKHRoaXMuYWN0aXZlRGF0ZSk7XG5cbiAgICBpZiAobW9udGggPT09IHVuZGVmaW5lZCB8fCBtb250aCA9PT0gbnVsbCB8fFxuICAgICAgICB0aGlzLl9pc1llYXJBbmRNb250aEFmdGVyTWF4RGF0ZShhY3RpdmVZZWFyLCBtb250aCkgfHxcbiAgICAgICAgdGhpcy5faXNZZWFyQW5kTW9udGhCZWZvcmVNaW5EYXRlKGFjdGl2ZVllYXIsIG1vbnRoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5kYXRlRmlsdGVyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdE9mTW9udGggPSB0aGlzLl9kYXRlQWRhcHRlci5jcmVhdGVEYXRlKGFjdGl2ZVllYXIsIG1vbnRoLCAxKTtcblxuICAgIC8vIElmIGFueSBkYXRlIGluIHRoZSBtb250aCBpcyBlbmFibGVkIGNvdW50IHRoZSBtb250aCBhcyBlbmFibGVkLlxuICAgIGZvciAobGV0IGRhdGUgPSBmaXJzdE9mTW9udGg7IHRoaXMuX2RhdGVBZGFwdGVyLmdldE1vbnRoKGRhdGUpID09IG1vbnRoO1xuICAgICAgICAgZGF0ZSA9IHRoaXMuX2RhdGVBZGFwdGVyLmFkZENhbGVuZGFyRGF5cyhkYXRlLCAxKSkge1xuICAgICAgaWYgKHRoaXMuZGF0ZUZpbHRlcihkYXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogVGVzdHMgd2hldGhlciB0aGUgY29tYmluYXRpb24gbW9udGgveWVhciBpcyBhZnRlciB0aGlzLm1heERhdGUsIGNvbnNpZGVyaW5nXG4gICAqIGp1c3QgdGhlIG1vbnRoIGFuZCB5ZWFyIG9mIHRoaXMubWF4RGF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBfaXNZZWFyQW5kTW9udGhBZnRlck1heERhdGUoeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyKSB7XG4gICAgaWYgKHRoaXMubWF4RGF0ZSkge1xuICAgICAgY29uc3QgbWF4WWVhciA9IHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXIodGhpcy5tYXhEYXRlKTtcbiAgICAgIGNvbnN0IG1heE1vbnRoID0gdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0TW9udGgodGhpcy5tYXhEYXRlKTtcblxuICAgICAgcmV0dXJuIHllYXIgPiBtYXhZZWFyIHx8ICh5ZWFyID09PSBtYXhZZWFyICYmIG1vbnRoID4gbWF4TW9udGgpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0cyB3aGV0aGVyIHRoZSBjb21iaW5hdGlvbiBtb250aC95ZWFyIGlzIGJlZm9yZSB0aGlzLm1pbkRhdGUsIGNvbnNpZGVyaW5nXG4gICAqIGp1c3QgdGhlIG1vbnRoIGFuZCB5ZWFyIG9mIHRoaXMubWluRGF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBfaXNZZWFyQW5kTW9udGhCZWZvcmVNaW5EYXRlKHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlcikge1xuICAgIGlmICh0aGlzLm1pbkRhdGUpIHtcbiAgICAgIGNvbnN0IG1pblllYXIgPSB0aGlzLl9kYXRlQWRhcHRlci5nZXRZZWFyKHRoaXMubWluRGF0ZSk7XG4gICAgICBjb25zdCBtaW5Nb250aCA9IHRoaXMuX2RhdGVBZGFwdGVyLmdldE1vbnRoKHRoaXMubWluRGF0ZSk7XG5cbiAgICAgIHJldHVybiB5ZWFyIDwgbWluWWVhciB8fCAoeWVhciA9PT0gbWluWWVhciAmJiBtb250aCA8IG1pbk1vbnRoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIG9iaiBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyBUaGUgZ2l2ZW4gb2JqZWN0IGlmIGl0IGlzIGJvdGggYSBkYXRlIGluc3RhbmNlIGFuZCB2YWxpZCwgb3RoZXJ3aXNlIG51bGwuXG4gICAqL1xuICBwcml2YXRlIF9nZXRWYWxpZERhdGVPck51bGwob2JqOiBhbnkpOiBEIHwgbnVsbCB7XG4gICAgcmV0dXJuICh0aGlzLl9kYXRlQWRhcHRlci5pc0RhdGVJbnN0YW5jZShvYmopICYmIHRoaXMuX2RhdGVBZGFwdGVyLmlzVmFsaWQob2JqKSkgPyBvYmogOiBudWxsO1xuICB9XG5cbiAgLyoqIERldGVybWluZXMgd2hldGhlciB0aGUgdXNlciBoYXMgdGhlIFJUTCBsYXlvdXQgZGlyZWN0aW9uLiAqL1xuICBwcml2YXRlIF9pc1J0bCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlyICYmIHRoaXMuX2Rpci52YWx1ZSA9PT0gJ3J0bCc7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge0NvbXBvbmVudFBvcnRhbCwgQ29tcG9uZW50VHlwZSwgUG9ydGFsfSBmcm9tICdAYW5ndWxhci9jZGsvcG9ydGFsJztcbmltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIEFmdGVyVmlld0NoZWNrZWQsXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgQ29tcG9uZW50LFxuICBFdmVudEVtaXR0ZXIsXG4gIGZvcndhcmRSZWYsXG4gIEluamVjdCxcbiAgSW5wdXQsXG4gIE9uQ2hhbmdlcyxcbiAgT25EZXN0cm95LFxuICBPcHRpb25hbCxcbiAgT3V0cHV0LFxuICBTaW1wbGVDaGFuZ2VzLFxuICBWaWV3Q2hpbGQsXG4gIFZpZXdFbmNhcHN1bGF0aW9uLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7U3ViamVjdCwgU3Vic2NyaXB0aW9ufSBmcm9tICdyeGpzJztcbmltcG9ydCB7Y3JlYXRlTWlzc2luZ0RhdGVJbXBsRXJyb3J9IGZyb20gJy4vZGF0ZXBpY2tlci1lcnJvcnMnO1xuaW1wb3J0IHtTYXREYXRlcGlja2VySW50bH0gZnJvbSAnLi9kYXRlcGlja2VyLWludGwnO1xuaW1wb3J0IHtTYXRNb250aFZpZXd9IGZyb20gJy4vbW9udGgtdmlldyc7XG5pbXBvcnQge1NhdE11bHRpWWVhclZpZXcsIHllYXJzUGVyUGFnZX0gZnJvbSAnLi9tdWx0aS15ZWFyLXZpZXcnO1xuaW1wb3J0IHtTYXRZZWFyVmlld30gZnJvbSAnLi95ZWFyLXZpZXcnO1xuXG5pbXBvcnQge1NhdERhdGVwaWNrZXJSYW5nZVZhbHVlfSBmcm9tICcuL2RhdGVwaWNrZXItaW5wdXQnO1xuaW1wb3J0IHtEYXRlQWRhcHRlcn0gZnJvbSAnLi4vZGF0ZXRpbWUvZGF0ZS1hZGFwdGVyJztcbmltcG9ydCB7TUFUX0RBVEVfRk9STUFUUywgTWF0RGF0ZUZvcm1hdHN9IGZyb20gJy4uL2RhdGV0aW1lL2RhdGUtZm9ybWF0cyc7XG5cbi8qKlxuICogUG9zc2libGUgdmlld3MgZm9yIHRoZSBjYWxlbmRhci5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xuZXhwb3J0IHR5cGUgU2F0Q2FsZW5kYXJWaWV3ID0gJ21vbnRoJyB8ICd5ZWFyJyB8ICdtdWx0aS15ZWFyJztcblxuLyoqIERlZmF1bHQgaGVhZGVyIGZvciBTYXRDYWxlbmRhciAqL1xuQENvbXBvbmVudCh7XG4gIG1vZHVsZUlkOiBtb2R1bGUuaWQsXG4gIHNlbGVjdG9yOiAnc2F0LWNhbGVuZGFyLWhlYWRlcicsXG4gIHRlbXBsYXRlVXJsOiAnY2FsZW5kYXItaGVhZGVyLmh0bWwnLFxuICBleHBvcnRBczogJ21hdENhbGVuZGFySGVhZGVyJyxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG59KVxuZXhwb3J0IGNsYXNzIFNhdENhbGVuZGFySGVhZGVyPEQ+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfaW50bDogU2F0RGF0ZXBpY2tlckludGwsXG4gICAgICAgICAgICAgIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBTYXRDYWxlbmRhcikpIHB1YmxpYyBjYWxlbmRhcjogU2F0Q2FsZW5kYXI8RD4sXG4gICAgICAgICAgICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX2RhdGVBZGFwdGVyOiBEYXRlQWRhcHRlcjxEPixcbiAgICAgICAgICAgICAgQE9wdGlvbmFsKCkgQEluamVjdChNQVRfREFURV9GT1JNQVRTKSBwcml2YXRlIF9kYXRlRm9ybWF0czogTWF0RGF0ZUZvcm1hdHMsXG4gICAgICAgICAgICAgIGNoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZikge1xuXG4gICAgdGhpcy5jYWxlbmRhci5zdGF0ZUNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IGNoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpKTtcbiAgfVxuXG4gIC8qKiBUaGUgbGFiZWwgZm9yIHRoZSBjdXJyZW50IGNhbGVuZGFyIHZpZXcuICovXG4gIGdldCBwZXJpb2RCdXR0b25UZXh0KCk6IHN0cmluZyB7XG4gICAgaWYgKHRoaXMuY2FsZW5kYXIuY3VycmVudFZpZXcgPT0gJ21vbnRoJykge1xuICAgICAgcmV0dXJuIHRoaXMuX2RhdGVBZGFwdGVyXG4gICAgICAgICAgLmZvcm1hdCh0aGlzLmNhbGVuZGFyLmFjdGl2ZURhdGUsIHRoaXMuX2RhdGVGb3JtYXRzLmRpc3BsYXkubW9udGhZZWFyTGFiZWwpXG4gICAgICAgICAgICAgIC50b0xvY2FsZVVwcGVyQ2FzZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jYWxlbmRhci5jdXJyZW50VmlldyA9PSAneWVhcicpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kYXRlQWRhcHRlci5nZXRZZWFyTmFtZSh0aGlzLmNhbGVuZGFyLmFjdGl2ZURhdGUpO1xuICAgIH1cbiAgICBjb25zdCBhY3RpdmVZZWFyID0gdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhcih0aGlzLmNhbGVuZGFyLmFjdGl2ZURhdGUpO1xuICAgIGNvbnN0IGZpcnN0WWVhckluVmlldyA9IHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXJOYW1lKFxuICAgICAgICB0aGlzLl9kYXRlQWRhcHRlci5jcmVhdGVEYXRlKGFjdGl2ZVllYXIgLSBhY3RpdmVZZWFyICUgMjQsIDAsIDEpKTtcbiAgICBjb25zdCBsYXN0WWVhckluVmlldyA9IHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXJOYW1lKFxuICAgICAgICB0aGlzLl9kYXRlQWRhcHRlci5jcmVhdGVEYXRlKGFjdGl2ZVllYXIgKyB5ZWFyc1BlclBhZ2UgLSAxIC0gYWN0aXZlWWVhciAlIDI0LCAwLCAxKSk7XG4gICAgcmV0dXJuIGAke2ZpcnN0WWVhckluVmlld30gXFx1MjAxMyAke2xhc3RZZWFySW5WaWV3fWA7XG4gIH1cblxuICBnZXQgcGVyaW9kQnV0dG9uTGFiZWwoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5jYWxlbmRhci5jdXJyZW50VmlldyA9PSAnbW9udGgnID9cbiAgICAgICAgdGhpcy5faW50bC5zd2l0Y2hUb011bHRpWWVhclZpZXdMYWJlbCA6IHRoaXMuX2ludGwuc3dpdGNoVG9Nb250aFZpZXdMYWJlbDtcbiAgfVxuXG4gIC8qKiBUaGUgbGFiZWwgZm9yIHRoZSB0aGUgcHJldmlvdXMgYnV0dG9uLiAqL1xuICBnZXQgcHJldkJ1dHRvbkxhYmVsKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdtb250aCc6IHRoaXMuX2ludGwucHJldk1vbnRoTGFiZWwsXG4gICAgICAneWVhcic6IHRoaXMuX2ludGwucHJldlllYXJMYWJlbCxcbiAgICAgICdtdWx0aS15ZWFyJzogdGhpcy5faW50bC5wcmV2TXVsdGlZZWFyTGFiZWxcbiAgICB9W3RoaXMuY2FsZW5kYXIuY3VycmVudFZpZXddO1xuICB9XG5cbiAgLyoqIFRoZSBsYWJlbCBmb3IgdGhlIHRoZSBuZXh0IGJ1dHRvbi4gKi9cbiAgZ2V0IG5leHRCdXR0b25MYWJlbCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB7XG4gICAgICAnbW9udGgnOiB0aGlzLl9pbnRsLm5leHRNb250aExhYmVsLFxuICAgICAgJ3llYXInOiB0aGlzLl9pbnRsLm5leHRZZWFyTGFiZWwsXG4gICAgICAnbXVsdGkteWVhcic6IHRoaXMuX2ludGwubmV4dE11bHRpWWVhckxhYmVsXG4gICAgfVt0aGlzLmNhbGVuZGFyLmN1cnJlbnRWaWV3XTtcbiAgfVxuXG4gIC8qKiBIYW5kbGVzIHVzZXIgY2xpY2tzIG9uIHRoZSBwZXJpb2QgbGFiZWwuXG4gICAqIE9wdGlvbmBjYWxlbmRhci5vcmRlclBlcmlvZExhYmVsYCBzb3J0IHRoZSBsYWJlbCBwZXJpb2Qgdmlld3MuXG4gICAqIC0gRGVmYXVsdCBbbXVsdGkteWVhcl06IG11bHRpLXllYXIgdGhlbiBiYWNrIHRvIG1vbnRoXG4gICAqIC0gTW9udGggW21vbnRoXTogbW9udGggPiB5ZWFyID4gbXVsdGkteWVhclxuICAgKi9cbiAgY3VycmVudFBlcmlvZENsaWNrZWQoKTogdm9pZCB7XG4gICAgY29uc3QgbW91dGhGaXJzdE9yZGVyOiBTYXRDYWxlbmRhclZpZXdbXSA9IFsnbW9udGgnLCAneWVhcicsICdtdWx0aS15ZWFyJ107XG4gICAgY29uc3QgZGVmYXVsdE9yZGVyOiBTYXRDYWxlbmRhclZpZXdbXSA9IFsnbW9udGgnLCAnbXVsdGkteWVhcicsICdtb250aCddO1xuICAgIGNvbnN0IG9yZGVyUGVyaW9kID0gdGhpcy5jYWxlbmRhci5vcmRlclBlcmlvZExhYmVsID09PSAnbW9udGgnID8gbW91dGhGaXJzdE9yZGVyIDogZGVmYXVsdE9yZGVyO1xuICAgIHN3aXRjaCAodGhpcy5jYWxlbmRhci5jdXJyZW50Vmlldykge1xuICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICB0aGlzLmNhbGVuZGFyLmN1cnJlbnRWaWV3ID0gb3JkZXJQZXJpb2RbMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgdGhpcy5jYWxlbmRhci5jdXJyZW50VmlldyA9IG9yZGVyUGVyaW9kWzJdXG4gICAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmNhbGVuZGFyLmN1cnJlbnRWaWV3ID0gb3JkZXJQZXJpb2RbMF1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLyoqIEhhbmRsZXMgdXNlciBjbGlja3Mgb24gdGhlIHByZXZpb3VzIGJ1dHRvbi4gKi9cbiAgcHJldmlvdXNDbGlja2VkKCk6IHZvaWQge1xuICAgIHRoaXMuY2FsZW5kYXIuYWN0aXZlRGF0ZSA9IHRoaXMuY2FsZW5kYXIuY3VycmVudFZpZXcgPT0gJ21vbnRoJyA/XG4gICAgICAgIHRoaXMuX2RhdGVBZGFwdGVyLmFkZENhbGVuZGFyTW9udGhzKHRoaXMuY2FsZW5kYXIuYWN0aXZlRGF0ZSwgLTEpIDpcbiAgICAgICAgICAgIHRoaXMuX2RhdGVBZGFwdGVyLmFkZENhbGVuZGFyWWVhcnMoXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxlbmRhci5hY3RpdmVEYXRlLCB0aGlzLmNhbGVuZGFyLmN1cnJlbnRWaWV3ID09ICd5ZWFyJyA/IC0xIDogLXllYXJzUGVyUGFnZVxuICAgICAgICAgICAgKTtcbiAgfVxuXG4gIC8qKiBIYW5kbGVzIHVzZXIgY2xpY2tzIG9uIHRoZSBuZXh0IGJ1dHRvbi4gKi9cbiAgbmV4dENsaWNrZWQoKTogdm9pZCB7XG4gICAgdGhpcy5jYWxlbmRhci5hY3RpdmVEYXRlID0gdGhpcy5jYWxlbmRhci5jdXJyZW50VmlldyA9PSAnbW9udGgnID9cbiAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIuYWRkQ2FsZW5kYXJNb250aHModGhpcy5jYWxlbmRhci5hY3RpdmVEYXRlLCAxKSA6XG4gICAgICAgICAgICB0aGlzLl9kYXRlQWRhcHRlci5hZGRDYWxlbmRhclllYXJzKFxuICAgICAgICAgICAgICAgIHRoaXMuY2FsZW5kYXIuYWN0aXZlRGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxlbmRhci5jdXJyZW50VmlldyA9PSAneWVhcicgPyAxIDogeWVhcnNQZXJQYWdlXG4gICAgICAgICAgICApO1xuICB9XG5cbiAgLyoqIFdoZXRoZXIgdGhlIHByZXZpb3VzIHBlcmlvZCBidXR0b24gaXMgZW5hYmxlZC4gKi9cbiAgcHJldmlvdXNFbmFibGVkKCk6IGJvb2xlYW4ge1xuICAgIGlmICghdGhpcy5jYWxlbmRhci5taW5EYXRlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuICF0aGlzLmNhbGVuZGFyLm1pbkRhdGUgfHxcbiAgICAgICAgIXRoaXMuX2lzU2FtZVZpZXcodGhpcy5jYWxlbmRhci5hY3RpdmVEYXRlLCB0aGlzLmNhbGVuZGFyLm1pbkRhdGUpO1xuICB9XG5cbiAgLyoqIFdoZXRoZXIgdGhlIG5leHQgcGVyaW9kIGJ1dHRvbiBpcyBlbmFibGVkLiAqL1xuICBuZXh0RW5hYmxlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIXRoaXMuY2FsZW5kYXIubWF4RGF0ZSB8fFxuICAgICAgICAhdGhpcy5faXNTYW1lVmlldyh0aGlzLmNhbGVuZGFyLmFjdGl2ZURhdGUsIHRoaXMuY2FsZW5kYXIubWF4RGF0ZSk7XG4gIH1cblxuICAvKiogV2hldGhlciB0aGUgdHdvIGRhdGVzIHJlcHJlc2VudCB0aGUgc2FtZSB2aWV3IGluIHRoZSBjdXJyZW50IHZpZXcgbW9kZSAobW9udGggb3IgeWVhcikuICovXG4gIHByaXZhdGUgX2lzU2FtZVZpZXcoZGF0ZTE6IEQsIGRhdGUyOiBEKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuY2FsZW5kYXIuY3VycmVudFZpZXcgPT0gJ21vbnRoJykge1xuICAgICAgcmV0dXJuIHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXIoZGF0ZTEpID09IHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXIoZGF0ZTIpICYmXG4gICAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0TW9udGgoZGF0ZTEpID09IHRoaXMuX2RhdGVBZGFwdGVyLmdldE1vbnRoKGRhdGUyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2FsZW5kYXIuY3VycmVudFZpZXcgPT0gJ3llYXInKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhcihkYXRlMSkgPT0gdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhcihkYXRlMik7XG4gICAgfVxuICAgIC8vIE90aGVyd2lzZSB3ZSBhcmUgaW4gJ211bHRpLXllYXInIHZpZXcuXG4gICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhcihkYXRlMSkgLyB5ZWFyc1BlclBhZ2UpID09XG4gICAgICAgIE1hdGguZmxvb3IodGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhcihkYXRlMikgLyB5ZWFyc1BlclBhZ2UpO1xuICB9XG59XG5cbi8qKlxuICogQSBjYWxlbmRhciB0aGF0IGlzIHVzZWQgYXMgcGFydCBvZiB0aGUgZGF0ZXBpY2tlci5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xuQENvbXBvbmVudCh7XG4gIG1vZHVsZUlkOiBtb2R1bGUuaWQsXG4gIHNlbGVjdG9yOiAnc2F0LWNhbGVuZGFyJyxcbiAgdGVtcGxhdGVVcmw6ICdjYWxlbmRhci5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJ2NhbGVuZGFyLmNzcyddLFxuICBob3N0OiB7XG4gICAgJ2NsYXNzJzogJ21hdC1jYWxlbmRhcicsXG4gIH0sXG4gIGV4cG9ydEFzOiAnbWF0Q2FsZW5kYXInLFxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbn0pXG5leHBvcnQgY2xhc3MgU2F0Q2FsZW5kYXI8RD4gaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBBZnRlclZpZXdDaGVja2VkLCBPbkRlc3Ryb3ksIE9uQ2hhbmdlcyB7XG5cbiAgICAvKiogQmVnaW5uaW5nIG9mIGRhdGUgcmFuZ2UuICovXG4gICAgQElucHV0KClcbiAgICBnZXQgYmVnaW5EYXRlKCk6IEQgfCBudWxsIHsgcmV0dXJuIHRoaXMuX2JlZ2luRGF0ZTsgfVxuICAgIHNldCBiZWdpbkRhdGUodmFsdWU6IEQgfCBudWxsKSB7XG4gICAgICAgIHRoaXMuX2JlZ2luRGF0ZSA9IHRoaXMuX2dldFZhbGlkRGF0ZU9yTnVsbCh0aGlzLl9kYXRlQWRhcHRlci5kZXNlcmlhbGl6ZSh2YWx1ZSkpO1xuICAgIH1cbiAgICBwcml2YXRlIF9iZWdpbkRhdGU6IEQgfCBudWxsO1xuXG4gICAgLyoqIERhdGUgcmFuZ2UgZW5kLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgZ2V0IGVuZERhdGUoKTogRCB8IG51bGwgeyByZXR1cm4gdGhpcy5fZW5kRGF0ZTsgfVxuICAgIHNldCBlbmREYXRlKHZhbHVlOiBEIHwgbnVsbCkge1xuICAgICAgICB0aGlzLl9lbmREYXRlID0gdGhpcy5fZ2V0VmFsaWREYXRlT3JOdWxsKHRoaXMuX2RhdGVBZGFwdGVyLmRlc2VyaWFsaXplKHZhbHVlKSk7XG4gICAgfVxuICAgIHByaXZhdGUgX2VuZERhdGU6IEQgfCBudWxsO1xuXG4gICAgLyoqIFdoZW5ldmVyIGRhdGVwaWNrZXIgaXMgZm9yIHNlbGVjdGluZyByYW5nZSBvZiBkYXRlcy4gKi9cbiAgICBASW5wdXQoKSByYW5nZU1vZGUgPSBmYWxzZTtcblxuICAgIC8qKiBFbWl0cyB3aGVuIG5ldyBwYWlyIG9mIGRhdGVzIHNlbGVjdGVkLiAqL1xuICAgIEBPdXRwdXQoKSBkYXRlUmFuZ2VzQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxTYXREYXRlcGlja2VyUmFuZ2VWYWx1ZTxEPj4oKTtcblxuXG4gICAgLyoqIFdoZW5ldmVyIHVzZXIgYWxyZWFkeSBzZWxlY3RlZCBzdGFydCBvZiBkYXRlcyBpbnRlcnZhbC4gKi9cbiAgICBwcml2YXRlIF9iZWdpbkRhdGVTZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgLyoqIEFuIGlucHV0IGluZGljYXRpbmcgdGhlIHR5cGUgb2YgdGhlIGhlYWRlciBjb21wb25lbnQsIGlmIHNldC4gKi9cbiAgQElucHV0KCkgaGVhZGVyQ29tcG9uZW50OiBDb21wb25lbnRUeXBlPGFueT47XG5cbiAgLyoqIEEgcG9ydGFsIGNvbnRhaW5pbmcgdGhlIGhlYWRlciBjb21wb25lbnQgdHlwZSBmb3IgdGhpcyBjYWxlbmRhci4gKi9cbiAgX2NhbGVuZGFySGVhZGVyUG9ydGFsOiBQb3J0YWw8YW55PjtcblxuICBwcml2YXRlIF9pbnRsQ2hhbmdlczogU3Vic2NyaXB0aW9uO1xuXG4gIC8qKlxuICAgKiBVc2VkIGZvciBzY2hlZHVsaW5nIHRoYXQgZm9jdXMgc2hvdWxkIGJlIG1vdmVkIHRvIHRoZSBhY3RpdmUgY2VsbCBvbiB0aGUgbmV4dCB0aWNrLlxuICAgKiBXZSBuZWVkIHRvIHNjaGVkdWxlIGl0LCByYXRoZXIgdGhhbiBkbyBpdCBpbW1lZGlhdGVseSwgYmVjYXVzZSB3ZSBoYXZlIHRvIHdhaXRcbiAgICogZm9yIEFuZ3VsYXIgdG8gcmUtZXZhbHVhdGUgdGhlIHZpZXcgY2hpbGRyZW4uXG4gICAqL1xuICBwcml2YXRlIF9tb3ZlRm9jdXNPbk5leHRUaWNrID0gZmFsc2U7XG5cbiAgLyoqIEEgZGF0ZSByZXByZXNlbnRpbmcgdGhlIHBlcmlvZCAobW9udGggb3IgeWVhcikgdG8gc3RhcnQgdGhlIGNhbGVuZGFyIGluLiAqL1xuICBASW5wdXQoKVxuICBnZXQgc3RhcnRBdCgpOiBEIHwgbnVsbCB7IHJldHVybiB0aGlzLl9zdGFydEF0OyB9XG4gIHNldCBzdGFydEF0KHZhbHVlOiBEIHwgbnVsbCkge1xuICAgIHRoaXMuX3N0YXJ0QXQgPSB0aGlzLl9nZXRWYWxpZERhdGVPck51bGwodGhpcy5fZGF0ZUFkYXB0ZXIuZGVzZXJpYWxpemUodmFsdWUpKTtcbiAgfVxuICBwcml2YXRlIF9zdGFydEF0OiBEIHwgbnVsbDtcblxuICAvKiogV2hldGhlciB0aGUgY2FsZW5kYXIgc2hvdWxkIGJlIHN0YXJ0ZWQgaW4gbW9udGggb3IgeWVhciB2aWV3LiAqL1xuICBASW5wdXQoKSBzdGFydFZpZXc6IFNhdENhbGVuZGFyVmlldyA9ICdtb250aCc7XG5cbiAgLyoqIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZGF0ZS4gKi9cbiAgQElucHV0KClcbiAgZ2V0IHNlbGVjdGVkKCk6IEQgfCBudWxsIHsgcmV0dXJuIHRoaXMuX3NlbGVjdGVkOyB9XG4gIHNldCBzZWxlY3RlZCh2YWx1ZTogRCB8IG51bGwpIHtcbiAgICB0aGlzLl9zZWxlY3RlZCA9IHRoaXMuX2dldFZhbGlkRGF0ZU9yTnVsbCh0aGlzLl9kYXRlQWRhcHRlci5kZXNlcmlhbGl6ZSh2YWx1ZSkpO1xuICB9XG4gIHByaXZhdGUgX3NlbGVjdGVkOiBEIHwgbnVsbDtcblxuICAvKiogVGhlIG1pbmltdW0gc2VsZWN0YWJsZSBkYXRlLiAqL1xuICBASW5wdXQoKVxuICBnZXQgbWluRGF0ZSgpOiBEIHwgbnVsbCB7IHJldHVybiB0aGlzLl9taW5EYXRlOyB9XG4gIHNldCBtaW5EYXRlKHZhbHVlOiBEIHwgbnVsbCkge1xuICAgIHRoaXMuX21pbkRhdGUgPSB0aGlzLl9nZXRWYWxpZERhdGVPck51bGwodGhpcy5fZGF0ZUFkYXB0ZXIuZGVzZXJpYWxpemUodmFsdWUpKTtcbiAgfVxuICBwcml2YXRlIF9taW5EYXRlOiBEIHwgbnVsbDtcblxuICAvKiogVGhlIG1heGltdW0gc2VsZWN0YWJsZSBkYXRlLiAqL1xuICBASW5wdXQoKVxuICBnZXQgbWF4RGF0ZSgpOiBEIHwgbnVsbCB7IHJldHVybiB0aGlzLl9tYXhEYXRlOyB9XG4gIHNldCBtYXhEYXRlKHZhbHVlOiBEIHwgbnVsbCkge1xuICAgIHRoaXMuX21heERhdGUgPSB0aGlzLl9nZXRWYWxpZERhdGVPck51bGwodGhpcy5fZGF0ZUFkYXB0ZXIuZGVzZXJpYWxpemUodmFsdWUpKTtcbiAgfVxuICBwcml2YXRlIF9tYXhEYXRlOiBEIHwgbnVsbDtcblxuICAvKiogQSBmdW5jdGlvbiB1c2VkIHRvIGZpbHRlciB3aGljaCBkYXRlcyBhcmUgc2VsZWN0YWJsZS4gKi9cbiAgQElucHV0KCkgZGF0ZUZpbHRlcjogKGRhdGU6IEQpID0+IGJvb2xlYW47XG5cbiAgLyoqIE9yZGVyIHRoZSB2aWV3cyB3aGVuIGNsaWNraW5nIG9uIHBlcmlvZCBsYWJlbCBidXR0b24gKi9cbiAgQElucHV0KCkgb3JkZXJQZXJpb2RMYWJlbDogJ211bHRpLXllYXInIHwgJ21vbnRoJyA9ICdtdWx0aS15ZWFyJztcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGRhdGUgY2hhbmdlcy4gKi9cbiAgQE91dHB1dCgpIHJlYWRvbmx5IHNlbGVjdGVkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8RD4gPSBuZXcgRXZlbnRFbWl0dGVyPEQ+KCk7XG5cbiAgLyoqXG4gICAqIEVtaXRzIHRoZSB5ZWFyIGNob3NlbiBpbiBtdWx0aXllYXIgdmlldy5cbiAgICogVGhpcyBkb2Vzbid0IGltcGx5IGEgY2hhbmdlIG9uIHRoZSBzZWxlY3RlZCBkYXRlLlxuICAgKi9cbiAgQE91dHB1dCgpIHJlYWRvbmx5IHllYXJTZWxlY3RlZDogRXZlbnRFbWl0dGVyPEQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxEPigpO1xuXG4gIC8qKlxuICAgKiBFbWl0cyB0aGUgbW9udGggY2hvc2VuIGluIHllYXIgdmlldy5cbiAgICogVGhpcyBkb2Vzbid0IGltcGx5IGEgY2hhbmdlIG9uIHRoZSBzZWxlY3RlZCBkYXRlLlxuICAgKi9cbiAgQE91dHB1dCgpIHJlYWRvbmx5IG1vbnRoU2VsZWN0ZWQ6IEV2ZW50RW1pdHRlcjxEPiA9IG5ldyBFdmVudEVtaXR0ZXI8RD4oKTtcblxuICAvKiogRW1pdHMgd2hlbiBhbnkgZGF0ZSBpcyBzZWxlY3RlZC4gKi9cbiAgQE91dHB1dCgpIHJlYWRvbmx5IF91c2VyU2VsZWN0aW9uOiBFdmVudEVtaXR0ZXI8dm9pZD4gPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBtb250aCB2aWV3IGNvbXBvbmVudC4gKi9cbiAgQFZpZXdDaGlsZChTYXRNb250aFZpZXcpIG1vbnRoVmlldzogU2F0TW9udGhWaWV3PEQ+O1xuXG4gIC8qKiBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgeWVhciB2aWV3IGNvbXBvbmVudC4gKi9cbiAgQFZpZXdDaGlsZChTYXRZZWFyVmlldykgeWVhclZpZXc6IFNhdFllYXJWaWV3PEQ+O1xuXG4gIC8qKiBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgbXVsdGkteWVhciB2aWV3IGNvbXBvbmVudC4gKi9cbiAgQFZpZXdDaGlsZChTYXRNdWx0aVllYXJWaWV3KSBtdWx0aVllYXJWaWV3OiBTYXRNdWx0aVllYXJWaWV3PEQ+O1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBhY3RpdmUgZGF0ZS4gVGhpcyBkZXRlcm1pbmVzIHdoaWNoIHRpbWUgcGVyaW9kIGlzIHNob3duIGFuZCB3aGljaCBkYXRlIGlzXG4gICAqIGhpZ2hsaWdodGVkIHdoZW4gdXNpbmcga2V5Ym9hcmQgbmF2aWdhdGlvbi5cbiAgICovXG4gIGdldCBhY3RpdmVEYXRlKCk6IEQgeyByZXR1cm4gdGhpcy5fY2xhbXBlZEFjdGl2ZURhdGU7IH1cbiAgc2V0IGFjdGl2ZURhdGUodmFsdWU6IEQpIHtcbiAgICB0aGlzLl9jbGFtcGVkQWN0aXZlRGF0ZSA9IHRoaXMuX2RhdGVBZGFwdGVyLmNsYW1wRGF0ZSh2YWx1ZSwgdGhpcy5taW5EYXRlLCB0aGlzLm1heERhdGUpO1xuICAgIHRoaXMuc3RhdGVDaGFuZ2VzLm5leHQoKTtcbiAgfVxuICBwcml2YXRlIF9jbGFtcGVkQWN0aXZlRGF0ZTogRDtcblxuICAvKiogV2hldGhlciB0aGUgY2FsZW5kYXIgaXMgaW4gbW9udGggdmlldy4gKi9cbiAgZ2V0IGN1cnJlbnRWaWV3KCk6IFNhdENhbGVuZGFyVmlldyB7IHJldHVybiB0aGlzLl9jdXJyZW50VmlldzsgfVxuICBzZXQgY3VycmVudFZpZXcodmFsdWU6IFNhdENhbGVuZGFyVmlldykge1xuICAgIHRoaXMuX2N1cnJlbnRWaWV3ID0gdmFsdWU7XG4gICAgdGhpcy5fbW92ZUZvY3VzT25OZXh0VGljayA9IHRydWU7XG4gIH1cbiAgcHJpdmF0ZSBfY3VycmVudFZpZXc6IFNhdENhbGVuZGFyVmlldztcblxuICAvKipcbiAgICogRW1pdHMgd2hlbmV2ZXIgdGhlcmUgaXMgYSBzdGF0ZSBjaGFuZ2UgdGhhdCB0aGUgaGVhZGVyIG1heSBuZWVkIHRvIHJlc3BvbmQgdG8uXG4gICAqL1xuICBzdGF0ZUNoYW5nZXMgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIGNvbnN0cnVjdG9yKF9pbnRsOiBTYXREYXRlcGlja2VySW50bCxcbiAgICAgICAgICAgICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBfZGF0ZUFkYXB0ZXI6IERhdGVBZGFwdGVyPEQ+LFxuICAgICAgICAgICAgICBAT3B0aW9uYWwoKSBASW5qZWN0KE1BVF9EQVRFX0ZPUk1BVFMpIHByaXZhdGUgX2RhdGVGb3JtYXRzOiBNYXREYXRlRm9ybWF0cyxcbiAgICAgICAgICAgICAgcHJpdmF0ZSBfY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmKSB7XG5cbiAgICBpZiAoIXRoaXMuX2RhdGVBZGFwdGVyKSB7XG4gICAgICB0aHJvdyBjcmVhdGVNaXNzaW5nRGF0ZUltcGxFcnJvcignRGF0ZUFkYXB0ZXInKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2RhdGVGb3JtYXRzKSB7XG4gICAgICB0aHJvdyBjcmVhdGVNaXNzaW5nRGF0ZUltcGxFcnJvcignTUFUX0RBVEVfRk9STUFUUycpO1xuICAgIH1cblxuICAgIHRoaXMuX2ludGxDaGFuZ2VzID0gX2ludGwuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgICAgdGhpcy5zdGF0ZUNoYW5nZXMubmV4dCgpO1xuICAgIH0pO1xuICB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIHRoaXMuX2NhbGVuZGFySGVhZGVyUG9ydGFsID0gbmV3IENvbXBvbmVudFBvcnRhbCh0aGlzLmhlYWRlckNvbXBvbmVudCB8fCBTYXRDYWxlbmRhckhlYWRlcik7XG4gICAgdGhpcy5hY3RpdmVEYXRlID0gdGhpcy5zdGFydEF0IHx8IHRoaXMuX2RhdGVBZGFwdGVyLnRvZGF5KCk7XG5cbiAgICAvLyBBc3NpZ24gdG8gdGhlIHByaXZhdGUgcHJvcGVydHkgc2luY2Ugd2UgZG9uJ3Qgd2FudCB0byBtb3ZlIGZvY3VzIG9uIGluaXQuXG4gICAgdGhpcy5fY3VycmVudFZpZXcgPSB0aGlzLnN0YXJ0VmlldztcbiAgfVxuXG4gIG5nQWZ0ZXJWaWV3Q2hlY2tlZCgpIHtcbiAgICBpZiAodGhpcy5fbW92ZUZvY3VzT25OZXh0VGljaykge1xuICAgICAgdGhpcy5fbW92ZUZvY3VzT25OZXh0VGljayA9IGZhbHNlO1xuICAgICAgdGhpcy5mb2N1c0FjdGl2ZUNlbGwoKTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLl9pbnRsQ2hhbmdlcy51bnN1YnNjcmliZSgpO1xuICAgIHRoaXMuc3RhdGVDaGFuZ2VzLmNvbXBsZXRlKCk7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgY29uc3QgY2hhbmdlID0gY2hhbmdlcy5taW5EYXRlIHx8IGNoYW5nZXMubWF4RGF0ZSB8fCBjaGFuZ2VzLmRhdGVGaWx0ZXI7XG5cbiAgICBpZiAoY2hhbmdlICYmICFjaGFuZ2UuZmlyc3RDaGFuZ2UpIHtcbiAgICAgIGNvbnN0IHZpZXcgPSB0aGlzLl9nZXRDdXJyZW50Vmlld0NvbXBvbmVudCgpO1xuXG4gICAgICBpZiAodmlldykge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGBkZXRlY3RDaGFuZ2VzYCBtYW51YWxseSBoZXJlLCBiZWNhdXNlIHRoZSBgbWluRGF0ZWAsIGBtYXhEYXRlYCBldGMuIGFyZVxuICAgICAgICAvLyBwYXNzZWQgZG93biB0byB0aGUgdmlldyB2aWEgZGF0YSBiaW5kaW5ncyB3aGljaCB3b24ndCBiZSB1cC10by1kYXRlIHdoZW4gd2UgY2FsbCBgX2luaXRgLlxuICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIHZpZXcuX2luaXQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlQ2hhbmdlcy5uZXh0KCk7XG4gIH1cblxuICBmb2N1c0FjdGl2ZUNlbGwoKSB7XG4gICAgdGhpcy5fZ2V0Q3VycmVudFZpZXdDb21wb25lbnQoKS5fZm9jdXNBY3RpdmVDZWxsKCk7XG4gIH1cblxuICAvKiogSGFuZGxlcyBkYXRlIHNlbGVjdGlvbiBpbiB0aGUgbW9udGggdmlldy4gKi9cbiAgX2RhdGVTZWxlY3RlZChkYXRlOiBEKTogdm9pZCB7XG4gICAgaWYgKHRoaXMucmFuZ2VNb2RlKSB7XG4gICAgICAgIGlmICghdGhpcy5fYmVnaW5EYXRlU2VsZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLl9iZWdpbkRhdGVTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5iZWdpbkRhdGUgPSBkYXRlO1xuICAgICAgICAgIHRoaXMuZW5kRGF0ZSA9IGRhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fYmVnaW5EYXRlU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICBpZiAodGhpcy5fZGF0ZUFkYXB0ZXIuY29tcGFyZURhdGUoPEQ+dGhpcy5iZWdpbkRhdGUsIGRhdGUpIDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGF0ZVJhbmdlc0NoYW5nZS5lbWl0KHtiZWdpbjogPEQ+dGhpcy5iZWdpbkRhdGUsIGVuZDogZGF0ZX0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRhdGVSYW5nZXNDaGFuZ2UuZW1pdCh7YmVnaW46IGRhdGUsIGVuZDogPEQ+dGhpcy5iZWdpbkRhdGV9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCF0aGlzLl9kYXRlQWRhcHRlci5zYW1lRGF0ZShkYXRlLCB0aGlzLnNlbGVjdGVkKSkge1xuICAgICAgdGhpcy5zZWxlY3RlZENoYW5nZS5lbWl0KGRhdGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBIYW5kbGVzIHllYXIgc2VsZWN0aW9uIGluIHRoZSBtdWx0aXllYXIgdmlldy4gKi9cbiAgX3llYXJTZWxlY3RlZEluTXVsdGlZZWFyVmlldyhub3JtYWxpemVkWWVhcjogRCkge1xuICAgIHRoaXMueWVhclNlbGVjdGVkLmVtaXQobm9ybWFsaXplZFllYXIpO1xuICB9XG5cbiAgLyoqIEhhbmRsZXMgbW9udGggc2VsZWN0aW9uIGluIHRoZSB5ZWFyIHZpZXcuICovXG4gIF9tb250aFNlbGVjdGVkSW5ZZWFyVmlldyhub3JtYWxpemVkTW9udGg6IEQpIHtcbiAgICB0aGlzLm1vbnRoU2VsZWN0ZWQuZW1pdChub3JtYWxpemVkTW9udGgpO1xuICB9XG5cbiAgX3VzZXJTZWxlY3RlZCgpOiB2b2lkIHtcbiAgICB0aGlzLl91c2VyU2VsZWN0aW9uLmVtaXQoKTtcbiAgfVxuXG4gIC8qKiBIYW5kbGVzIHllYXIvbW9udGggc2VsZWN0aW9uIGluIHRoZSBtdWx0aS15ZWFyL3llYXIgdmlld3MuICovXG4gIF9nb1RvRGF0ZUluVmlldyhkYXRlOiBELCB2aWV3OiAnbW9udGgnIHwgJ3llYXInIHwgJ211bHRpLXllYXInKTogdm9pZCB7XG4gICAgdGhpcy5hY3RpdmVEYXRlID0gZGF0ZTtcbiAgICB0aGlzLmN1cnJlbnRWaWV3ID0gdmlldztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gb2JqIFRoZSBvYmplY3QgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIFRoZSBnaXZlbiBvYmplY3QgaWYgaXQgaXMgYm90aCBhIGRhdGUgaW5zdGFuY2UgYW5kIHZhbGlkLCBvdGhlcndpc2UgbnVsbC5cbiAgICovXG4gIHByaXZhdGUgX2dldFZhbGlkRGF0ZU9yTnVsbChvYmo6IGFueSk6IEQgfCBudWxsIHtcbiAgICByZXR1cm4gKHRoaXMuX2RhdGVBZGFwdGVyLmlzRGF0ZUluc3RhbmNlKG9iaikgJiYgdGhpcy5fZGF0ZUFkYXB0ZXIuaXNWYWxpZChvYmopKSA/IG9iaiA6IG51bGw7XG4gIH1cblxuICAvKiogUmV0dXJucyB0aGUgY29tcG9uZW50IGluc3RhbmNlIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGN1cnJlbnQgY2FsZW5kYXIgdmlldy4gKi9cbiAgcHJpdmF0ZSBfZ2V0Q3VycmVudFZpZXdDb21wb25lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9udGhWaWV3IHx8IHRoaXMueWVhclZpZXcgfHwgdGhpcy5tdWx0aVllYXJWaWV3O1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmltcG9ydCB7XG4gICAgYW5pbWF0ZSxcbiAgICBzdGF0ZSxcbiAgICBzdHlsZSxcbiAgICB0cmFuc2l0aW9uLFxuICAgIHRyaWdnZXIsXG4gICAgQW5pbWF0aW9uVHJpZ2dlck1ldGFkYXRhLFxuICAgIGdyb3VwLFxuICAgIHF1ZXJ5LFxuICAgIGFuaW1hdGVDaGlsZCxcbn0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5cbi8qKiBBbmltYXRpb25zIHVzZWQgYnkgdGhlIE1hdGVyaWFsIGRhdGVwaWNrZXIuICovXG5leHBvcnQgY29uc3QgbWF0RGF0ZXBpY2tlckFuaW1hdGlvbnM6IHtcbiAgICByZWFkb25seSB0cmFuc2Zvcm1QYW5lbDogQW5pbWF0aW9uVHJpZ2dlck1ldGFkYXRhO1xuICAgIHJlYWRvbmx5IGZhZGVJbkNhbGVuZGFyOiBBbmltYXRpb25UcmlnZ2VyTWV0YWRhdGE7XG59ID0ge1xuICAgIC8qKiBUcmFuc2Zvcm1zIHRoZSBoZWlnaHQgb2YgdGhlIGRhdGVwaWNrZXIncyBjYWxlbmRhci4gKi9cbiAgICB0cmFuc2Zvcm1QYW5lbDogdHJpZ2dlcigndHJhbnNmb3JtUGFuZWwnLCBbXG4gICAgICAgIHN0YXRlKCd2b2lkJywgc3R5bGUoe29wYWNpdHk6IDAsIHRyYW5zZm9ybTogJ3NjYWxlKDEsIDApJ30pKSxcbiAgICAgICAgc3RhdGUoJ2VudGVyJywgc3R5bGUoe29wYWNpdHk6IDEsIHRyYW5zZm9ybTogJ3NjYWxlKDEsIDEpJ30pKSxcbiAgICAgICAgdHJhbnNpdGlvbigndm9pZCA9PiBlbnRlcicsIGdyb3VwKFtcbiAgICAgICAgICAgIHF1ZXJ5KCdAZmFkZUluQ2FsZW5kYXInLCBhbmltYXRlQ2hpbGQoKSksXG4gICAgICAgICAgICBhbmltYXRlKCc0MDBtcyBjdWJpYy1iZXppZXIoMC4yNSwgMC44LCAwLjI1LCAxKScpXG4gICAgICAgIF0pKSxcbiAgICAgICAgdHJhbnNpdGlvbignKiA9PiB2b2lkJywgYW5pbWF0ZSgnMTAwbXMgbGluZWFyJywgc3R5bGUoe29wYWNpdHk6IDB9KSkpXG4gICAgXSksXG5cbiAgICAvKiogRmFkZXMgaW4gdGhlIGNvbnRlbnQgb2YgdGhlIGNhbGVuZGFyLiAqL1xuICAgIGZhZGVJbkNhbGVuZGFyOiB0cmlnZ2VyKCdmYWRlSW5DYWxlbmRhcicsIFtcbiAgICAgICAgc3RhdGUoJ3ZvaWQnLCBzdHlsZSh7b3BhY2l0eTogMH0pKSxcbiAgICAgICAgc3RhdGUoJ2VudGVyJywgc3R5bGUoe29wYWNpdHk6IDF9KSksXG4gICAgICAgIHRyYW5zaXRpb24oJ3ZvaWQgPT4gKicsIGFuaW1hdGUoJzQwMG1zIDEwMG1zIGN1YmljLWJlemllcigwLjU1LCAwLCAwLjU1LCAwLjIpJykpXG4gICAgXSlcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtEaXJlY3Rpb25hbGl0eX0gZnJvbSAnQGFuZ3VsYXIvY2RrL2JpZGknO1xuaW1wb3J0IHtjb2VyY2VCb29sZWFuUHJvcGVydHl9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQge0VTQ0FQRSwgVVBfQVJST1d9IGZyb20gJ0Bhbmd1bGFyL2Nkay9rZXljb2Rlcyc7XG5pbXBvcnQge1xuICBPdmVybGF5LFxuICBPdmVybGF5Q29uZmlnLFxuICBPdmVybGF5UmVmLFxuICBQb3NpdGlvblN0cmF0ZWd5LFxuICBTY3JvbGxTdHJhdGVneSxcbn0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuaW1wb3J0IHtDb21wb25lbnRQb3J0YWwsIENvbXBvbmVudFR5cGV9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wb3J0YWwnO1xuaW1wb3J0IHtET0NVTUVOVH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7dGFrZSwgZmlsdGVyfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge1xuICBBZnRlclZpZXdJbml0LFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ29tcG9uZW50LFxuICBDb21wb25lbnRSZWYsXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5qZWN0LFxuICBJbmplY3Rpb25Ub2tlbixcbiAgSW5wdXQsXG4gIE5nWm9uZSxcbiAgT3B0aW9uYWwsXG4gIE91dHB1dCxcbiAgVmlld0NoaWxkLFxuICBWaWV3Q29udGFpbmVyUmVmLFxuICBWaWV3RW5jYXBzdWxhdGlvbixcbiAgT25EZXN0cm95LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q2FuQ29sb3IsIG1peGluQ29sb3IsIFRoZW1lUGFsZXR0ZX0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvY29yZSc7XG5pbXBvcnQge01hdERpYWxvZywgTWF0RGlhbG9nUmVmfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9kaWFsb2cnO1xuaW1wb3J0IHttZXJnZSwgU3ViamVjdCwgU3Vic2NyaXB0aW9ufSBmcm9tICdyeGpzJztcbmltcG9ydCB7U2F0Q2FsZW5kYXJ9IGZyb20gJy4vY2FsZW5kYXInO1xuaW1wb3J0IHttYXREYXRlcGlja2VyQW5pbWF0aW9uc30gZnJvbSAnLi9kYXRlcGlja2VyLWFuaW1hdGlvbnMnO1xuaW1wb3J0IHtjcmVhdGVNaXNzaW5nRGF0ZUltcGxFcnJvcn0gZnJvbSAnLi9kYXRlcGlja2VyLWVycm9ycyc7XG5pbXBvcnQge1NhdERhdGVwaWNrZXJJbnB1dCwgU2F0RGF0ZXBpY2tlclJhbmdlVmFsdWV9IGZyb20gJy4vZGF0ZXBpY2tlci1pbnB1dCc7XG5pbXBvcnQge0RhdGVBZGFwdGVyfSBmcm9tICcuLi9kYXRldGltZS9kYXRlLWFkYXB0ZXInO1xuXG4vKiogVXNlZCB0byBnZW5lcmF0ZSBhIHVuaXF1ZSBJRCBmb3IgZWFjaCBkYXRlcGlja2VyIGluc3RhbmNlLiAqL1xubGV0IGRhdGVwaWNrZXJVaWQgPSAwO1xuXG4vKiogSW5qZWN0aW9uIHRva2VuIHRoYXQgZGV0ZXJtaW5lcyB0aGUgc2Nyb2xsIGhhbmRsaW5nIHdoaWxlIHRoZSBjYWxlbmRhciBpcyBvcGVuLiAqL1xuZXhwb3J0IGNvbnN0IE1BVF9EQVRFUElDS0VSX1NDUk9MTF9TVFJBVEVHWSA9XG4gICAgbmV3IEluamVjdGlvblRva2VuPCgpID0+IFNjcm9sbFN0cmF0ZWd5Pignc2F0LWRhdGVwaWNrZXItc2Nyb2xsLXN0cmF0ZWd5Jyk7XG5cbi8qKiBAZG9jcy1wcml2YXRlICovXG5leHBvcnQgZnVuY3Rpb24gTUFUX0RBVEVQSUNLRVJfU0NST0xMX1NUUkFURUdZX0ZBQ1RPUlkob3ZlcmxheTogT3ZlcmxheSk6ICgpID0+IFNjcm9sbFN0cmF0ZWd5IHtcbiAgcmV0dXJuICgpID0+IG92ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5yZXBvc2l0aW9uKCk7XG59XG5cbi8qKiBAZG9jcy1wcml2YXRlICovXG5leHBvcnQgY29uc3QgTUFUX0RBVEVQSUNLRVJfU0NST0xMX1NUUkFURUdZX0ZBQ1RPUllfUFJPVklERVIgPSB7XG4gIHByb3ZpZGU6IE1BVF9EQVRFUElDS0VSX1NDUk9MTF9TVFJBVEVHWSxcbiAgZGVwczogW092ZXJsYXldLFxuICB1c2VGYWN0b3J5OiBNQVRfREFURVBJQ0tFUl9TQ1JPTExfU1RSQVRFR1lfRkFDVE9SWSxcbn07XG5cbi8vIEJvaWxlcnBsYXRlIGZvciBhcHBseWluZyBtaXhpbnMgdG8gU2F0RGF0ZXBpY2tlckNvbnRlbnQuXG4vKiogQGRvY3MtcHJpdmF0ZSAqL1xuZXhwb3J0IGNsYXNzIFNhdERhdGVwaWNrZXJDb250ZW50QmFzZSB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBfZWxlbWVudFJlZjogRWxlbWVudFJlZikgeyB9XG59XG5leHBvcnQgY29uc3QgX1NhdERhdGVwaWNrZXJDb250ZW50TWl4aW5CYXNlID0gbWl4aW5Db2xvcihTYXREYXRlcGlja2VyQ29udGVudEJhc2UpO1xuXG4vKipcbiAqIENvbXBvbmVudCB1c2VkIGFzIHRoZSBjb250ZW50IGZvciB0aGUgZGF0ZXBpY2tlciBkaWFsb2cgYW5kIHBvcHVwLiBXZSB1c2UgdGhpcyBpbnN0ZWFkIG9mIHVzaW5nXG4gKiBTYXRDYWxlbmRhciBkaXJlY3RseSBhcyB0aGUgY29udGVudCBzbyB3ZSBjYW4gY29udHJvbCB0aGUgaW5pdGlhbCBmb2N1cy4gVGhpcyBhbHNvIGdpdmVzIHVzIGFcbiAqIHBsYWNlIHRvIHB1dCBhZGRpdGlvbmFsIGZlYXR1cmVzIG9mIHRoZSBwb3B1cCB0aGF0IGFyZSBub3QgcGFydCBvZiB0aGUgY2FsZW5kYXIgaXRzZWxmIGluIHRoZVxuICogZnV0dXJlLiAoZS5nLiBjb25maXJtYXRpb24gYnV0dG9ucykuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbkBDb21wb25lbnQoe1xuICBtb2R1bGVJZDogbW9kdWxlLmlkLFxuICBzZWxlY3RvcjogJ3NhdC1kYXRlcGlja2VyLWNvbnRlbnQnLFxuICB0ZW1wbGF0ZVVybDogJ2RhdGVwaWNrZXItY29udGVudC5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJ2RhdGVwaWNrZXItY29udGVudC5jc3MnXSxcbiAgaG9zdDoge1xuICAgICdjbGFzcyc6ICdtYXQtZGF0ZXBpY2tlci1jb250ZW50JyxcbiAgICAnW0B0cmFuc2Zvcm1QYW5lbF0nOiAnXCJlbnRlclwiJyxcbiAgICAnW2NsYXNzLm1hdC1kYXRlcGlja2VyLWNvbnRlbnQtdG91Y2hdJzogJ2RhdGVwaWNrZXIudG91Y2hVaScsXG4gIH0sXG4gIGFuaW1hdGlvbnM6IFtcbiAgICBtYXREYXRlcGlja2VyQW5pbWF0aW9ucy50cmFuc2Zvcm1QYW5lbCxcbiAgICBtYXREYXRlcGlja2VyQW5pbWF0aW9ucy5mYWRlSW5DYWxlbmRhcixcbiAgXSxcbiAgZXhwb3J0QXM6ICdtYXREYXRlcGlja2VyQ29udGVudCcsXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBpbnB1dHM6IFsnY29sb3InXSxcbn0pXG5leHBvcnQgY2xhc3MgU2F0RGF0ZXBpY2tlckNvbnRlbnQ8RD4gZXh0ZW5kcyBfU2F0RGF0ZXBpY2tlckNvbnRlbnRNaXhpbkJhc2VcbiAgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBDYW5Db2xvciB7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byB0aGUgaW50ZXJuYWwgY2FsZW5kYXIgY29tcG9uZW50LiAqL1xuICBAVmlld0NoaWxkKFNhdENhbGVuZGFyKSBfY2FsZW5kYXI6IFNhdENhbGVuZGFyPEQ+O1xuXG4gIC8qKiBSZWZlcmVuY2UgdG8gdGhlIGRhdGVwaWNrZXIgdGhhdCBjcmVhdGVkIHRoZSBvdmVybGF5LiAqL1xuICBkYXRlcGlja2VyOiBTYXREYXRlcGlja2VyPEQ+O1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBkYXRlcGlja2VyIGlzIGFib3ZlIG9yIGJlbG93IHRoZSBpbnB1dC4gKi9cbiAgX2lzQWJvdmU6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZikge1xuICAgIHN1cGVyKGVsZW1lbnRSZWYpO1xuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIHRoaXMuX2NhbGVuZGFyLmZvY3VzQWN0aXZlQ2VsbCgpO1xuICB9XG5cbiAgY2xvc2UoKSB7XG4gICAgaWYgKHRoaXMuZGF0ZXBpY2tlci5jbG9zZUFmdGVyU2VsZWN0aW9uKSB7XG4gICAgICB0aGlzLmRhdGVwaWNrZXIuY2xvc2UoKTtcbiAgICB9XG4gIH1cbn1cblxuXG4vLyBUT0RPKG1tYWxlcmJhKTogV2UgdXNlIGEgY29tcG9uZW50IGluc3RlYWQgb2YgYSBkaXJlY3RpdmUgaGVyZSBzbyB0aGUgdXNlciBjYW4gdXNlIGltcGxpY2l0XG4vLyB0ZW1wbGF0ZSByZWZlcmVuY2UgdmFyaWFibGVzIChlLmcuICNkIHZzICNkPVwibWF0RGF0ZXBpY2tlclwiKS4gV2UgY2FuIGNoYW5nZSB0aGlzIHRvIGEgZGlyZWN0aXZlXG4vLyBpZiBhbmd1bGFyIGFkZHMgc3VwcG9ydCBmb3IgYGV4cG9ydEFzOiAnJGltcGxpY2l0J2Agb24gZGlyZWN0aXZlcy5cbi8qKiBDb21wb25lbnQgcmVzcG9uc2libGUgZm9yIG1hbmFnaW5nIHRoZSBkYXRlcGlja2VyIHBvcHVwL2RpYWxvZy4gKi9cbkBDb21wb25lbnQoe1xuICBtb2R1bGVJZDogbW9kdWxlLmlkLFxuICBzZWxlY3RvcjogJ3NhdC1kYXRlcGlja2VyJyxcbiAgdGVtcGxhdGU6ICcnLFxuICBleHBvcnRBczogJ21hdERhdGVwaWNrZXInLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbn0pXG5leHBvcnQgY2xhc3MgU2F0RGF0ZXBpY2tlcjxEPiBpbXBsZW1lbnRzIE9uRGVzdHJveSwgQ2FuQ29sb3Ige1xuXG4gIC8qKiBXaGVuZXZlciBkYXRlcGlja2VyIGlzIGZvciBzZWxlY3RpbmcgcmFuZ2Ugb2YgZGF0ZXMuICovXG4gIEBJbnB1dCgpXG4gIGdldCByYW5nZU1vZGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3JhbmdlTW9kZTtcbiAgfVxuICBzZXQgcmFuZ2VNb2RlKG1vZGU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9yYW5nZU1vZGUgPSBtb2RlO1xuICAgIGlmICh0aGlzLnJhbmdlTW9kZSkge1xuICAgICAgdGhpcy5fdmFsaWRTZWxlY3RlZCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2JlZ2luRGF0ZSA9IHRoaXMuX2VuZERhdGUgPSBudWxsO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIF9yYW5nZU1vZGU7XG5cbiAgLyoqIFN0YXJ0IG9mIGRhdGVzIGludGVydmFsLiAqL1xuICBASW5wdXQoKVxuICBnZXQgYmVnaW5EYXRlKCk6IEQgfCBudWxsIHsgcmV0dXJuIHRoaXMuX2JlZ2luRGF0ZTsgfVxuICBzZXQgYmVnaW5EYXRlKHZhbHVlOiBEIHwgbnVsbCkge1xuICAgIHRoaXMuX3ZhbGlkU2VsZWN0ZWQgPSBudWxsO1xuICAgIHRoaXMuX2JlZ2luRGF0ZSA9IHRoaXMuX2dldFZhbGlkRGF0ZU9yTnVsbCh0aGlzLl9kYXRlQWRhcHRlci5kZXNlcmlhbGl6ZSh2YWx1ZSkpO1xuICB9XG4gIF9iZWdpbkRhdGU6IEQgfCBudWxsO1xuXG4gIC8qKiBFbmQgb2YgZGF0ZXMgaW50ZXJ2YWwuICovXG4gIEBJbnB1dCgpXG4gIGdldCBlbmREYXRlKCk6IEQgfCBudWxsIHsgcmV0dXJuIHRoaXMuX2VuZERhdGU7IH1cbiAgc2V0IGVuZERhdGUodmFsdWU6IEQgfCBudWxsKSB7XG4gICAgdGhpcy5fdmFsaWRTZWxlY3RlZCA9IG51bGw7XG4gICAgdGhpcy5fZW5kRGF0ZSA9IHRoaXMuX2dldFZhbGlkRGF0ZU9yTnVsbCh0aGlzLl9kYXRlQWRhcHRlci5kZXNlcmlhbGl6ZSh2YWx1ZSkpO1xuICB9XG4gIF9lbmREYXRlOiBEIHwgbnVsbDtcblxuICAgIC8qKiBBbiBpbnB1dCBpbmRpY2F0aW5nIHRoZSB0eXBlIG9mIHRoZSBjdXN0b20gaGVhZGVyIGNvbXBvbmVudCBmb3IgdGhlIGNhbGVuZGFyLCBpZiBzZXQuICovXG4gICAgQElucHV0KCkgY2FsZW5kYXJIZWFkZXJDb21wb25lbnQ6IENvbXBvbmVudFR5cGU8YW55PjtcblxuICAvKiogVGhlIGRhdGUgdG8gb3BlbiB0aGUgY2FsZW5kYXIgdG8gaW5pdGlhbGx5LiAqL1xuICBASW5wdXQoKVxuICBnZXQgc3RhcnRBdCgpOiBEIHwgbnVsbCB7XG4gICAgLy8gSWYgYW4gZXhwbGljaXQgc3RhcnRBdCBpcyBzZXQgd2Ugc3RhcnQgdGhlcmUsIG90aGVyd2lzZSB3ZSBzdGFydCBhdCB3aGF0ZXZlciB0aGUgY3VycmVudGx5XG4gICAgLy8gc2VsZWN0ZWQgdmFsdWUgaXMuXG4gICAgaWYgKHRoaXMucmFuZ2VNb2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RhcnRBdCB8fCAodGhpcy5fZGF0ZXBpY2tlcklucHV0ICYmIHRoaXMuX2RhdGVwaWNrZXJJbnB1dC52YWx1ZSA/XG4gICAgICAgICg8U2F0RGF0ZXBpY2tlclJhbmdlVmFsdWU8RD4+dGhpcy5fZGF0ZXBpY2tlcklucHV0LnZhbHVlKS5iZWdpbiA6IG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc3RhcnRBdCB8fCAodGhpcy5fZGF0ZXBpY2tlcklucHV0ID8gPER8bnVsbD50aGlzLl9kYXRlcGlja2VySW5wdXQudmFsdWUgOiBudWxsKTtcbiAgfVxuICBzZXQgc3RhcnRBdCh2YWx1ZTogRCB8IG51bGwpIHtcbiAgICB0aGlzLl9zdGFydEF0ID0gdGhpcy5fZ2V0VmFsaWREYXRlT3JOdWxsKHRoaXMuX2RhdGVBZGFwdGVyLmRlc2VyaWFsaXplKHZhbHVlKSk7XG4gIH1cbiAgcHJpdmF0ZSBfc3RhcnRBdDogRCB8IG51bGw7XG5cbiAgLyoqIFRoZSB2aWV3IHRoYXQgdGhlIGNhbGVuZGFyIHNob3VsZCBzdGFydCBpbi4gKi9cbiAgQElucHV0KCkgc3RhcnRWaWV3OiAnbW9udGgnIHwgJ3llYXInID0gJ21vbnRoJztcblxuICAvKiogQ29sb3IgcGFsZXR0ZSB0byB1c2Ugb24gdGhlIGRhdGVwaWNrZXIncyBjYWxlbmRhci4gKi9cbiAgQElucHV0KClcbiAgZ2V0IGNvbG9yKCk6IFRoZW1lUGFsZXR0ZSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbG9yIHx8XG4gICAgICAgICh0aGlzLl9kYXRlcGlja2VySW5wdXQgPyB0aGlzLl9kYXRlcGlja2VySW5wdXQuX2dldFRoZW1lUGFsZXR0ZSgpIDogdW5kZWZpbmVkKTtcbiAgfVxuICBzZXQgY29sb3IodmFsdWU6IFRoZW1lUGFsZXR0ZSkge1xuICAgIHRoaXMuX2NvbG9yID0gdmFsdWU7XG4gIH1cbiAgX2NvbG9yOiBUaGVtZVBhbGV0dGU7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGNhbGVuZGFyIFVJIGlzIGluIHRvdWNoIG1vZGUuIEluIHRvdWNoIG1vZGUgdGhlIGNhbGVuZGFyIG9wZW5zIGluIGEgZGlhbG9nIHJhdGhlclxuICAgKiB0aGFuIGEgcG9wdXAgYW5kIGVsZW1lbnRzIGhhdmUgbW9yZSBwYWRkaW5nIHRvIGFsbG93IGZvciBiaWdnZXIgdG91Y2ggdGFyZ2V0cy5cbiAgICovXG4gIEBJbnB1dCgpXG4gIGdldCB0b3VjaFVpKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fdG91Y2hVaTsgfVxuICBzZXQgdG91Y2hVaSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX3RvdWNoVWkgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICB9XG4gIHByaXZhdGUgX3RvdWNoVWkgPSBmYWxzZTtcblxuICAvKiogV2hldGhlciB0aGUgZGF0ZXBpY2tlciBwb3AtdXAgc2hvdWxkIGJlIGRpc2FibGVkLiAqL1xuICBASW5wdXQoKVxuICBnZXQgZGlzYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkID09PSB1bmRlZmluZWQgJiYgdGhpcy5fZGF0ZXBpY2tlcklucHV0ID9cbiAgICAgICAgdGhpcy5fZGF0ZXBpY2tlcklucHV0LmRpc2FibGVkIDogISF0aGlzLl9kaXNhYmxlZDtcbiAgfVxuICBzZXQgZGlzYWJsZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG5cbiAgICBpZiAobmV3VmFsdWUgIT09IHRoaXMuX2Rpc2FibGVkKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlZCA9IG5ld1ZhbHVlO1xuICAgICAgdGhpcy5fZGlzYWJsZWRDaGFuZ2UubmV4dChuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHByaXZhdGUgX2Rpc2FibGVkOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBFbWl0cyBzZWxlY3RlZCB5ZWFyIGluIG11bHRpeWVhciB2aWV3LlxuICAgKiBUaGlzIGRvZXNuJ3QgaW1wbHkgYSBjaGFuZ2Ugb24gdGhlIHNlbGVjdGVkIGRhdGUuXG4gICAqL1xuICBAT3V0cHV0KCkgcmVhZG9ubHkgeWVhclNlbGVjdGVkOiBFdmVudEVtaXR0ZXI8RD4gPSBuZXcgRXZlbnRFbWl0dGVyPEQ+KCk7XG5cbiAgLyoqXG4gICAqIEVtaXRzIHNlbGVjdGVkIG1vbnRoIGluIHllYXIgdmlldy5cbiAgICogVGhpcyBkb2Vzbid0IGltcGx5IGEgY2hhbmdlIG9uIHRoZSBzZWxlY3RlZCBkYXRlLlxuICAgKi9cbiAgQE91dHB1dCgpIHJlYWRvbmx5IG1vbnRoU2VsZWN0ZWQ6IEV2ZW50RW1pdHRlcjxEPiA9IG5ldyBFdmVudEVtaXR0ZXI8RD4oKTtcblxuICAvKiogQ2xhc3NlcyB0byBiZSBwYXNzZWQgdG8gdGhlIGRhdGUgcGlja2VyIHBhbmVsLiBTdXBwb3J0cyB0aGUgc2FtZSBzeW50YXggYXMgYG5nQ2xhc3NgLiAqL1xuICBASW5wdXQoKSBwYW5lbENsYXNzOiBzdHJpbmcgfCBzdHJpbmdbXTtcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgZGF0ZXBpY2tlciBoYXMgYmVlbiBvcGVuZWQuICovXG4gIEBPdXRwdXQoJ29wZW5lZCcpIG9wZW5lZFN0cmVhbTogRXZlbnRFbWl0dGVyPHZvaWQ+ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSBkYXRlcGlja2VyIGhhcyBiZWVuIGNsb3NlZC4gKi9cbiAgQE91dHB1dCgnY2xvc2VkJykgY2xvc2VkU3RyZWFtOiBFdmVudEVtaXR0ZXI8dm9pZD4gPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgLyoqIEVuYWJsZXMgZGF0ZXBpY2tlciBjbG9zaW5nIGFmdGVyIHNlbGVjdGlvbiAqL1xuICBASW5wdXQoKSBjbG9zZUFmdGVyU2VsZWN0aW9uID0gdHJ1ZTtcblxuICAvKiogT3JkZXIgdGhlIHZpZXdzIHdoZW4gY2xpY2tpbmcgb24gcGVyaW9kIGxhYmVsIGJ1dHRvbiAqL1xuICBASW5wdXQoKSBvcmRlclBlcmlvZExhYmVsOiAnbW9udGgnIHwgJ211bHRpLXllYXInID0gJ211bHRpLXllYXInO1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBjYWxlbmRhciBpcyBvcGVuLiAqL1xuICBASW5wdXQoKVxuICBnZXQgb3BlbmVkKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fb3BlbmVkOyB9XG4gIHNldCBvcGVuZWQodmFsdWU6IGJvb2xlYW4pIHsgdmFsdWUgPyB0aGlzLm9wZW4oKSA6IHRoaXMuY2xvc2UoKTsgfVxuICBwcml2YXRlIF9vcGVuZWQgPSBmYWxzZTtcblxuICAvKiogVGhlIGlkIGZvciB0aGUgZGF0ZXBpY2tlciBjYWxlbmRhci4gKi9cbiAgaWQ6IHN0cmluZyA9IGBzYXQtZGF0ZXBpY2tlci0ke2RhdGVwaWNrZXJVaWQrK31gO1xuXG4gIC8qKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGRhdGUuICovXG4gIGdldCBfc2VsZWN0ZWQoKTogRCB8IG51bGwgeyByZXR1cm4gdGhpcy5fdmFsaWRTZWxlY3RlZDsgfVxuICBzZXQgX3NlbGVjdGVkKHZhbHVlOiBEIHwgbnVsbCkgeyB0aGlzLl92YWxpZFNlbGVjdGVkID0gdmFsdWU7IH1cbiAgcHJpdmF0ZSBfdmFsaWRTZWxlY3RlZDogRCB8IG51bGwgPSBudWxsO1xuXG4gIC8qKiBUaGUgbWluaW11bSBzZWxlY3RhYmxlIGRhdGUuICovXG4gIGdldCBfbWluRGF0ZSgpOiBEIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVwaWNrZXJJbnB1dCAmJiB0aGlzLl9kYXRlcGlja2VySW5wdXQubWluO1xuICB9XG5cbiAgLyoqIFRoZSBtYXhpbXVtIHNlbGVjdGFibGUgZGF0ZS4gKi9cbiAgZ2V0IF9tYXhEYXRlKCk6IEQgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZXBpY2tlcklucHV0ICYmIHRoaXMuX2RhdGVwaWNrZXJJbnB1dC5tYXg7XG4gIH1cblxuICBnZXQgX2RhdGVGaWx0ZXIoKTogKGRhdGU6IEQgfCBudWxsKSA9PiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZXBpY2tlcklucHV0ICYmIHRoaXMuX2RhdGVwaWNrZXJJbnB1dC5fZGF0ZUZpbHRlcjtcbiAgfVxuXG4gIC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgb3ZlcmxheSB3aGVuIHRoZSBjYWxlbmRhciBpcyBvcGVuZWQgYXMgYSBwb3B1cC4gKi9cbiAgX3BvcHVwUmVmOiBPdmVybGF5UmVmO1xuXG4gIC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgZGlhbG9nIHdoZW4gdGhlIGNhbGVuZGFyIGlzIG9wZW5lZCBhcyBhIGRpYWxvZy4gKi9cbiAgcHJpdmF0ZSBfZGlhbG9nUmVmOiBNYXREaWFsb2dSZWY8U2F0RGF0ZXBpY2tlckNvbnRlbnQ8RD4+IHwgbnVsbDtcblxuICAvKiogQSBwb3J0YWwgY29udGFpbmluZyB0aGUgY2FsZW5kYXIgZm9yIHRoaXMgZGF0ZXBpY2tlci4gKi9cbiAgcHJpdmF0ZSBfY2FsZW5kYXJQb3J0YWw6IENvbXBvbmVudFBvcnRhbDxTYXREYXRlcGlja2VyQ29udGVudDxEPj47XG5cbiAgLyoqIFJlZmVyZW5jZSB0byB0aGUgY29tcG9uZW50IGluc3RhbnRpYXRlZCBpbiBwb3B1cCBtb2RlLiAqL1xuICBwcml2YXRlIF9wb3B1cENvbXBvbmVudFJlZjogQ29tcG9uZW50UmVmPFNhdERhdGVwaWNrZXJDb250ZW50PEQ+PiB8IG51bGw7XG5cbiAgLyoqIFRoZSBlbGVtZW50IHRoYXQgd2FzIGZvY3VzZWQgYmVmb3JlIHRoZSBkYXRlcGlja2VyIHdhcyBvcGVuZWQuICovXG4gIHByaXZhdGUgX2ZvY3VzZWRFbGVtZW50QmVmb3JlT3BlbjogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbDtcblxuICAvKiogU3Vic2NyaXB0aW9uIHRvIHZhbHVlIGNoYW5nZXMgaW4gdGhlIGFzc29jaWF0ZWQgaW5wdXQgZWxlbWVudC4gKi9cbiAgcHJpdmF0ZSBfaW5wdXRTdWJzY3JpcHRpb24gPSBTdWJzY3JpcHRpb24uRU1QVFk7XG5cbiAgLyoqIFRoZSBpbnB1dCBlbGVtZW50IHRoaXMgZGF0ZXBpY2tlciBpcyBhc3NvY2lhdGVkIHdpdGguICovXG4gIF9kYXRlcGlja2VySW5wdXQ6IFNhdERhdGVwaWNrZXJJbnB1dDxEPjtcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgZGF0ZXBpY2tlciBpcyBkaXNhYmxlZC4gKi9cbiAgcmVhZG9ubHkgX2Rpc2FibGVkQ2hhbmdlID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcblxuICAvKiogRW1pdHMgbmV3IHNlbGVjdGVkIGRhdGUgd2hlbiBzZWxlY3RlZCBkYXRlIGNoYW5nZXMuICovXG4gIHJlYWRvbmx5IF9zZWxlY3RlZENoYW5nZWQgPSBuZXcgU3ViamVjdDxTYXREYXRlcGlja2VyUmFuZ2VWYWx1ZTxEPnxEPigpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2RpYWxvZzogTWF0RGlhbG9nLFxuICAgICAgICAgICAgICBwcml2YXRlIF9vdmVybGF5OiBPdmVybGF5LFxuICAgICAgICAgICAgICBwcml2YXRlIF9uZ1pvbmU6IE5nWm9uZSxcbiAgICAgICAgICAgICAgcHJpdmF0ZSBfdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZixcbiAgICAgICAgICAgICAgQEluamVjdChNQVRfREFURVBJQ0tFUl9TQ1JPTExfU1RSQVRFR1kpIHByaXZhdGUgX3Njcm9sbFN0cmF0ZWd5LFxuICAgICAgICAgICAgICBAT3B0aW9uYWwoKSBwcml2YXRlIF9kYXRlQWRhcHRlcjogRGF0ZUFkYXB0ZXI8RD4sXG4gICAgICAgICAgICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX2RpcjogRGlyZWN0aW9uYWxpdHksXG4gICAgICAgICAgICAgIEBPcHRpb25hbCgpIEBJbmplY3QoRE9DVU1FTlQpIHByaXZhdGUgX2RvY3VtZW50OiBhbnkpIHtcbiAgICBpZiAoIXRoaXMuX2RhdGVBZGFwdGVyKSB7XG4gICAgICB0aHJvdyBjcmVhdGVNaXNzaW5nRGF0ZUltcGxFcnJvcignRGF0ZUFkYXB0ZXInKTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLmNsb3NlKCk7XG4gICAgdGhpcy5faW5wdXRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB0aGlzLl9kaXNhYmxlZENoYW5nZS5jb21wbGV0ZSgpO1xuXG4gICAgaWYgKHRoaXMuX3BvcHVwUmVmKSB7XG4gICAgICB0aGlzLl9wb3B1cFJlZi5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9wb3B1cENvbXBvbmVudFJlZiA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqIFNlbGVjdHMgdGhlIGdpdmVuIGRhdGUgKi9cbiAgX3NlbGVjdChkYXRlOiBEKTogdm9pZCB7XG4gICAgbGV0IG9sZFZhbHVlID0gdGhpcy5fc2VsZWN0ZWQ7XG4gICAgdGhpcy5fc2VsZWN0ZWQgPSBkYXRlO1xuICAgIGlmICghdGhpcy5fZGF0ZUFkYXB0ZXIuc2FtZURhdGUob2xkVmFsdWUsIHRoaXMuX3NlbGVjdGVkKSkge1xuICAgICAgdGhpcy5fc2VsZWN0ZWRDaGFuZ2VkLm5leHQoZGF0ZSk7XG4gICAgfVxuICB9XG5cblxuICAvKiogU2VsZWN0cyB0aGUgZ2l2ZW4gZGF0ZSByYW5nZSAqL1xuICBfc2VsZWN0UmFuZ2UoZGF0ZXM6IFNhdERhdGVwaWNrZXJSYW5nZVZhbHVlPEQ+KTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLl9kYXRlQWRhcHRlci5zYW1lRGF0ZShkYXRlcy5iZWdpbiwgdGhpcy5iZWdpbkRhdGUpIHx8XG4gICAgICAhdGhpcy5fZGF0ZUFkYXB0ZXIuc2FtZURhdGUoZGF0ZXMuZW5kLCB0aGlzLmVuZERhdGUpKSB7XG4gICAgICB0aGlzLl9zZWxlY3RlZENoYW5nZWQubmV4dChkYXRlcyk7XG4gICAgfVxuICAgIHRoaXMuX2JlZ2luRGF0ZSA9IGRhdGVzLmJlZ2luO1xuICAgIHRoaXMuX2VuZERhdGUgPSBkYXRlcy5lbmQ7XG4gIH1cbiAgLyoqIEVtaXRzIHRoZSBzZWxlY3RlZCB5ZWFyIGluIG11bHRpeWVhciB2aWV3ICovXG4gIF9zZWxlY3RZZWFyKG5vcm1hbGl6ZWRZZWFyOiBEKTogdm9pZCB7XG4gICAgdGhpcy55ZWFyU2VsZWN0ZWQuZW1pdChub3JtYWxpemVkWWVhcik7XG4gIH1cblxuICAvKiogRW1pdHMgc2VsZWN0ZWQgbW9udGggaW4geWVhciB2aWV3ICovXG4gIF9zZWxlY3RNb250aChub3JtYWxpemVkTW9udGg6IEQpOiB2b2lkIHtcbiAgICB0aGlzLm1vbnRoU2VsZWN0ZWQuZW1pdChub3JtYWxpemVkTW9udGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFuIGlucHV0IHdpdGggdGhpcyBkYXRlcGlja2VyLlxuICAgKiBAcGFyYW0gaW5wdXQgVGhlIGRhdGVwaWNrZXIgaW5wdXQgdG8gcmVnaXN0ZXIgd2l0aCB0aGlzIGRhdGVwaWNrZXIuXG4gICAqL1xuICBfcmVnaXN0ZXJJbnB1dChpbnB1dDogU2F0RGF0ZXBpY2tlcklucHV0PEQ+KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX2RhdGVwaWNrZXJJbnB1dCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0EgU2F0RGF0ZXBpY2tlciBjYW4gb25seSBiZSBhc3NvY2lhdGVkIHdpdGggYSBzaW5nbGUgaW5wdXQuJyk7XG4gICAgfVxuICAgIHRoaXMuX2RhdGVwaWNrZXJJbnB1dCA9IGlucHV0O1xuICAgIHRoaXMuX2lucHV0U3Vic2NyaXB0aW9uID1cbiAgICAgICAgdGhpcy5fZGF0ZXBpY2tlcklucHV0Ll92YWx1ZUNoYW5nZVxuICAgICAgICAgIC5zdWJzY3JpYmUoKHZhbHVlOiBTYXREYXRlcGlja2VyUmFuZ2VWYWx1ZTxEPiB8IEQgfCBudWxsKSA9PiB7XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmJlZ2luRGF0ZSA9IHRoaXMuZW5kRGF0ZSA9IHRoaXMuX3NlbGVjdGVkID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmhhc093blByb3BlcnR5KCdiZWdpbicpICYmIHZhbHVlLmhhc093blByb3BlcnR5KCdlbmQnKSkge1xuICAgICAgICAgICAgdmFsdWUgPSA8U2F0RGF0ZXBpY2tlclJhbmdlVmFsdWU8RD4+dmFsdWU7XG4gICAgICAgICAgICBpZiAodmFsdWUuYmVnaW4gJiYgdmFsdWUuZW5kICYmXG4gICAgICAgICAgICAgIHRoaXMuX2RhdGVBZGFwdGVyLmNvbXBhcmVEYXRlKHZhbHVlLmJlZ2luLCB2YWx1ZS5lbmQpIDw9IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5iZWdpbkRhdGUgPSB2YWx1ZS5iZWdpbjtcbiAgICAgICAgICAgICAgdGhpcy5lbmREYXRlID0gdmFsdWUuZW5kO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5iZWdpbkRhdGUgPSB0aGlzLmVuZERhdGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IDxEPnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gIH1cblxuICAvKiogT3BlbiB0aGUgY2FsZW5kYXIuICovXG4gIG9wZW4oKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX29wZW5lZCB8fCB0aGlzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5fZGF0ZXBpY2tlcklucHV0KSB7XG4gICAgICB0aHJvdyBFcnJvcignQXR0ZW1wdGVkIHRvIG9wZW4gYW4gU2F0RGF0ZXBpY2tlciB3aXRoIG5vIGFzc29jaWF0ZWQgaW5wdXQuJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9kb2N1bWVudCkge1xuICAgICAgdGhpcy5fZm9jdXNlZEVsZW1lbnRCZWZvcmVPcGVuID0gdGhpcy5fZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICB0aGlzLnRvdWNoVWkgPyB0aGlzLl9vcGVuQXNEaWFsb2coKSA6IHRoaXMuX29wZW5Bc1BvcHVwKCk7XG4gICAgdGhpcy5fb3BlbmVkID0gdHJ1ZTtcbiAgICB0aGlzLm9wZW5lZFN0cmVhbS5lbWl0KCk7XG4gIH1cblxuICAvKiogQ2xvc2UgdGhlIGNhbGVuZGFyLiAqL1xuICBjbG9zZSgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuX29wZW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcG9wdXBSZWYgJiYgdGhpcy5fcG9wdXBSZWYuaGFzQXR0YWNoZWQoKSkge1xuICAgICAgdGhpcy5fcG9wdXBSZWYuZGV0YWNoKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9kaWFsb2dSZWYpIHtcbiAgICAgIHRoaXMuX2RpYWxvZ1JlZi5jbG9zZSgpO1xuICAgICAgdGhpcy5fZGlhbG9nUmVmID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2NhbGVuZGFyUG9ydGFsICYmIHRoaXMuX2NhbGVuZGFyUG9ydGFsLmlzQXR0YWNoZWQpIHtcbiAgICAgIHRoaXMuX2NhbGVuZGFyUG9ydGFsLmRldGFjaCgpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbXBsZXRlQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAvLyBUaGUgYF9vcGVuZWRgIGNvdWxkJ3ZlIGJlZW4gcmVzZXQgYWxyZWFkeSBpZlxuICAgICAgLy8gd2UgZ290IHR3byBldmVudHMgaW4gcXVpY2sgc3VjY2Vzc2lvbi5cbiAgICAgIGlmICh0aGlzLl9vcGVuZWQpIHtcbiAgICAgICAgdGhpcy5fb3BlbmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2xvc2VkU3RyZWFtLmVtaXQoKTtcbiAgICAgICAgdGhpcy5fZm9jdXNlZEVsZW1lbnRCZWZvcmVPcGVuID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuX2ZvY3VzZWRFbGVtZW50QmVmb3JlT3BlbiAmJlxuICAgICAgdHlwZW9mIHRoaXMuX2ZvY3VzZWRFbGVtZW50QmVmb3JlT3Blbi5mb2N1cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQmVjYXVzZSBJRSBtb3ZlcyBmb2N1cyBhc3luY2hyb25vdXNseSwgd2UgY2FuJ3QgY291bnQgb24gaXQgYmVpbmcgcmVzdG9yZWQgYmVmb3JlIHdlJ3ZlXG4gICAgICAvLyBtYXJrZWQgdGhlIGRhdGVwaWNrZXIgYXMgY2xvc2VkLiBJZiB0aGUgZXZlbnQgZmlyZXMgb3V0IG9mIHNlcXVlbmNlIGFuZCB0aGUgZWxlbWVudCB0aGF0XG4gICAgICAvLyB3ZSdyZSByZWZvY3VzaW5nIG9wZW5zIHRoZSBkYXRlcGlja2VyIG9uIGZvY3VzLCB0aGUgdXNlciBjb3VsZCBiZSBzdHVjayB3aXRoIG5vdCBiZWluZ1xuICAgICAgLy8gYWJsZSB0byBjbG9zZSB0aGUgY2FsZW5kYXIgYXQgYWxsLiBXZSB3b3JrIGFyb3VuZCBpdCBieSBtYWtpbmcgdGhlIGxvZ2ljLCB0aGF0IG1hcmtzXG4gICAgICAvLyB0aGUgZGF0ZXBpY2tlciBhcyBjbG9zZWQsIGFzeW5jIGFzIHdlbGwuXG4gICAgICB0aGlzLl9mb2N1c2VkRWxlbWVudEJlZm9yZU9wZW4uZm9jdXMoKTtcbiAgICAgIHNldFRpbWVvdXQoY29tcGxldGVDbG9zZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBsZXRlQ2xvc2UoKTtcbiAgICB9XG4gIH1cblxuICAvKiogT3BlbiB0aGUgY2FsZW5kYXIgYXMgYSBkaWFsb2cuICovXG4gIHByaXZhdGUgX29wZW5Bc0RpYWxvZygpOiB2b2lkIHtcbiAgICB0aGlzLl9kaWFsb2dSZWYgPSB0aGlzLl9kaWFsb2cub3BlbjxTYXREYXRlcGlja2VyQ29udGVudDxEPj4oU2F0RGF0ZXBpY2tlckNvbnRlbnQsIHtcbiAgICAgIGRpcmVjdGlvbjogdGhpcy5fZGlyID8gdGhpcy5fZGlyLnZhbHVlIDogJ2x0cicsXG4gICAgICB2aWV3Q29udGFpbmVyUmVmOiB0aGlzLl92aWV3Q29udGFpbmVyUmVmLFxuICAgICAgcGFuZWxDbGFzczogJ21hdC1kYXRlcGlja2VyLWRpYWxvZycsXG4gICAgfSk7XG5cbiAgICB0aGlzLl9kaWFsb2dSZWYuYWZ0ZXJDbG9zZWQoKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jbG9zZSgpKTtcbiAgICB0aGlzLl9kaWFsb2dSZWYuY29tcG9uZW50SW5zdGFuY2UuZGF0ZXBpY2tlciA9IHRoaXM7XG4gICAgdGhpcy5fc2V0Q29sb3IoKTtcbiAgfVxuXG4gIC8qKiBPcGVuIHRoZSBjYWxlbmRhciBhcyBhIHBvcHVwLiAqL1xuICBwcml2YXRlIF9vcGVuQXNQb3B1cCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuX2NhbGVuZGFyUG9ydGFsKSB7XG4gICAgICB0aGlzLl9jYWxlbmRhclBvcnRhbCA9IG5ldyBDb21wb25lbnRQb3J0YWw8U2F0RGF0ZXBpY2tlckNvbnRlbnQ8RD4+KFNhdERhdGVwaWNrZXJDb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3BvcHVwUmVmKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fcG9wdXBSZWYuaGFzQXR0YWNoZWQoKSkge1xuICAgICAgdGhpcy5fcG9wdXBDb21wb25lbnRSZWYgPSB0aGlzLl9wb3B1cFJlZi5hdHRhY2godGhpcy5fY2FsZW5kYXJQb3J0YWwpO1xuICAgICAgdGhpcy5fcG9wdXBDb21wb25lbnRSZWYuaW5zdGFuY2UuZGF0ZXBpY2tlciA9IHRoaXM7XG4gICAgICB0aGlzLl9zZXRDb2xvcigpO1xuXG4gICAgICAvLyBVcGRhdGUgdGhlIHBvc2l0aW9uIG9uY2UgdGhlIGNhbGVuZGFyIGhhcyByZW5kZXJlZC5cbiAgICAgIHRoaXMuX25nWm9uZS5vblN0YWJsZS5hc09ic2VydmFibGUoKS5waXBlKHRha2UoMSkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuX3BvcHVwUmVmLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKiogQ3JlYXRlIHRoZSBwb3B1cC4gKi9cbiAgcHJpdmF0ZSBfY3JlYXRlUG9wdXAoKTogdm9pZCB7XG4gICAgY29uc3Qgb3ZlcmxheUNvbmZpZyA9IG5ldyBPdmVybGF5Q29uZmlnKHtcbiAgICAgIHBvc2l0aW9uU3RyYXRlZ3k6IHRoaXMuX2NyZWF0ZVBvcHVwUG9zaXRpb25TdHJhdGVneSgpLFxuICAgICAgaGFzQmFja2Ryb3A6IHRydWUsXG4gICAgICBiYWNrZHJvcENsYXNzOiAnbWF0LW92ZXJsYXktdHJhbnNwYXJlbnQtYmFja2Ryb3AnLFxuICAgICAgZGlyZWN0aW9uOiB0aGlzLl9kaXIsXG4gICAgICBzY3JvbGxTdHJhdGVneTogdGhpcy5fc2Nyb2xsU3RyYXRlZ3koKSxcbiAgICAgIHBhbmVsQ2xhc3M6ICdtYXQtZGF0ZXBpY2tlci1wb3B1cCcsXG4gICAgfSk7XG5cbiAgICB0aGlzLl9wb3B1cFJlZiA9IHRoaXMuX292ZXJsYXkuY3JlYXRlKG92ZXJsYXlDb25maWcpO1xuICAgIHRoaXMuX3BvcHVwUmVmLm92ZXJsYXlFbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdkaWFsb2cnKTtcblxuICAgIG1lcmdlKFxuICAgICAgdGhpcy5fcG9wdXBSZWYuYmFja2Ryb3BDbGljaygpLFxuICAgICAgdGhpcy5fcG9wdXBSZWYuZGV0YWNobWVudHMoKSxcbiAgICAgIHRoaXMuX3BvcHVwUmVmLmtleWRvd25FdmVudHMoKS5waXBlKGZpbHRlcihldmVudCA9PiB7XG4gICAgICAgIC8vIENsb3Npbmcgb24gYWx0ICsgdXAgaXMgb25seSB2YWxpZCB3aGVuIHRoZXJlJ3MgYW4gaW5wdXQgYXNzb2NpYXRlZCB3aXRoIHRoZSBkYXRlcGlja2VyLlxuICAgICAgICByZXR1cm4gZXZlbnQua2V5Q29kZSA9PT0gRVNDQVBFIHx8XG4gICAgICAgICAgICAgICAodGhpcy5fZGF0ZXBpY2tlcklucHV0ICYmIGV2ZW50LmFsdEtleSAmJiBldmVudC5rZXlDb2RlID09PSBVUF9BUlJPVyk7XG4gICAgICB9KSlcbiAgICApLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNsb3NlKCkpO1xuICB9XG5cbiAgLyoqIENyZWF0ZSB0aGUgcG9wdXAgUG9zaXRpb25TdHJhdGVneS4gKi9cbiAgcHJpdmF0ZSBfY3JlYXRlUG9wdXBQb3NpdGlvblN0cmF0ZWd5KCk6IFBvc2l0aW9uU3RyYXRlZ3kge1xuICAgIHJldHVybiB0aGlzLl9vdmVybGF5LnBvc2l0aW9uKClcbiAgICAgIC5mbGV4aWJsZUNvbm5lY3RlZFRvKHRoaXMuX2RhdGVwaWNrZXJJbnB1dC5nZXRDb25uZWN0ZWRPdmVybGF5T3JpZ2luKCkpXG4gICAgICAud2l0aFRyYW5zZm9ybU9yaWdpbk9uKCcubWF0LWRhdGVwaWNrZXItY29udGVudCcpXG4gICAgICAud2l0aEZsZXhpYmxlRGltZW5zaW9ucyhmYWxzZSlcbiAgICAgIC53aXRoVmlld3BvcnRNYXJnaW4oOClcbiAgICAgIC53aXRoUHVzaChmYWxzZSlcbiAgICAgIC53aXRoUG9zaXRpb25zKFtcbiAgICAgICAge1xuICAgICAgICAgIG9yaWdpblg6ICdzdGFydCcsXG4gICAgICAgICAgb3JpZ2luWTogJ2JvdHRvbScsXG4gICAgICAgICAgb3ZlcmxheVg6ICdzdGFydCcsXG4gICAgICAgICAgb3ZlcmxheVk6ICd0b3AnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBvcmlnaW5YOiAnc3RhcnQnLFxuICAgICAgICAgIG9yaWdpblk6ICd0b3AnLFxuICAgICAgICAgIG92ZXJsYXlYOiAnc3RhcnQnLFxuICAgICAgICAgIG92ZXJsYXlZOiAnYm90dG9tJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgb3JpZ2luWDogJ2VuZCcsXG4gICAgICAgICAgb3JpZ2luWTogJ2JvdHRvbScsXG4gICAgICAgICAgb3ZlcmxheVg6ICdlbmQnLFxuICAgICAgICAgIG92ZXJsYXlZOiAndG9wJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgb3JpZ2luWDogJ2VuZCcsXG4gICAgICAgICAgb3JpZ2luWTogJ3RvcCcsXG4gICAgICAgICAgb3ZlcmxheVg6ICdlbmQnLFxuICAgICAgICAgIG92ZXJsYXlZOiAnYm90dG9tJ1xuICAgICAgICB9XG4gICAgICBdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gb2JqIFRoZSBvYmplY3QgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIFRoZSBnaXZlbiBvYmplY3QgaWYgaXQgaXMgYm90aCBhIGRhdGUgaW5zdGFuY2UgYW5kIHZhbGlkLCBvdGhlcndpc2UgbnVsbC5cbiAgICovXG4gIHByaXZhdGUgX2dldFZhbGlkRGF0ZU9yTnVsbChvYmo6IGFueSk6IEQgfCBudWxsIHtcbiAgICByZXR1cm4gKHRoaXMuX2RhdGVBZGFwdGVyLmlzRGF0ZUluc3RhbmNlKG9iaikgJiYgdGhpcy5fZGF0ZUFkYXB0ZXIuaXNWYWxpZChvYmopKSA/IG9iaiA6IG51bGw7XG4gIH1cblxuICAvKiogUGFzc2VzIHRoZSBjdXJyZW50IHRoZW1lIGNvbG9yIGFsb25nIHRvIHRoZSBjYWxlbmRhciBvdmVybGF5LiAqL1xuICBwcml2YXRlIF9zZXRDb2xvcigpOiB2b2lkIHtcbiAgICBjb25zdCBjb2xvciA9IHRoaXMuY29sb3I7XG4gICAgaWYgKHRoaXMuX3BvcHVwQ29tcG9uZW50UmVmKSB7XG4gICAgICB0aGlzLl9wb3B1cENvbXBvbmVudFJlZi5pbnN0YW5jZS5jb2xvciA9IGNvbG9yO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZGlhbG9nUmVmKSB7XG4gICAgICB0aGlzLl9kaWFsb2dSZWYuY29tcG9uZW50SW5zdGFuY2UuY29sb3IgPSBjb2xvcjtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge2NvZXJjZUJvb2xlYW5Qcm9wZXJ0eX0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcbmltcG9ydCB7RE9XTl9BUlJPV30gZnJvbSAnQGFuZ3VsYXIvY2RrL2tleWNvZGVzJztcbmltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBmb3J3YXJkUmVmLFxuICBJbmplY3QsXG4gIElucHV0LFxuICBPbkRlc3Ryb3ksXG4gIE9wdGlvbmFsLFxuICBPdXRwdXQsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgQWJzdHJhY3RDb250cm9sLFxuICBDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAgTkdfVkFMSURBVE9SUyxcbiAgTkdfVkFMVUVfQUNDRVNTT1IsXG4gIFZhbGlkYXRpb25FcnJvcnMsXG4gIFZhbGlkYXRvcixcbiAgVmFsaWRhdG9yRm4sXG4gIFZhbGlkYXRvcnNcbn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtEYXRlQWRhcHRlcn0gZnJvbSAnLi4vZGF0ZXRpbWUvZGF0ZS1hZGFwdGVyJztcbmltcG9ydCB7TUFUX0RBVEVfRk9STUFUUywgTWF0RGF0ZUZvcm1hdHN9IGZyb20gJy4uL2RhdGV0aW1lL2RhdGUtZm9ybWF0cyc7XG5pbXBvcnQge01hdEZvcm1GaWVsZH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvZm9ybS1maWVsZCc7XG5pbXBvcnQge01BVF9JTlBVVF9WQUxVRV9BQ0NFU1NPUn0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvaW5wdXQnO1xuaW1wb3J0IHtTdWJzY3JpcHRpb259IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtTYXREYXRlcGlja2VyfSBmcm9tICcuL2RhdGVwaWNrZXInO1xuaW1wb3J0IHtjcmVhdGVNaXNzaW5nRGF0ZUltcGxFcnJvcn0gZnJvbSAnLi9kYXRlcGlja2VyLWVycm9ycyc7XG5cblxuZXhwb3J0IGNvbnN0IE1BVF9EQVRFUElDS0VSX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBTYXREYXRlcGlja2VySW5wdXQpLFxuICBtdWx0aTogdHJ1ZVxufTtcblxuXG5leHBvcnQgY29uc3QgTUFUX0RBVEVQSUNLRVJfVkFMSURBVE9SUzogYW55ID0ge1xuICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBTYXREYXRlcGlja2VySW5wdXQpLFxuICBtdWx0aTogdHJ1ZVxufTtcblxuLyoqXG4gKiBTcGVjaWFsIGludGVyZmFjZSB0byBpbnB1dCBhbmQgb3V0cHV0IGRhdGVzIGludGVydmFsLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNhdERhdGVwaWNrZXJSYW5nZVZhbHVlPEQ+IHtcbiAgYmVnaW46IEQgfCBudWxsO1xuICBlbmQ6IEQgfCBudWxsO1xufVxuXG4vKipcbiAqIEFuIGV2ZW50IHVzZWQgZm9yIGRhdGVwaWNrZXIgaW5wdXQgYW5kIGNoYW5nZSBldmVudHMuIFdlIGRvbid0IGFsd2F5cyBoYXZlIGFjY2VzcyB0byBhIG5hdGl2ZVxuICogaW5wdXQgb3IgY2hhbmdlIGV2ZW50IGJlY2F1c2UgdGhlIGV2ZW50IG1heSBoYXZlIGJlZW4gdHJpZ2dlcmVkIGJ5IHRoZSB1c2VyIGNsaWNraW5nIG9uIHRoZVxuICogY2FsZW5kYXIgcG9wdXAuIEZvciBjb25zaXN0ZW5jeSwgd2UgYWx3YXlzIHVzZSBTYXREYXRlcGlja2VySW5wdXRFdmVudCBpbnN0ZWFkLlxuICovXG5leHBvcnQgY2xhc3MgU2F0RGF0ZXBpY2tlcklucHV0RXZlbnQ8RD4ge1xuICAvKiogVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIHRhcmdldCBkYXRlcGlja2VyIGlucHV0LiAqL1xuICB2YWx1ZTogU2F0RGF0ZXBpY2tlclJhbmdlVmFsdWU8RD4gfCBEIHwgbnVsbDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICAvKiogUmVmZXJlbmNlIHRvIHRoZSBkYXRlcGlja2VyIGlucHV0IGNvbXBvbmVudCB0aGF0IGVtaXR0ZWQgdGhlIGV2ZW50LiAqL1xuICAgIHB1YmxpYyB0YXJnZXQ6IFNhdERhdGVwaWNrZXJJbnB1dDxEPixcbiAgICAvKiogUmVmZXJlbmNlIHRvIHRoZSBuYXRpdmUgaW5wdXQgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhlIGRhdGVwaWNrZXIgaW5wdXQuICovXG4gICAgcHVibGljIHRhcmdldEVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG4gICAgdGhpcy52YWx1ZSA9IHRoaXMudGFyZ2V0LnZhbHVlO1xuICB9XG59XG5cblxuLyoqIERpcmVjdGl2ZSB1c2VkIHRvIGNvbm5lY3QgYW4gaW5wdXQgdG8gYSBTYXREYXRlcGlja2VyLiAqL1xuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnaW5wdXRbc2F0RGF0ZXBpY2tlcl0nLFxuICBwcm92aWRlcnM6IFtcbiAgICBNQVRfREFURVBJQ0tFUl9WQUxVRV9BQ0NFU1NPUixcbiAgICBNQVRfREFURVBJQ0tFUl9WQUxJREFUT1JTLFxuICAgIHtwcm92aWRlOiBNQVRfSU5QVVRfVkFMVUVfQUNDRVNTT1IsIHVzZUV4aXN0aW5nOiBTYXREYXRlcGlja2VySW5wdXR9LFxuICBdLFxuICBob3N0OiB7XG4gICAgJ1thdHRyLmFyaWEtaGFzcG9wdXBdJzogJ3RydWUnLFxuICAgICdbYXR0ci5hcmlhLW93bnNdJzogJyhfZGF0ZXBpY2tlcj8ub3BlbmVkICYmIF9kYXRlcGlja2VyLmlkKSB8fCBudWxsJyxcbiAgICAnW2F0dHIubWluXSc6ICdtaW4gPyBfZGF0ZUFkYXB0ZXIudG9Jc284NjAxKG1pbikgOiBudWxsJyxcbiAgICAnW2F0dHIubWF4XSc6ICdtYXggPyBfZGF0ZUFkYXB0ZXIudG9Jc284NjAxKG1heCkgOiBudWxsJyxcbiAgICAnW2Rpc2FibGVkXSc6ICdkaXNhYmxlZCcsXG4gICAgJyhpbnB1dCknOiAnX29uSW5wdXQoJGV2ZW50LnRhcmdldC52YWx1ZSknLFxuICAgICcoY2hhbmdlKSc6ICdfb25DaGFuZ2UoKScsXG4gICAgJyhibHVyKSc6ICdfb25CbHVyKCknLFxuICAgICcoa2V5ZG93biknOiAnX29uS2V5ZG93bigkZXZlbnQpJyxcbiAgfSxcbiAgZXhwb3J0QXM6ICdtYXREYXRlcGlja2VySW5wdXQnLFxufSlcbmV4cG9ydCBjbGFzcyBTYXREYXRlcGlja2VySW5wdXQ8RD4gaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBDb250cm9sVmFsdWVBY2Nlc3NvciwgT25EZXN0cm95LFxuICAgIFZhbGlkYXRvciB7XG4gIC8qKiBUaGUgZGF0ZXBpY2tlciB0aGF0IHRoaXMgaW5wdXQgaXMgYXNzb2NpYXRlZCB3aXRoLiAqL1xuICBASW5wdXQoKVxuICBzZXQgc2F0RGF0ZXBpY2tlcih2YWx1ZTogU2F0RGF0ZXBpY2tlcjxEPikge1xuICAgIHRoaXMucmVnaXN0ZXJEYXRlcGlja2VyKHZhbHVlKTtcbiAgfVxuICBfZGF0ZXBpY2tlcjogU2F0RGF0ZXBpY2tlcjxEPjtcblxuICBwcml2YXRlIHJlZ2lzdGVyRGF0ZXBpY2tlcih2YWx1ZTogU2F0RGF0ZXBpY2tlcjxEPikge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5fZGF0ZXBpY2tlciA9IHZhbHVlO1xuICAgICAgdGhpcy5fZGF0ZXBpY2tlci5fcmVnaXN0ZXJJbnB1dCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICAvKiogRnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBmaWx0ZXIgb3V0IGRhdGVzIHdpdGhpbiB0aGUgZGF0ZXBpY2tlci4gKi9cbiAgQElucHV0KClcbiAgc2V0IG1hdERhdGVwaWNrZXJGaWx0ZXIodmFsdWU6IChkYXRlOiBEIHwgbnVsbCkgPT4gYm9vbGVhbikge1xuICAgIHRoaXMuX2RhdGVGaWx0ZXIgPSB2YWx1ZTtcbiAgICB0aGlzLl92YWxpZGF0b3JPbkNoYW5nZSgpO1xuICB9XG4gIF9kYXRlRmlsdGVyOiAoZGF0ZTogU2F0RGF0ZXBpY2tlclJhbmdlVmFsdWU8RD4gfCBEIHwgbnVsbCkgPT4gYm9vbGVhbjtcblxuICAvKiogVGhlIHZhbHVlIG9mIHRoZSBpbnB1dC4gKi9cbiAgQElucHV0KClcbiAgZ2V0IHZhbHVlKCk6IFNhdERhdGVwaWNrZXJSYW5nZVZhbHVlPEQ+IHwgRCB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuICBzZXQgdmFsdWUodmFsdWU6ICBTYXREYXRlcGlja2VyUmFuZ2VWYWx1ZTxEPiB8IEQgfCBudWxsKSB7XG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLmhhc093blByb3BlcnR5KCdiZWdpbicpICYmIHZhbHVlLmhhc093blByb3BlcnR5KCdlbmQnKSkge1xuICAgICAgLyoqIFJhbmdlIG1vZGUgKi9cbiAgICAgIGNvbnN0IHJhbmdlVmFsdWUgPSA8U2F0RGF0ZXBpY2tlclJhbmdlVmFsdWU8RD4+dmFsdWU7XG4gICAgICByYW5nZVZhbHVlLmJlZ2luID0gdGhpcy5fZGF0ZUFkYXB0ZXIuZGVzZXJpYWxpemUocmFuZ2VWYWx1ZS5iZWdpbik7XG4gICAgICByYW5nZVZhbHVlLmVuZCA9IHRoaXMuX2RhdGVBZGFwdGVyLmRlc2VyaWFsaXplKHJhbmdlVmFsdWUuZW5kKTtcbiAgICAgIHRoaXMuX2xhc3RWYWx1ZVZhbGlkID0gIXJhbmdlVmFsdWUuYmVnaW4gfHwgIXJhbmdlVmFsdWUuZW5kIHx8XG4gICAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIuaXNWYWxpZChyYW5nZVZhbHVlLmJlZ2luKSAmJiB0aGlzLl9kYXRlQWRhcHRlci5pc1ZhbGlkKHJhbmdlVmFsdWUuZW5kKTtcbiAgICAgIHJhbmdlVmFsdWUuYmVnaW4gPSB0aGlzLl9nZXRWYWxpZERhdGVPck51bGwocmFuZ2VWYWx1ZS5iZWdpbik7XG4gICAgICByYW5nZVZhbHVlLmVuZCA9IHRoaXMuX2dldFZhbGlkRGF0ZU9yTnVsbChyYW5nZVZhbHVlLmVuZCk7XG4gICAgICBsZXQgb2xkRGF0ZSA9IDxTYXREYXRlcGlja2VyUmFuZ2VWYWx1ZTxEPiB8IG51bGw+dGhpcy52YWx1ZTtcbiAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC52YWx1ZSA9XG4gICAgICAgICAgcmFuZ2VWYWx1ZSAmJiByYW5nZVZhbHVlLmJlZ2luICYmIHJhbmdlVmFsdWUuZW5kXG4gICAgICAgICAgICAgID8gdGhpcy5fZGF0ZUFkYXB0ZXIuZm9ybWF0KHJhbmdlVmFsdWUuYmVnaW4sIHRoaXMuX2RhdGVGb3JtYXRzLmRpc3BsYXkuZGF0ZUlucHV0KSArXG4gICAgICAgICAgICAgICAgJyAtICcgK1xuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGVBZGFwdGVyLmZvcm1hdChyYW5nZVZhbHVlLmVuZCwgdGhpcy5fZGF0ZUZvcm1hdHMuZGlzcGxheS5kYXRlSW5wdXQpXG4gICAgICAgICAgICAgIDogJyc7XG4gICAgICBpZiAob2xkRGF0ZSA9PSBudWxsICYmIHJhbmdlVmFsdWUgIT0gbnVsbCB8fCBvbGREYXRlICE9IG51bGwgJiYgcmFuZ2VWYWx1ZSA9PSBudWxsIHx8XG4gICAgICAgICAgIXRoaXMuX2RhdGVBZGFwdGVyLnNhbWVEYXRlKCg8U2F0RGF0ZXBpY2tlclJhbmdlVmFsdWU8RD4+b2xkRGF0ZSkuYmVnaW4sXG4gICAgICAgICAgICAgIHJhbmdlVmFsdWUuYmVnaW4pIHx8XG4gICAgICAgICAgIXRoaXMuX2RhdGVBZGFwdGVyLnNhbWVEYXRlKCg8U2F0RGF0ZXBpY2tlclJhbmdlVmFsdWU8RD4+b2xkRGF0ZSkuZW5kLFxuICAgICAgICAgICAgICByYW5nZVZhbHVlLmVuZCkpIHtcbiAgICAgICAgaWYgKHJhbmdlVmFsdWUuZW5kICYmIHJhbmdlVmFsdWUuYmVnaW4gJiZcbiAgICAgICAgICAgIHRoaXMuX2RhdGVBZGFwdGVyXG4gICAgICAgICAgICAgICAgLmNvbXBhcmVEYXRlKHJhbmdlVmFsdWUuYmVnaW4sIHJhbmdlVmFsdWUuZW5kICkgPiAwKSB7IC8vIGlmIGJlZ2luID4gZW5kXG4gICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3ZhbHVlQ2hhbmdlLmVtaXQodmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiogTm90IHJhbmdlIG1vZGUgKi9cbiAgICAgIHZhbHVlID0gdGhpcy5fZGF0ZUFkYXB0ZXIuZGVzZXJpYWxpemUodmFsdWUpO1xuICAgICAgdGhpcy5fbGFzdFZhbHVlVmFsaWQgPSAhdmFsdWUgfHwgdGhpcy5fZGF0ZUFkYXB0ZXIuaXNWYWxpZCh2YWx1ZSk7XG4gICAgICB2YWx1ZSA9IHRoaXMuX2dldFZhbGlkRGF0ZU9yTnVsbCh2YWx1ZSk7XG4gICAgICBsZXQgb2xkRGF0ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlID1cbiAgICAgICAgICB2YWx1ZSA/IHRoaXMuX2RhdGVBZGFwdGVyLmZvcm1hdCh2YWx1ZSwgdGhpcy5fZGF0ZUZvcm1hdHMuZGlzcGxheS5kYXRlSW5wdXQpIDogJyc7XG4gICAgICBpZiAoIXRoaXMuX2RhdGVBZGFwdGVyLnNhbWVEYXRlKDxEPm9sZERhdGUsIHZhbHVlKSkge1xuICAgICAgICB0aGlzLl92YWx1ZUNoYW5nZS5lbWl0KHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcHJpdmF0ZSBfdmFsdWU6IFNhdERhdGVwaWNrZXJSYW5nZVZhbHVlPEQ+IHwgRCB8IG51bGw7XG5cbiAgLyoqIFRoZSBtaW5pbXVtIHZhbGlkIGRhdGUuICovXG4gIEBJbnB1dCgpXG4gIGdldCBtaW4oKTogRCB8IG51bGwgeyByZXR1cm4gdGhpcy5fbWluOyB9XG4gIHNldCBtaW4odmFsdWU6IEQgfCBudWxsKSB7XG4gICAgdGhpcy5fbWluID0gdGhpcy5fZ2V0VmFsaWREYXRlT3JOdWxsKHRoaXMuX2RhdGVBZGFwdGVyLmRlc2VyaWFsaXplKHZhbHVlKSk7XG4gICAgdGhpcy5fdmFsaWRhdG9yT25DaGFuZ2UoKTtcbiAgfVxuICBwcml2YXRlIF9taW46IEQgfCBudWxsO1xuXG4gIC8qKiBUaGUgbWF4aW11bSB2YWxpZCBkYXRlLiAqL1xuICBASW5wdXQoKVxuICBnZXQgbWF4KCk6IEQgfCBudWxsIHsgcmV0dXJuIHRoaXMuX21heDsgfVxuICBzZXQgbWF4KHZhbHVlOiBEIHwgbnVsbCkge1xuICAgIHRoaXMuX21heCA9IHRoaXMuX2dldFZhbGlkRGF0ZU9yTnVsbCh0aGlzLl9kYXRlQWRhcHRlci5kZXNlcmlhbGl6ZSh2YWx1ZSkpO1xuICAgIHRoaXMuX3ZhbGlkYXRvck9uQ2hhbmdlKCk7XG4gIH1cbiAgcHJpdmF0ZSBfbWF4OiBEIHwgbnVsbDtcblxuICAvKiogV2hldGhlciB0aGUgZGF0ZXBpY2tlci1pbnB1dCBpcyBkaXNhYmxlZC4gKi9cbiAgQElucHV0KClcbiAgZ2V0IGRpc2FibGVkKCk6IGJvb2xlYW4geyByZXR1cm4gISF0aGlzLl9kaXNhYmxlZDsgfVxuICBzZXQgZGlzYWJsZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcblxuICAgIGlmICh0aGlzLl9kaXNhYmxlZCAhPT0gbmV3VmFsdWUpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVkID0gbmV3VmFsdWU7XG4gICAgICB0aGlzLl9kaXNhYmxlZENoYW5nZS5lbWl0KG5ld1ZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBXZSBuZWVkIHRvIG51bGwgY2hlY2sgdGhlIGBibHVyYCBtZXRob2QsIGJlY2F1c2UgaXQncyB1bmRlZmluZWQgZHVyaW5nIFNTUi5cbiAgICBpZiAobmV3VmFsdWUgJiYgZWxlbWVudC5ibHVyKSB7XG4gICAgICAvLyBOb3JtYWxseSwgbmF0aXZlIGlucHV0IGVsZW1lbnRzIGF1dG9tYXRpY2FsbHkgYmx1ciBpZiB0aGV5IHR1cm4gZGlzYWJsZWQuIFRoaXMgYmVoYXZpb3JcbiAgICAgIC8vIGlzIHByb2JsZW1hdGljLCBiZWNhdXNlIGl0IHdvdWxkIG1lYW4gdGhhdCBpdCB0cmlnZ2VycyBhbm90aGVyIGNoYW5nZSBkZXRlY3Rpb24gY3ljbGUsXG4gICAgICAvLyB3aGljaCB0aGVuIGNhdXNlcyBhIGNoYW5nZWQgYWZ0ZXIgY2hlY2tlZCBlcnJvciBpZiB0aGUgaW5wdXQgZWxlbWVudCB3YXMgZm9jdXNlZCBiZWZvcmUuXG4gICAgICBlbGVtZW50LmJsdXIoKTtcbiAgICB9XG4gIH1cbiAgcHJpdmF0ZSBfZGlzYWJsZWQ6IGJvb2xlYW47XG5cbiAgLyoqIEVtaXRzIHdoZW4gYSBgY2hhbmdlYCBldmVudCBpcyBmaXJlZCBvbiB0aGlzIGA8aW5wdXQ+YC4gKi9cbiAgQE91dHB1dCgpIHJlYWRvbmx5IGRhdGVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxTYXREYXRlcGlja2VySW5wdXRFdmVudDxEPj4gPVxuICAgICAgbmV3IEV2ZW50RW1pdHRlcjxTYXREYXRlcGlja2VySW5wdXRFdmVudDxEPj4oKTtcblxuICAvKiogRW1pdHMgd2hlbiBhbiBgaW5wdXRgIGV2ZW50IGlzIGZpcmVkIG9uIHRoaXMgYDxpbnB1dD5gLiAqL1xuICBAT3V0cHV0KCkgcmVhZG9ubHkgZGF0ZUlucHV0OiBFdmVudEVtaXR0ZXI8U2F0RGF0ZXBpY2tlcklucHV0RXZlbnQ8RD4+ID1cbiAgICAgIG5ldyBFdmVudEVtaXR0ZXI8U2F0RGF0ZXBpY2tlcklucHV0RXZlbnQ8RD4+KCk7XG5cbiAgLyoqIEVtaXRzIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMgKGVpdGhlciBkdWUgdG8gdXNlciBpbnB1dCBvciBwcm9ncmFtbWF0aWMgY2hhbmdlKS4gKi9cbiAgX3ZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxTYXREYXRlcGlja2VyUmFuZ2VWYWx1ZTxEPnxEfG51bGw+KCk7XG5cbiAgLyoqIEVtaXRzIHdoZW4gdGhlIGRpc2FibGVkIHN0YXRlIGhhcyBjaGFuZ2VkICovXG4gIF9kaXNhYmxlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICBfb25Ub3VjaGVkID0gKCkgPT4ge307XG5cbiAgcHJpdmF0ZSBfY3ZhT25DaGFuZ2U6ICh2YWx1ZTogYW55KSA9PiB2b2lkID0gKCkgPT4ge307XG5cbiAgcHJpdmF0ZSBfdmFsaWRhdG9yT25DaGFuZ2UgPSAoKSA9PiB7fTtcblxuICBwcml2YXRlIF9kYXRlcGlja2VyU3Vic2NyaXB0aW9uID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xuXG4gIHByaXZhdGUgX2xvY2FsZVN1YnNjcmlwdGlvbiA9IFN1YnNjcmlwdGlvbi5FTVBUWTtcblxuICAvKiogVGhlIGZvcm0gY29udHJvbCB2YWxpZGF0b3IgZm9yIHdoZXRoZXIgdGhlIGlucHV0IHBhcnNlcy4gKi9cbiAgcHJpdmF0ZSBfcGFyc2VWYWxpZGF0b3I6IFZhbGlkYXRvckZuID0gKCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+IHtcbiAgICByZXR1cm4gdGhpcy5fbGFzdFZhbHVlVmFsaWQgP1xuICAgICAgICBudWxsIDogeydtYXREYXRlcGlja2VyUGFyc2UnOiB7J3RleHQnOiB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWV9fTtcbiAgfVxuXG4gIC8qKiBUaGUgZm9ybSBjb250cm9sIHZhbGlkYXRvciBmb3IgdGhlIG1pbiBkYXRlLiAqL1xuICBwcml2YXRlIF9taW5WYWxpZGF0b3I6IFZhbGlkYXRvckZuID0gKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+IHtcbiAgICBpZiAodGhpcy5fZGF0ZXBpY2tlci5yYW5nZU1vZGUgJiYgY29udHJvbC52YWx1ZSkge1xuICAgICAgY29uc3QgYmVnaW5EYXRlID1cbiAgICAgICAgICB0aGlzLl9nZXRWYWxpZERhdGVPck51bGwodGhpcy5fZGF0ZUFkYXB0ZXIuZGVzZXJpYWxpemUoY29udHJvbC52YWx1ZS5iZWdpbikpO1xuICAgICAgY29uc3QgZW5kRGF0ZSA9XG4gICAgICAgICAgdGhpcy5fZ2V0VmFsaWREYXRlT3JOdWxsKHRoaXMuX2RhdGVBZGFwdGVyLmRlc2VyaWFsaXplKGNvbnRyb2wudmFsdWUuZW5kKSk7XG4gICAgICBpZiAodGhpcy5taW4pIHtcbiAgICAgICAgaWYgKGJlZ2luRGF0ZSAmJiB0aGlzLl9kYXRlQWRhcHRlci5jb21wYXJlRGF0ZSh0aGlzLm1pbiwgYmVnaW5EYXRlKSA+IDApIHtcbiAgICAgICAgICByZXR1cm4geydtYXREYXRlcGlja2VyTWluJzogeydtaW4nOiB0aGlzLm1pbiwgJ2FjdHVhbCc6IGJlZ2luRGF0ZX19O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmREYXRlICYmIHRoaXMuX2RhdGVBZGFwdGVyLmNvbXBhcmVEYXRlKHRoaXMubWluLCBlbmREYXRlKSA+IDApIHtcbiAgICAgICAgICByZXR1cm4geydtYXREYXRlcGlja2VyTWluJzogeydtaW4nOiB0aGlzLm1pbiwgJ2FjdHVhbCc6IGVuZERhdGV9fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRyb2xWYWx1ZSA9IHRoaXMuX2dldFZhbGlkRGF0ZU9yTnVsbCh0aGlzLl9kYXRlQWRhcHRlci5kZXNlcmlhbGl6ZShjb250cm9sLnZhbHVlKSk7XG4gICAgcmV0dXJuICghdGhpcy5taW4gfHwgIWNvbnRyb2xWYWx1ZSB8fFxuICAgICAgICB0aGlzLl9kYXRlQWRhcHRlci5jb21wYXJlRGF0ZSh0aGlzLm1pbiwgY29udHJvbFZhbHVlKSA8PSAwKSA/XG4gICAgICAgIG51bGwgOiB7J21hdERhdGVwaWNrZXJNaW4nOiB7J21pbic6IHRoaXMubWluLCAnYWN0dWFsJzogY29udHJvbFZhbHVlfX07XG4gIH1cblxuICAvKiogVGhlIGZvcm0gY29udHJvbCB2YWxpZGF0b3IgZm9yIHRoZSBtYXggZGF0ZS4gKi9cbiAgcHJpdmF0ZSBfbWF4VmFsaWRhdG9yOiBWYWxpZGF0b3JGbiA9IChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PiB7XG4gICAgaWYgKHRoaXMuX2RhdGVwaWNrZXIucmFuZ2VNb2RlICYmIGNvbnRyb2wudmFsdWUpIHtcbiAgICAgIGNvbnN0IGJlZ2luRGF0ZSA9XG4gICAgICAgICAgdGhpcy5fZ2V0VmFsaWREYXRlT3JOdWxsKHRoaXMuX2RhdGVBZGFwdGVyLmRlc2VyaWFsaXplKGNvbnRyb2wudmFsdWUuYmVnaW4pKTtcbiAgICAgIGNvbnN0IGVuZERhdGUgPSB0aGlzLl9nZXRWYWxpZERhdGVPck51bGwodGhpcy5fZGF0ZUFkYXB0ZXIuZGVzZXJpYWxpemUoY29udHJvbC52YWx1ZS5lbmQpKTtcbiAgICAgIGlmICh0aGlzLm1heCkge1xuICAgICAgICBpZiAoYmVnaW5EYXRlICYmIHRoaXMuX2RhdGVBZGFwdGVyLmNvbXBhcmVEYXRlKHRoaXMubWF4LCBiZWdpbkRhdGUpIDwgMCApIHtcbiAgICAgICAgICByZXR1cm4geydtYXREYXRlcGlja2VyTWF4JzogeydtYXgnOiB0aGlzLm1heCwgJ2FjdHVhbCc6IGJlZ2luRGF0ZX19O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmREYXRlICYmIHRoaXMuX2RhdGVBZGFwdGVyLmNvbXBhcmVEYXRlKHRoaXMubWF4LCBlbmREYXRlKSA8IDApIHtcbiAgICAgICAgICByZXR1cm4geydtYXREYXRlcGlja2VyTWF4JzogeydtYXgnOiB0aGlzLm1heCwgJ2FjdHVhbCc6IGVuZERhdGV9fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRyb2xWYWx1ZSA9IHRoaXMuX2dldFZhbGlkRGF0ZU9yTnVsbCh0aGlzLl9kYXRlQWRhcHRlci5kZXNlcmlhbGl6ZShjb250cm9sLnZhbHVlKSk7XG4gICAgcmV0dXJuICghdGhpcy5tYXggfHwgIWNvbnRyb2xWYWx1ZSB8fFxuICAgICAgICB0aGlzLl9kYXRlQWRhcHRlci5jb21wYXJlRGF0ZSh0aGlzLm1heCwgY29udHJvbFZhbHVlKSA+PSAwKSA/XG4gICAgICAgIG51bGwgOiB7J21hdERhdGVwaWNrZXJNYXgnOiB7J21heCc6IHRoaXMubWF4LCAnYWN0dWFsJzogY29udHJvbFZhbHVlfX07XG4gIH1cblxuICAvKiogVGhlIGZvcm0gY29udHJvbCB2YWxpZGF0b3IgZm9yIHRoZSBkYXRlIGZpbHRlci4gKi9cbiAgcHJpdmF0ZSBfZmlsdGVyVmFsaWRhdG9yOiBWYWxpZGF0b3JGbiA9IChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PiB7XG4gICAgaWYgKHRoaXMuX2RhdGVwaWNrZXIucmFuZ2VNb2RlICYmIGNvbnRyb2wudmFsdWUpIHtcbiAgICAgIGNvbnN0IGJlZ2luRGF0ZSA9XG4gICAgICAgICAgdGhpcy5fZ2V0VmFsaWREYXRlT3JOdWxsKHRoaXMuX2RhdGVBZGFwdGVyLmRlc2VyaWFsaXplKGNvbnRyb2wudmFsdWUuYmVnaW4pKTtcbiAgICAgIGNvbnN0IGVuZERhdGUgPSB0aGlzLl9nZXRWYWxpZERhdGVPck51bGwodGhpcy5fZGF0ZUFkYXB0ZXIuZGVzZXJpYWxpemUoY29udHJvbC52YWx1ZS5lbmQpKTtcbiAgICAgIHJldHVybiAhdGhpcy5fZGF0ZUZpbHRlciB8fCAhYmVnaW5EYXRlICYmICFlbmREYXRlIHx8XG4gICAgICAgICAgdGhpcy5fZGF0ZUZpbHRlcihiZWdpbkRhdGUpICYmIHRoaXMuX2RhdGVGaWx0ZXIoZW5kRGF0ZSkgP1xuICAgICAgICBudWxsIDogeydtYXREYXRlcGlja2VyRmlsdGVyJzogdHJ1ZX07XG4gICAgfVxuICAgIGNvbnN0IGNvbnRyb2xWYWx1ZSA9IHRoaXMuX2dldFZhbGlkRGF0ZU9yTnVsbCh0aGlzLl9kYXRlQWRhcHRlci5kZXNlcmlhbGl6ZShjb250cm9sLnZhbHVlKSk7XG4gICAgcmV0dXJuICF0aGlzLl9kYXRlRmlsdGVyIHx8ICFjb250cm9sVmFsdWUgfHwgdGhpcy5fZGF0ZUZpbHRlcihjb250cm9sVmFsdWUpID9cbiAgICAgICAgbnVsbCA6IHsnbWF0RGF0ZXBpY2tlckZpbHRlcic6IHRydWV9O1xuICB9XG5cbiAgLyoqIFRoZSBmb3JtIGNvbnRyb2wgdmFsaWRhdG9yIGZvciB0aGUgZGF0ZSBmaWx0ZXIuICovXG4gIHByaXZhdGUgX3JhbmdlVmFsaWRhdG9yOiBWYWxpZGF0b3JGbiA9IChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PiB7XG4gICAgaWYgKHRoaXMuX2RhdGVwaWNrZXIucmFuZ2VNb2RlICYmIGNvbnRyb2wudmFsdWUpIHtcbiAgICAgIGNvbnN0IGJlZ2luRGF0ZSA9XG4gICAgICAgICAgdGhpcy5fZ2V0VmFsaWREYXRlT3JOdWxsKHRoaXMuX2RhdGVBZGFwdGVyLmRlc2VyaWFsaXplKGNvbnRyb2wudmFsdWUuYmVnaW4pKTtcbiAgICAgIGNvbnN0IGVuZERhdGUgPSB0aGlzLl9nZXRWYWxpZERhdGVPck51bGwodGhpcy5fZGF0ZUFkYXB0ZXIuZGVzZXJpYWxpemUoY29udHJvbC52YWx1ZS5lbmQpKTtcbiAgICAgIHJldHVybiAhYmVnaW5EYXRlIHx8ICFlbmREYXRlIHx8IHRoaXMuX2RhdGVBZGFwdGVyLmNvbXBhcmVEYXRlKGJlZ2luRGF0ZSwgZW5kRGF0ZSkgPD0gMCA/XG4gICAgICAgIG51bGwgOiB7J21hdERhdGVwaWNrZXJSYW5nZSc6IHRydWV9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKiBUaGUgY29tYmluZWQgZm9ybSBjb250cm9sIHZhbGlkYXRvciBmb3IgdGhpcyBpbnB1dC4gKi9cbiAgcHJpdmF0ZSBfdmFsaWRhdG9yOiBWYWxpZGF0b3JGbiB8IG51bGwgPVxuICAgICAgVmFsaWRhdG9ycy5jb21wb3NlKFxuICAgICAgICAgIFt0aGlzLl9wYXJzZVZhbGlkYXRvciwgdGhpcy5fbWluVmFsaWRhdG9yLCB0aGlzLl9tYXhWYWxpZGF0b3IsXG4gICAgICAgICAgICB0aGlzLl9maWx0ZXJWYWxpZGF0b3IsIHRoaXMuX3JhbmdlVmFsaWRhdG9yXSk7XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGxhc3QgdmFsdWUgc2V0IG9uIHRoZSBpbnB1dCB3YXMgdmFsaWQuICovXG4gIHByaXZhdGUgX2xhc3RWYWx1ZVZhbGlkID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgQE9wdGlvbmFsKCkgcHVibGljIF9kYXRlQWRhcHRlcjogRGF0ZUFkYXB0ZXI8RD4sXG4gICAgICBAT3B0aW9uYWwoKSBASW5qZWN0KE1BVF9EQVRFX0ZPUk1BVFMpIHByaXZhdGUgX2RhdGVGb3JtYXRzOiBNYXREYXRlRm9ybWF0cyxcbiAgICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX2Zvcm1GaWVsZDogTWF0Rm9ybUZpZWxkKSB7XG4gICAgaWYgKCF0aGlzLl9kYXRlQWRhcHRlcikge1xuICAgICAgdGhyb3cgY3JlYXRlTWlzc2luZ0RhdGVJbXBsRXJyb3IoJ0RhdGVBZGFwdGVyJyk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fZGF0ZUZvcm1hdHMpIHtcbiAgICAgIHRocm93IGNyZWF0ZU1pc3NpbmdEYXRlSW1wbEVycm9yKCdNQVRfREFURV9GT1JNQVRTJyk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSBkaXNwbGF5ZWQgZGF0ZSB3aGVuIHRoZSBsb2NhbGUgY2hhbmdlcy5cbiAgICB0aGlzLl9sb2NhbGVTdWJzY3JpcHRpb24gPSBfZGF0ZUFkYXB0ZXIubG9jYWxlQ2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgfSk7XG4gIH1cblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgaWYgKHRoaXMuX2RhdGVwaWNrZXIpIHtcbiAgICAgIHRoaXMuX2RhdGVwaWNrZXJTdWJzY3JpcHRpb24gPVxuICAgICAgICAgIHRoaXMuX2RhdGVwaWNrZXIuX3NlbGVjdGVkQ2hhbmdlZC5zdWJzY3JpYmUoKHNlbGVjdGVkOiBTYXREYXRlcGlja2VyUmFuZ2VWYWx1ZTxEPiB8IEQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBzZWxlY3RlZDtcbiAgICAgICAgICAgIHRoaXMuX2N2YU9uQ2hhbmdlKHNlbGVjdGVkKTtcbiAgICAgICAgICAgIHRoaXMuX29uVG91Y2hlZCgpO1xuICAgICAgICAgICAgdGhpcy5kYXRlSW5wdXQuZW1pdChuZXcgU2F0RGF0ZXBpY2tlcklucHV0RXZlbnQodGhpcywgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KSk7XG4gICAgICAgICAgICB0aGlzLmRhdGVDaGFuZ2UuZW1pdChuZXcgU2F0RGF0ZXBpY2tlcklucHV0RXZlbnQodGhpcywgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KSk7XG4gICAgICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5fZGF0ZXBpY2tlclN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIHRoaXMuX2xvY2FsZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIHRoaXMuX3ZhbHVlQ2hhbmdlLmNvbXBsZXRlKCk7XG4gICAgdGhpcy5fZGlzYWJsZWRDaGFuZ2UuY29tcGxldGUoKTtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZm46ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLl92YWxpZGF0b3JPbkNoYW5nZSA9IGZuO1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgdmFsaWRhdGUoYzogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLl92YWxpZGF0b3IgPyB0aGlzLl92YWxpZGF0b3IoYykgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEBkZWxldGlvbi10YXJnZXQgNy4wLjAgVXNlIGBnZXRDb25uZWN0ZWRPdmVybGF5T3JpZ2luYCBpbnN0ZWFkXG4gICAqL1xuICBnZXRQb3B1cENvbm5lY3Rpb25FbGVtZW50UmVmKCk6IEVsZW1lbnRSZWYge1xuICAgIHJldHVybiB0aGlzLmdldENvbm5lY3RlZE92ZXJsYXlPcmlnaW4oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBlbGVtZW50IHRoYXQgdGhlIGRhdGVwaWNrZXIgcG9wdXAgc2hvdWxkIGJlIGNvbm5lY3RlZCB0by5cbiAgICogQHJldHVybiBUaGUgZWxlbWVudCB0byBjb25uZWN0IHRoZSBwb3B1cCB0by5cbiAgICovXG4gIGdldENvbm5lY3RlZE92ZXJsYXlPcmlnaW4oKTogRWxlbWVudFJlZiB7XG4gICAgcmV0dXJuIHRoaXMuX2Zvcm1GaWVsZCA/IHRoaXMuX2Zvcm1GaWVsZC5nZXRDb25uZWN0ZWRPdmVybGF5T3JpZ2luKCkgOiB0aGlzLl9lbGVtZW50UmVmO1xuICB9XG5cbiAgLy8gSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3NvclxuICB3cml0ZVZhbHVlKHZhbHVlOiBTYXREYXRlcGlja2VyUmFuZ2VWYWx1ZTxEPiB8IEQpOiB2b2lkIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICAvLyBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICByZWdpc3Rlck9uQ2hhbmdlKGZuOiAodmFsdWU6IGFueSkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMuX2N2YU9uQ2hhbmdlID0gZm47XG4gIH1cblxuICAvLyBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICByZWdpc3Rlck9uVG91Y2hlZChmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMuX29uVG91Y2hlZCA9IGZuO1xuICB9XG5cbiAgLy8gSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gIH1cblxuICBfb25LZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmFsdEtleSAmJiBldmVudC5rZXlDb2RlID09PSBET1dOX0FSUk9XKSB7XG4gICAgICB0aGlzLl9kYXRlcGlja2VyLm9wZW4oKTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG5cbiAgX29uSW5wdXQodmFsdWU6IHN0cmluZykge1xuICAgIGxldCBkYXRlOiBTYXREYXRlcGlja2VyUmFuZ2VWYWx1ZTxEPnxEfG51bGwgPSBudWxsO1xuICAgIGlmICh0aGlzLl9kYXRlcGlja2VyLnJhbmdlTW9kZSkge1xuICAgICAgY29uc3QgcGFydHMgPSB2YWx1ZS5zcGxpdCgnLScpO1xuICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IE1hdGguZmxvb3IocGFydHMubGVuZ3RoIC8gMik7XG4gICAgICAgICAgY29uc3QgYmVnaW5EYXRlU3RyaW5nID0gcGFydHMuc2xpY2UoMCwgcG9zaXRpb24pLmpvaW4oJy0nKTtcbiAgICAgICAgICBjb25zdCBlbmREYXRlU3RyaW5nID0gcGFydHMuc2xpY2UocG9zaXRpb24pLmpvaW4oJy0nKTtcbiAgICAgICAgICBsZXQgYmVnaW5EYXRlID0gdGhpcy5fZGF0ZUFkYXB0ZXIucGFyc2UoYmVnaW5EYXRlU3RyaW5nLFxuICAgICAgICAgICAgICB0aGlzLl9kYXRlRm9ybWF0cy5wYXJzZS5kYXRlSW5wdXQpO1xuICAgICAgICAgIGxldCBlbmREYXRlID0gdGhpcy5fZGF0ZUFkYXB0ZXIucGFyc2UoZW5kRGF0ZVN0cmluZywgdGhpcy5fZGF0ZUZvcm1hdHMucGFyc2UuZGF0ZUlucHV0KTtcbiAgICAgICAgICB0aGlzLl9sYXN0VmFsdWVWYWxpZCA9ICFiZWdpbkRhdGUgfHwgIWVuZERhdGUgfHwgdGhpcy5fZGF0ZUFkYXB0ZXIuaXNWYWxpZChiZWdpbkRhdGUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGVBZGFwdGVyLmlzVmFsaWQoZW5kRGF0ZSk7XG4gICAgICAgICAgYmVnaW5EYXRlID0gdGhpcy5fZ2V0VmFsaWREYXRlT3JOdWxsKGJlZ2luRGF0ZSk7XG4gICAgICAgICAgZW5kRGF0ZSA9IHRoaXMuX2dldFZhbGlkRGF0ZU9yTnVsbChlbmREYXRlKTtcbiAgICAgICAgICBpZiAoYmVnaW5EYXRlICYmIGVuZERhdGUpIHtcbiAgICAgICAgICAgIGRhdGUgPSA8U2F0RGF0ZXBpY2tlclJhbmdlVmFsdWU8RD4+e2JlZ2luOiBiZWdpbkRhdGUsIGVuZDogZW5kRGF0ZX07XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkYXRlID0gdGhpcy5fZGF0ZUFkYXB0ZXIucGFyc2UodmFsdWUsIHRoaXMuX2RhdGVGb3JtYXRzLnBhcnNlLmRhdGVJbnB1dCk7XG4gICAgICB0aGlzLl9sYXN0VmFsdWVWYWxpZCA9ICFkYXRlIHx8IHRoaXMuX2RhdGVBZGFwdGVyLmlzVmFsaWQoZGF0ZSk7XG4gICAgICBkYXRlID0gdGhpcy5fZ2V0VmFsaWREYXRlT3JOdWxsKGRhdGUpO1xuICAgIH1cbiAgICB0aGlzLl92YWx1ZSA9IGRhdGU7XG4gICAgdGhpcy5fY3ZhT25DaGFuZ2UoZGF0ZSk7XG4gICAgdGhpcy5fdmFsdWVDaGFuZ2UuZW1pdChkYXRlKTtcbiAgICB0aGlzLmRhdGVJbnB1dC5lbWl0KG5ldyBTYXREYXRlcGlja2VySW5wdXRFdmVudCh0aGlzLCB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpKTtcbiAgfVxuXG4gIF9vbkNoYW5nZSgpIHtcbiAgICB0aGlzLmRhdGVDaGFuZ2UuZW1pdChuZXcgU2F0RGF0ZXBpY2tlcklucHV0RXZlbnQodGhpcywgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KSk7XG4gIH1cblxuICAvKiogUmV0dXJucyB0aGUgcGFsZXR0ZSB1c2VkIGJ5IHRoZSBpbnB1dCdzIGZvcm0gZmllbGQsIGlmIGFueS4gKi9cbiAgX2dldFRoZW1lUGFsZXR0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9ybUZpZWxkID8gdGhpcy5fZm9ybUZpZWxkLmNvbG9yIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqIEhhbmRsZXMgYmx1ciBldmVudHMgb24gdGhlIGlucHV0LiAqL1xuICBfb25CbHVyKCkge1xuICAgIC8vIFJlZm9ybWF0IHRoZSBpbnB1dCBvbmx5IGlmIHdlIGhhdmUgYSB2YWxpZCB2YWx1ZS5cbiAgICBpZiAodGhpcy52YWx1ZSkge1xuICAgICAgdGhpcy5fZm9ybWF0VmFsdWUodGhpcy52YWx1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fb25Ub3VjaGVkKCk7XG4gIH1cblxuICAvKiogRm9ybWF0cyBhIHZhbHVlIGFuZCBzZXRzIGl0IG9uIHRoZSBpbnB1dCBlbGVtZW50LiAqL1xuICBwcml2YXRlIF9mb3JtYXRWYWx1ZSh2YWx1ZTogU2F0RGF0ZXBpY2tlclJhbmdlVmFsdWU8RD4gfCBEIHwgbnVsbCkge1xuICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmhhc093blByb3BlcnR5KCdiZWdpbicpICYmIHZhbHVlLmhhc093blByb3BlcnR5KCdlbmQnKSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUgYXMgU2F0RGF0ZXBpY2tlclJhbmdlVmFsdWU8RD5cbiAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWUgPVxuICAgICAgICAgICAgICB2YWx1ZSAmJiB2YWx1ZS5iZWdpbiAmJiB2YWx1ZS5lbmRcbiAgICAgICAgICAgICAgICAgID8gdGhpcy5fZGF0ZUFkYXB0ZXIuZm9ybWF0KHZhbHVlLmJlZ2luLCB0aGlzLl9kYXRlRm9ybWF0cy5kaXNwbGF5LmRhdGVJbnB1dCkgK1xuICAgICAgICAgICAgICAgICAgJyAtICcgK1xuICAgICAgICAgICAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIuZm9ybWF0KHZhbHVlLmVuZCwgdGhpcy5fZGF0ZUZvcm1hdHMuZGlzcGxheS5kYXRlSW5wdXQpXG4gICAgICAgICAgICAgICAgICA6ICcnXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgYXMgRCB8IG51bGxcbiAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWUgPVxuICAgICAgICAgICAgICB2YWx1ZSA/IHRoaXMuX2RhdGVBZGFwdGVyLmZvcm1hdCh2YWx1ZSwgdGhpcy5fZGF0ZUZvcm1hdHMuZGlzcGxheS5kYXRlSW5wdXQpIDogJyc7XG4gICAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIG9iaiBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyBUaGUgZ2l2ZW4gb2JqZWN0IGlmIGl0IGlzIGJvdGggYSBkYXRlIGluc3RhbmNlIGFuZCB2YWxpZCwgb3RoZXJ3aXNlIG51bGwuXG4gICAqL1xuICBwcml2YXRlIF9nZXRWYWxpZERhdGVPck51bGwob2JqOiBhbnkpOiBEIHwgbnVsbCB7XG4gICAgcmV0dXJuICh0aGlzLl9kYXRlQWRhcHRlci5pc0RhdGVJbnN0YW5jZShvYmopICYmIHRoaXMuX2RhdGVBZGFwdGVyLmlzVmFsaWQob2JqKSkgPyBvYmogOiBudWxsO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtjb2VyY2VCb29sZWFuUHJvcGVydHl9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIENvbXBvbmVudCxcbiAgQ29udGVudENoaWxkLFxuICBEaXJlY3RpdmUsXG4gIElucHV0LFxuICBPbkNoYW5nZXMsXG4gIE9uRGVzdHJveSxcbiAgU2ltcGxlQ2hhbmdlcyxcbiAgVmlld0VuY2Fwc3VsYXRpb24sXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHttZXJnZSwgb2YgYXMgb2JzZXJ2YWJsZU9mLCBTdWJzY3JpcHRpb259IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtTYXREYXRlcGlja2VyfSBmcm9tICcuL2RhdGVwaWNrZXInO1xuaW1wb3J0IHtTYXREYXRlcGlja2VySW50bH0gZnJvbSAnLi9kYXRlcGlja2VyLWludGwnO1xuXG5cbi8qKiBDYW4gYmUgdXNlZCB0byBvdmVycmlkZSB0aGUgaWNvbiBvZiBhIGBtYXREYXRlcGlja2VyVG9nZ2xlYC4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1ttYXREYXRlcGlja2VyVG9nZ2xlSWNvbl0nXG59KVxuZXhwb3J0IGNsYXNzIFNhdERhdGVwaWNrZXJUb2dnbGVJY29uIHt9XG5cblxuQENvbXBvbmVudCh7XG4gIG1vZHVsZUlkOiBtb2R1bGUuaWQsXG4gIHNlbGVjdG9yOiAnc2F0LWRhdGVwaWNrZXItdG9nZ2xlJyxcbiAgdGVtcGxhdGVVcmw6ICdkYXRlcGlja2VyLXRvZ2dsZS5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJ2RhdGVwaWNrZXItdG9nZ2xlLmNzcyddLFxuICBob3N0OiB7XG4gICAgJ2NsYXNzJzogJ21hdC1kYXRlcGlja2VyLXRvZ2dsZScsXG4gICAgJ1tjbGFzcy5tYXQtZGF0ZXBpY2tlci10b2dnbGUtYWN0aXZlXSc6ICdkYXRlcGlja2VyICYmIGRhdGVwaWNrZXIub3BlbmVkJyxcbiAgICAnW2NsYXNzLm1hdC1hY2NlbnRdJzogJ2RhdGVwaWNrZXIgJiYgZGF0ZXBpY2tlci5jb2xvciA9PT0gXCJhY2NlbnRcIicsXG4gICAgJ1tjbGFzcy5tYXQtd2Fybl0nOiAnZGF0ZXBpY2tlciAmJiBkYXRlcGlja2VyLmNvbG9yID09PSBcIndhcm5cIicsXG4gIH0sXG4gIGV4cG9ydEFzOiAnbWF0RGF0ZXBpY2tlclRvZ2dsZScsXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxufSlcbmV4cG9ydCBjbGFzcyBTYXREYXRlcGlja2VyVG9nZ2xlPEQ+IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuICBwcml2YXRlIF9zdGF0ZUNoYW5nZXMgPSBTdWJzY3JpcHRpb24uRU1QVFk7XG5cbiAgLyoqIERhdGVwaWNrZXIgaW5zdGFuY2UgdGhhdCB0aGUgYnV0dG9uIHdpbGwgdG9nZ2xlLiAqL1xuICBASW5wdXQoJ2ZvcicpIGRhdGVwaWNrZXI6IFNhdERhdGVwaWNrZXI8RD47XG5cbiAgLyoqIFdoZXRoZXIgdGhlIHRvZ2dsZSBidXR0b24gaXMgZGlzYWJsZWQuICovXG4gIEBJbnB1dCgpXG4gIGdldCBkaXNhYmxlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRoaXMuZGF0ZXBpY2tlci5kaXNhYmxlZCA6ICEhdGhpcy5fZGlzYWJsZWQ7XG4gIH1cbiAgc2V0IGRpc2FibGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fZGlzYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICB9XG4gIHByaXZhdGUgX2Rpc2FibGVkOiBib29sZWFuO1xuXG4gIC8qKiBDdXN0b20gaWNvbiBzZXQgYnkgdGhlIGNvbnN1bWVyLiAqL1xuICBAQ29udGVudENoaWxkKFNhdERhdGVwaWNrZXJUb2dnbGVJY29uKSBfY3VzdG9tSWNvbjogU2F0RGF0ZXBpY2tlclRvZ2dsZUljb247XG5cbiAgY29uc3RydWN0b3IocHVibGljIF9pbnRsOiBTYXREYXRlcGlja2VySW50bCwgcHJpdmF0ZSBfY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmKSB7fVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICBpZiAoY2hhbmdlcy5kYXRlcGlja2VyKSB7XG4gICAgICB0aGlzLl93YXRjaFN0YXRlQ2hhbmdlcygpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX3N0YXRlQ2hhbmdlcy51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIHRoaXMuX3dhdGNoU3RhdGVDaGFuZ2VzKCk7XG4gIH1cblxuICBfb3BlbihldmVudDogRXZlbnQpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5kYXRlcGlja2VyICYmICF0aGlzLmRpc2FibGVkKSB7XG4gICAgICB0aGlzLmRhdGVwaWNrZXIub3BlbigpO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfd2F0Y2hTdGF0ZUNoYW5nZXMoKSB7XG4gICAgY29uc3QgZGF0ZXBpY2tlckRpc2FibGVkID0gdGhpcy5kYXRlcGlja2VyID8gdGhpcy5kYXRlcGlja2VyLl9kaXNhYmxlZENoYW5nZSA6IG9ic2VydmFibGVPZigpO1xuICAgIGNvbnN0IGlucHV0RGlzYWJsZWQgPSB0aGlzLmRhdGVwaWNrZXIgJiYgdGhpcy5kYXRlcGlja2VyLl9kYXRlcGlja2VySW5wdXQgP1xuICAgICAgICB0aGlzLmRhdGVwaWNrZXIuX2RhdGVwaWNrZXJJbnB1dC5fZGlzYWJsZWRDaGFuZ2UgOiBvYnNlcnZhYmxlT2YoKTtcbiAgICBjb25zdCBkYXRlcGlja2VyVG9nZ2xlZCA9IHRoaXMuZGF0ZXBpY2tlciA/XG4gICAgICAgIG1lcmdlKHRoaXMuZGF0ZXBpY2tlci5vcGVuZWRTdHJlYW0sIHRoaXMuZGF0ZXBpY2tlci5jbG9zZWRTdHJlYW0pIDpcbiAgICAgICAgb2JzZXJ2YWJsZU9mKCk7XG5cbiAgICB0aGlzLl9zdGF0ZUNoYW5nZXMudW5zdWJzY3JpYmUoKTtcbiAgICB0aGlzLl9zdGF0ZUNoYW5nZXMgPSBtZXJnZShcbiAgICAgIHRoaXMuX2ludGwuY2hhbmdlcyxcbiAgICAgIGRhdGVwaWNrZXJEaXNhYmxlZCxcbiAgICAgIGlucHV0RGlzYWJsZWQsXG4gICAgICBkYXRlcGlja2VyVG9nZ2xlZFxuICAgICkuc3Vic2NyaWJlKCgpID0+IHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCB7QTExeU1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHtPdmVybGF5TW9kdWxlfSBmcm9tICdAYW5ndWxhci9jZGsvb3ZlcmxheSc7XG5pbXBvcnQge1BvcnRhbE1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BvcnRhbCc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtNYXRCdXR0b25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL2J1dHRvbic7XG5pbXBvcnQge01hdERpYWxvZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvZGlhbG9nJztcbmltcG9ydCB7U2F0Q2FsZW5kYXIsIFNhdENhbGVuZGFySGVhZGVyfSBmcm9tICcuL2NhbGVuZGFyJztcbmltcG9ydCB7U2F0Q2FsZW5kYXJCb2R5fSBmcm9tICcuL2NhbGVuZGFyLWJvZHknO1xuaW1wb3J0IHtcbiAgU2F0RGF0ZXBpY2tlcixcbiAgU2F0RGF0ZXBpY2tlckNvbnRlbnQsXG4gIE1BVF9EQVRFUElDS0VSX1NDUk9MTF9TVFJBVEVHWV9GQUNUT1JZX1BST1ZJREVSLFxufSBmcm9tICcuL2RhdGVwaWNrZXInO1xuaW1wb3J0IHtTYXREYXRlcGlja2VySW5wdXR9IGZyb20gJy4vZGF0ZXBpY2tlci1pbnB1dCc7XG5pbXBvcnQge1NhdERhdGVwaWNrZXJJbnRsfSBmcm9tICcuL2RhdGVwaWNrZXItaW50bCc7XG5pbXBvcnQge1NhdERhdGVwaWNrZXJUb2dnbGUsIFNhdERhdGVwaWNrZXJUb2dnbGVJY29ufSBmcm9tICcuL2RhdGVwaWNrZXItdG9nZ2xlJztcbmltcG9ydCB7U2F0TW9udGhWaWV3fSBmcm9tICcuL21vbnRoLXZpZXcnO1xuaW1wb3J0IHtTYXRNdWx0aVllYXJWaWV3fSBmcm9tICcuL211bHRpLXllYXItdmlldyc7XG5pbXBvcnQge1NhdFllYXJWaWV3fSBmcm9tICcuL3llYXItdmlldyc7XG5cblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW1xuICAgIENvbW1vbk1vZHVsZSxcbiAgICBNYXRCdXR0b25Nb2R1bGUsXG4gICAgTWF0RGlhbG9nTW9kdWxlLFxuICAgIE92ZXJsYXlNb2R1bGUsXG4gICAgQTExeU1vZHVsZSxcbiAgICBQb3J0YWxNb2R1bGUsXG4gIF0sXG4gIGV4cG9ydHM6IFtcbiAgICBTYXRDYWxlbmRhcixcbiAgICBTYXRDYWxlbmRhckJvZHksXG4gICAgU2F0RGF0ZXBpY2tlcixcbiAgICBTYXREYXRlcGlja2VyQ29udGVudCxcbiAgICBTYXREYXRlcGlja2VySW5wdXQsXG4gICAgU2F0RGF0ZXBpY2tlclRvZ2dsZSxcbiAgICBTYXREYXRlcGlja2VyVG9nZ2xlSWNvbixcbiAgICBTYXRNb250aFZpZXcsXG4gICAgU2F0WWVhclZpZXcsXG4gICAgU2F0TXVsdGlZZWFyVmlldyxcbiAgICBTYXRDYWxlbmRhckhlYWRlcixcbiAgXSxcbiAgZGVjbGFyYXRpb25zOiBbXG4gICAgU2F0Q2FsZW5kYXIsXG4gICAgU2F0Q2FsZW5kYXJCb2R5LFxuICAgIFNhdERhdGVwaWNrZXIsXG4gICAgU2F0RGF0ZXBpY2tlckNvbnRlbnQsXG4gICAgU2F0RGF0ZXBpY2tlcklucHV0LFxuICAgIFNhdERhdGVwaWNrZXJUb2dnbGUsXG4gICAgU2F0RGF0ZXBpY2tlclRvZ2dsZUljb24sXG4gICAgU2F0TW9udGhWaWV3LFxuICAgIFNhdFllYXJWaWV3LFxuICAgIFNhdE11bHRpWWVhclZpZXcsXG4gICAgU2F0Q2FsZW5kYXJIZWFkZXIsXG4gIF0sXG4gIHByb3ZpZGVyczogW1xuICAgIFNhdERhdGVwaWNrZXJJbnRsLFxuICAgIE1BVF9EQVRFUElDS0VSX1NDUk9MTF9TVFJBVEVHWV9GQUNUT1JZX1BST1ZJREVSLFxuICBdLFxuICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICBTYXREYXRlcGlja2VyQ29udGVudCxcbiAgICBTYXRDYWxlbmRhckhlYWRlcixcbiAgXVxufSlcbmV4cG9ydCBjbGFzcyBTYXREYXRlcGlja2VyTW9kdWxlIHt9XG4iXSwibmFtZXMiOlsiSW5qZWN0aW9uVG9rZW4iLCJpbmplY3QiLCJMT0NBTEVfSUQiLCJTdWJqZWN0IiwidHNsaWJfMS5fX2V4dGVuZHMiLCJwbGF0Zm9ybSIsIkluamVjdGFibGUiLCJPcHRpb25hbCIsIkluamVjdCIsIlBsYXRmb3JtIiwiTmdNb2R1bGUiLCJQbGF0Zm9ybU1vZHVsZSIsIkV2ZW50RW1pdHRlciIsInRha2UiLCJDb21wb25lbnQiLCJWaWV3RW5jYXBzdWxhdGlvbiIsIkNoYW5nZURldGVjdGlvblN0cmF0ZWd5IiwiRWxlbWVudFJlZiIsIk5nWm9uZSIsIklucHV0IiwiT3V0cHV0IiwiTEVGVF9BUlJPVyIsIlJJR0hUX0FSUk9XIiwiVVBfQVJST1ciLCJET1dOX0FSUk9XIiwiSE9NRSIsIkVORCIsIlBBR0VfVVAiLCJQQUdFX0RPV04iLCJFTlRFUiIsIkNoYW5nZURldGVjdG9yUmVmIiwiRGlyZWN0aW9uYWxpdHkiLCJWaWV3Q2hpbGQiLCJmb3J3YXJkUmVmIiwiQ29tcG9uZW50UG9ydGFsIiwidHJpZ2dlciIsInN0YXRlIiwic3R5bGUiLCJ0cmFuc2l0aW9uIiwiZ3JvdXAiLCJxdWVyeSIsImFuaW1hdGVDaGlsZCIsImFuaW1hdGUiLCJvdmVybGF5IiwiT3ZlcmxheSIsIm1peGluQ29sb3IiLCJTdWJzY3JpcHRpb24iLCJjb2VyY2VCb29sZWFuUHJvcGVydHkiLCJpbnB1dCIsIk92ZXJsYXlDb25maWciLCJtZXJnZSIsImZpbHRlciIsIkVTQ0FQRSIsIk1hdERpYWxvZyIsIlZpZXdDb250YWluZXJSZWYiLCJET0NVTUVOVCIsIk5HX1ZBTFVFX0FDQ0VTU09SIiwiTkdfVkFMSURBVE9SUyIsIlZhbGlkYXRvcnMiLCJEaXJlY3RpdmUiLCJNQVRfSU5QVVRfVkFMVUVfQUNDRVNTT1IiLCJNYXRGb3JtRmllbGQiLCJvYnNlcnZhYmxlT2YiLCJDb250ZW50Q2hpbGQiLCJDb21tb25Nb2R1bGUiLCJNYXRCdXR0b25Nb2R1bGUiLCJNYXREaWFsb2dNb2R1bGUiLCJPdmVybGF5TW9kdWxlIiwiQTExeU1vZHVsZSIsIlBvcnRhbE1vZHVsZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQVlBLE1BQWEsZUFBZSxHQUFHLElBQUlBLGlCQUFjLENBQVMsaUJBQWlCLEVBQUU7TUFDM0UsVUFBVSxFQUFFLE1BQU07TUFDbEIsT0FBTyxFQUFFLHVCQUF1QjtHQUNqQyxDQUFDLENBQUM7Ozs7O0FBR0g7TUFDRSxPQUFPQyxTQUFNLENBQUNDLFlBQVMsQ0FBQyxDQUFDO0dBQzFCOzs7Ozs7O0FBUUQsTUFBYSx3QkFBd0IsR0FBRyxFQUFDLE9BQU8sRUFBRSxlQUFlLEVBQUUsV0FBVyxFQUFFQSxZQUFTLEVBQUMsQ0FBQzs7Ozs7O0FBRzNGOzs7O01BQUE7O2dDQU02QixJQUFJQyxZQUFPLEVBQVE7O01BRDlDLHNCQUFJLHNDQUFhOzs7OztjQUFqQixjQUF3QyxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRTs7O1NBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUFxTHJFLGlDQUFXOzs7Ozs7Ozs7Ozs7VUFBWCxVQUFZLEtBQVU7Y0FDcEIsSUFBSSxLQUFLLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRTtrQkFDdEUsT0FBTyxLQUFLLENBQUM7ZUFDZDtjQUNELE9BQU8sSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1dBQ3ZCOzs7Ozs7Ozs7O01BTUQsK0JBQVM7Ozs7O1VBQVQsVUFBVSxNQUFXO2NBQ25CLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO2NBQ3JCLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLENBQUM7V0FDNUI7Ozs7Ozs7Ozs7Ozs7OztNQVNELGlDQUFXOzs7Ozs7O1VBQVgsVUFBWSxLQUFRLEVBQUUsTUFBUztj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V0FBVyxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsVUFBVSxDQUFDO01BQ3RGLE9BQU8sRUFBRSxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQztNQUMxRCxRQUFRLEVBQUUsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUM7R0FDOUMsQ0FBQzs7Ozs7RUFLRixJQUFNLGlCQUFpQixHQUFHO01BQ3hCLEVBQUUsRUFBQyxDQUFDLEVBQUUsRUFBRSxFQUFDLENBQUMsRUFBRSxPQUFPLEVBQUMsQ0FBQyxFQUFFLE9BQU8sRUFBQyxDQUFDLEVBQUUsT0FBTyxFQUFDLENBQUMsRUFBRSxFQUFFLEVBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBQyxDQUFDLEVBQUUsRUFBRSxFQUFDLENBQUMsRUFBRSxFQUFFLEVBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBQyxDQUFDLEVBQUUsRUFBRSxFQUFDLENBQUMsRUFBRSxFQUFFLEVBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBQyxDQUFDLEVBQUUsRUFBRSxFQUFDLENBQUM7TUFDakcsRUFBRSxFQUFDLENBQUMsRUFBRSxFQUFFLEVBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBQyxDQUFDLEVBQUUsT0FBTyxFQUFDLENBQUMsRUFBRSxPQUFPLEVBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBQyxDQUFDLEVBQUUsT0FBTyxFQUFDLENBQUMsRUFBRSxPQUFPLEVBQUMsQ0FBQyxFQUFFLE9BQU8sRUFBQyxDQUFDLEVBQUUsT0FBTyxFQUFDLENBQUMsRUFBRSxFQUFFLEVBQUMsQ0FBQztNQUM5RixFQUFFLEVBQUMsQ0FBQyxFQUFFLE9BQU8sRUFBQyxDQUFDLEVBQUUsRUFBRSxFQUFDLENBQUMsRUFBRSxFQUFFLEVBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBQyxDQUFDLEVBQUUsRUFBRSxFQUFDLENBQUMsRUFBRSxFQUFFLEVBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBQyxDQUFDLEVBQUUsT0FBTyxFQUFDLENBQUMsRUFBRSxFQUFFLEVBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBQyxDQUFDLEVBQUUsRUFBRSxFQUFDLENBQUMsRUFBRSxVQUFVLEVBQUMsQ0FBQztNQUM5RixFQUFFLEVBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBQyxDQUFDLEVBQUUsT0FBTyxFQUFDLENBQUMsRUFBRSxFQUFFLEVBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBQyxDQUFDLEVBQUUsRUFBRSxFQUFDLENBQUMsRUFBRSxFQUFFLEVBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBQyxDQUFDLEVBQUUsRUFBRSxFQUFDLENBQUMsRUFBRSxFQUFFLEVBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBQyxDQUFDLEVBQUUsRUFBRSxFQUFDLENBQUMsRUFBRSxFQUFFLEVBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBQyxDQUFDLEVBQUUsRUFBRSxFQUFDLENBQUM7TUFDN0YsRUFBRSxFQUFDLENBQUMsRUFBRSxFQUFFLEVBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBQyxDQUFDLEVBQUUsT0FBTyxFQUFDLENBQUMsRUFBRSxFQUFFLEVBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBQyxDQUFDLEVBQUUsRUFBRSxFQUFDLENBQUMsRUFBRSxFQUFFLEVBQUMsQ0FBQyxFQUFFLE9BQU8sRUFBQyxDQUFDLEVBQUUsRUFBRSxFQUFDLENBQUMsRUFBRSxFQUFFLEVBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBQyxDQUFDLEVBQUUsT0FBTyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBQyxDQUFDO01BQ3hHLEVBQUUsRUFBQyxDQUFDLEVBQUUsRUFBRSxFQUFDLENBQUMsRUFBRSxFQUFFLEVBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBQyxDQUFDLEVBQUUsRUFBRSxFQUFDLENBQUMsRUFBRSxFQUFFLEVBQUMsQ0FBQyxFQUFFLFNBQVMsRUFBQyxDQUFDLEVBQUUsRUFBRSxFQUFDLENBQUMsRUFBRSxFQUFFLEVBQUMs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